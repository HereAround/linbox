<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>linbox: NTL_ZZ_p Struct Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">linbox
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',false,false,'search.php','Search');
});
</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespace_lin_box.html">LinBox</a></li><li class="navelem"><a class="el" href="struct_lin_box_1_1_n_t_l___z_z__p.html">NTL_ZZ_p</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a>  </div>
  <div class="headertitle">
<div class="title">NTL_ZZ_p Struct Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Wrapper of zz_p from NTL.  
 <a href="struct_lin_box_1_1_n_t_l___z_z__p.html#details">More...</a></p>

<p><code>#include &lt;ntl-zz_p.h&gt;</code></p>
<div id="dynsection-0" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-0-trigger" src="closed.png" alt="+"/> Inheritance diagram for NTL_ZZ_p:</div>
<div id="dynsection-0-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-0-content" class="dyncontent" style="display:none;">
<div class="center"><img src="struct_lin_box_1_1_n_t_l___z_z__p__inherit__graph.png" border="0" usemap="#_n_t_l___z_z__p_inherit__map" alt="Inheritance graph"/></div>
<map name="_n_t_l___z_z__p_inherit__map" id="_n_t_l___z_z__p_inherit__map">
<area shape="rect" id="node2" href="class_lin_box_1_1_p_i_r__ntl___z_z__p.html" title="extend Wrapper of ZZ_p from NTL. " alt="" coords="5,80,117,107"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ad23995bae372364f0740029cec89c110"><td class="memItemLeft" align="right" valign="top">Element &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_lin_box_1_1_n_t_l___z_z__p.html#ad23995bae372364f0740029cec89c110">init</a> (Element &amp;x, const NTL::ZZ &amp;y) const</td></tr>
<tr class="memdesc:ad23995bae372364f0740029cec89c110"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization for NTL::ZZ.  <a href="#ad23995bae372364f0740029cec89c110">More...</a><br /></td></tr>
<tr class="separator:ad23995bae372364f0740029cec89c110"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b0b1537ccb0eb1b4c8588b48b7ad2e9"><td class="memItemLeft" align="right" valign="top">NTL::ZZ &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_lin_box_1_1_n_t_l___z_z__p.html#a0b0b1537ccb0eb1b4c8588b48b7ad2e9">convert</a> (NTL::ZZ &amp;x, const Element &amp;y) const</td></tr>
<tr class="memdesc:a0b0b1537ccb0eb1b4c8588b48b7ad2e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization for NTL::ZZ.  <a href="#a0b0b1537ccb0eb1b4c8588b48b7ad2e9">More...</a><br /></td></tr>
<tr class="separator:a0b0b1537ccb0eb1b4c8588b48b7ad2e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6bcc7e558d3d0bb05dae9d989753124"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__integers.html#ga69460c665a80daebb395e45f6f76db54">integer</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_lin_box_1_1_n_t_l___z_z__p.html#ac6bcc7e558d3d0bb05dae9d989753124">convert</a> (<a class="el" href="group__integers.html#ga69460c665a80daebb395e45f6f76db54">integer</a> &amp;x, const Element &amp;y) const</td></tr>
<tr class="memdesc:ac6bcc7e558d3d0bb05dae9d989753124"><td class="mdescLeft">&#160;</td><td class="mdescRight">Conversion of field element to an integer.  <a href="#ac6bcc7e558d3d0bb05dae9d989753124">More...</a><br /></td></tr>
<tr class="separator:ac6bcc7e558d3d0bb05dae9d989753124"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37344accf121d516241676bdc8ada7d3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__integers.html#ga69460c665a80daebb395e45f6f76db54">integer</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_lin_box_1_1_n_t_l___z_z__p.html#a37344accf121d516241676bdc8ada7d3">cardinality</a> (<a class="el" href="group__integers.html#ga69460c665a80daebb395e45f6f76db54">integer</a> &amp;c) const</td></tr>
<tr class="memdesc:a37344accf121d516241676bdc8ada7d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cardinality.  <a href="#a37344accf121d516241676bdc8ada7d3">More...</a><br /></td></tr>
<tr class="separator:a37344accf121d516241676bdc8ada7d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacfcf932e067281730164de4a8a52e7b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__integers.html#ga69460c665a80daebb395e45f6f76db54">integer</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_lin_box_1_1_n_t_l___z_z__p.html#aacfcf932e067281730164de4a8a52e7b">characteristic</a> (<a class="el" href="group__integers.html#ga69460c665a80daebb395e45f6f76db54">integer</a> &amp;c) const</td></tr>
<tr class="memdesc:aacfcf932e067281730164de4a8a52e7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Characteristic.  <a href="#aacfcf932e067281730164de4a8a52e7b">More...</a><br /></td></tr>
<tr class="separator:aacfcf932e067281730164de4a8a52e7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b04a8733ba45559bb499a1650354ed7"><td class="memItemLeft" align="right" valign="top">Element &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_lin_box_1_1_n_t_l___z_z__p.html#a8b04a8733ba45559bb499a1650354ed7">inv</a> (Element &amp;x, const Element &amp;y) const</td></tr>
<tr class="memdesc:a8b04a8733ba45559bb499a1650354ed7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplicative <a class="el" href="class_lin_box_1_1_inverse.html" title="A Blackbox for the inverse. ">Inverse</a>.  <a href="#a8b04a8733ba45559bb499a1650354ed7">More...</a><br /></td></tr>
<tr class="separator:a8b04a8733ba45559bb499a1650354ed7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2d88b93ea3b42832c57bd21f4ac20ad"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_lin_box_1_1_n_t_l___z_z__p.html#ac2d88b93ea3b42832c57bd21f4ac20ad">isZero</a> (const Element &amp;x) const</td></tr>
<tr class="memdesc:ac2d88b93ea3b42832c57bd21f4ac20ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Zero equality.  <a href="#ac2d88b93ea3b42832c57bd21f4ac20ad">More...</a><br /></td></tr>
<tr class="separator:ac2d88b93ea3b42832c57bd21f4ac20ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3d8079da446c30e84d0db1f94ca6ed4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_lin_box_1_1_n_t_l___z_z__p.html#ac3d8079da446c30e84d0db1f94ca6ed4">isOne</a> (const Element &amp;x) const</td></tr>
<tr class="memdesc:ac3d8079da446c30e84d0db1f94ca6ed4"><td class="mdescLeft">&#160;</td><td class="mdescRight">One equality.  <a href="#ac3d8079da446c30e84d0db1f94ca6ed4">More...</a><br /></td></tr>
<tr class="separator:ac3d8079da446c30e84d0db1f94ca6ed4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a0bab072ffee815b789cc912697fd93"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_lin_box_1_1_n_t_l___z_z__p.html#a2a0bab072ffee815b789cc912697fd93">isMOne</a> (const Element &amp;x) const</td></tr>
<tr class="memdesc:a2a0bab072ffee815b789cc912697fd93"><td class="mdescLeft">&#160;</td><td class="mdescRight">MOne equality.  <a href="#a2a0bab072ffee815b789cc912697fd93">More...</a><br /></td></tr>
<tr class="separator:a2a0bab072ffee815b789cc912697fd93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a035f29a9ef299930eddcd1fc9a16d4ef"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_lin_box_1_1_n_t_l___z_z__p.html#a035f29a9ef299930eddcd1fc9a16d4ef">isUnit</a> (const Element &amp;x) const</td></tr>
<tr class="memdesc:a035f29a9ef299930eddcd1fc9a16d4ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unit test.  <a href="#a035f29a9ef299930eddcd1fc9a16d4ef">More...</a><br /></td></tr>
<tr class="separator:a035f29a9ef299930eddcd1fc9a16d4ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad6eeaa33a4435e3f1de4d653d2df3e3"><td class="memItemLeft" align="right" valign="top">Element &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_lin_box_1_1_n_t_l___z_z__p.html#aad6eeaa33a4435e3f1de4d653d2df3e3">invin</a> (Element &amp;x) const</td></tr>
<tr class="memdesc:aad6eeaa33a4435e3f1de4d653d2df3e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inplace Multiplicative <a class="el" href="class_lin_box_1_1_inverse.html" title="A Blackbox for the inverse. ">Inverse</a>.  <a href="#aad6eeaa33a4435e3f1de4d653d2df3e3">More...</a><br /></td></tr>
<tr class="separator:aad6eeaa33a4435e3f1de4d653d2df3e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a318cf33cb3a667e37ffbdebc34053a"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_lin_box_1_1_n_t_l___z_z__p.html#a0a318cf33cb3a667e37ffbdebc34053a">write</a> (std::ostream &amp;os) const</td></tr>
<tr class="memdesc:a0a318cf33cb3a667e37ffbdebc34053a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print field.  <a href="#a0a318cf33cb3a667e37ffbdebc34053a">More...</a><br /></td></tr>
<tr class="separator:a0a318cf33cb3a667e37ffbdebc34053a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68775eeaf377adef11f8949e3fcf4a38"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_lin_box_1_1_n_t_l___z_z__p.html#a68775eeaf377adef11f8949e3fcf4a38">write</a> (std::ostream &amp;os, const Element &amp;x) const</td></tr>
<tr class="memdesc:a68775eeaf377adef11f8949e3fcf4a38"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print field.  <a href="#a68775eeaf377adef11f8949e3fcf4a38">More...</a><br /></td></tr>
<tr class="separator:a68775eeaf377adef11f8949e3fcf4a38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">NTL_ZZ_p</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>Arbitrary precision integers modulus a positive integer.</p>
<p>While NTL allows any integer to serve as the modulus, only prime moduli yield fields. Therefore, while arthmetic operations may be valid for any modulus, only prime moduli are supported in this implementation. The primality of the modulus will not be checked, so it is the programmer's responsibility to supply a prime modulus. These specializations allow the Givaro::ZRing template class to be used to wrap NTL's <code>ZZ_p</code> class as a <a class="el" href="namespace_lin_box.html" title="Namespace in which all linbox code resides. ">LinBox</a> field. </p>
</div></td></tr>
<tr class="memitem:a1bb67a53f02c0bd1467f907505b57fc3"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_lin_box_1_1_n_t_l___z_z__p.html#a1bb67a53f02c0bd1467f907505b57fc3">NTL_ZZ_p</a> (<a class="el" href="group__integers.html#ga69460c665a80daebb395e45f6f76db54">integer</a> q, size_t e=1)</td></tr>
<tr class="separator:a1bb67a53f02c0bd1467f907505b57fc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56c4eb4843262a27771f09534fe1d499"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_lin_box_1_1_n_t_l___z_z__p.html#a56c4eb4843262a27771f09534fe1d499">NTL_ZZ_p</a> (NTL::ZZ d, size_t e=1)</td></tr>
<tr class="separator:a56c4eb4843262a27771f09534fe1d499"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a561beb6830851f0e43b2ba993be0b365"><td class="memItemLeft" align="right" valign="top"><a id="a561beb6830851f0e43b2ba993be0b365"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_lin_box_1_1_n_t_l___z_z__p.html#a561beb6830851f0e43b2ba993be0b365">NTL_ZZ_p</a> ()</td></tr>
<tr class="memdesc:a561beb6830851f0e43b2ba993be0b365"><td class="mdescLeft">&#160;</td><td class="mdescRight">NULL constructor. <br /></td></tr>
<tr class="separator:a561beb6830851f0e43b2ba993be0b365"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Wrapper of zz_p from NTL. </p>
<p>Uses nice mod p via floating pt trick. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a1bb67a53f02c0bd1467f907505b57fc3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1bb67a53f02c0bd1467f907505b57fc3">&#9670;&nbsp;</a></span>NTL_ZZ_p() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_lin_box_1_1_n_t_l___z_z__p.html">NTL_ZZ_p</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__integers.html#ga69460c665a80daebb395e45f6f76db54">integer</a>&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>e</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">q,e</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a56c4eb4843262a27771f09534fe1d499"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56c4eb4843262a27771f09534fe1d499">&#9670;&nbsp;</a></span>NTL_ZZ_p() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_lin_box_1_1_n_t_l___z_z__p.html">NTL_ZZ_p</a> </td>
          <td>(</td>
          <td class="paramtype">NTL::ZZ&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>e</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">d,e</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ad23995bae372364f0740029cec89c110"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad23995bae372364f0740029cec89c110">&#9670;&nbsp;</a></span>init()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Element&amp; init </td>
          <td>(</td>
          <td class="paramtype">Element &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const NTL::ZZ &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Specialization for NTL::ZZ. </p>
<dl class="section return"><dt>Returns</dt><dd>reference to field element. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>field element to contain output (reference returned) </td></tr>
    <tr><td class="paramname">y</td><td>NTL::ZZ. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0b0b1537ccb0eb1b4c8588b48b7ad2e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b0b1537ccb0eb1b4c8588b48b7ad2e9">&#9670;&nbsp;</a></span>convert() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">NTL::ZZ&amp; convert </td>
          <td>(</td>
          <td class="paramtype">NTL::ZZ &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Element &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Specialization for NTL::ZZ. </p>
<dl class="section return"><dt>Returns</dt><dd>reference to NTL::ZZ </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>NTL::ZZ to contain output (reference returned). </td></tr>
    <tr><td class="paramname">y</td><td>constant reference to field element. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac6bcc7e558d3d0bb05dae9d989753124"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6bcc7e558d3d0bb05dae9d989753124">&#9670;&nbsp;</a></span>convert() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__integers.html#ga69460c665a80daebb395e45f6f76db54">integer</a>&amp; convert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__integers.html#ga69460c665a80daebb395e45f6f76db54">integer</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Element &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Conversion of field element to an integer. </p>
<p>This function assumes the output field element x has already been constructed, but that it is not already initialized. This done by converting to a std::string : inefficient but correct. </p><dl class="section return"><dt>Returns</dt><dd>reference to integer. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>reference to integer to contain output (reference returned). </td></tr>
    <tr><td class="paramname">y</td><td>constant reference to field element. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a37344accf121d516241676bdc8ada7d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37344accf121d516241676bdc8ada7d3">&#9670;&nbsp;</a></span>cardinality()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__integers.html#ga69460c665a80daebb395e45f6f76db54">integer</a>&amp; cardinality </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__integers.html#ga69460c665a80daebb395e45f6f76db54">integer</a> &amp;&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Cardinality. </p>
<p>Return integer representing cardinality of the field. Returns the modulus of the field, which should be prime. </p><dl class="section return"><dt>Returns</dt><dd>integer representing cardinality of the field </dd></dl>

</div>
</div>
<a id="aacfcf932e067281730164de4a8a52e7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aacfcf932e067281730164de4a8a52e7b">&#9670;&nbsp;</a></span>characteristic()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__integers.html#ga69460c665a80daebb395e45f6f76db54">integer</a>&amp; characteristic </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__integers.html#ga69460c665a80daebb395e45f6f76db54">integer</a> &amp;&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Characteristic. </p>
<p>Return integer representing characteristic of the field. Returns the modulus of the field, which should be prime. </p><dl class="section return"><dt>Returns</dt><dd>integer representing characteristic of the field. </dd></dl>

</div>
</div>
<a id="a8b04a8733ba45559bb499a1650354ed7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b04a8733ba45559bb499a1650354ed7">&#9670;&nbsp;</a></span>inv()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Element&amp; inv </td>
          <td>(</td>
          <td class="paramtype">Element &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Element &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiplicative <a class="el" href="class_lin_box_1_1_inverse.html" title="A Blackbox for the inverse. ">Inverse</a>. </p>
<p>x = 1 / y This function assumes both field elements have already been constructed and initialized. </p><dl class="section return"><dt>Returns</dt><dd>reference to x. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>field element (reference returned). </td></tr>
    <tr><td class="paramname">y</td><td>field element. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac2d88b93ea3b42832c57bd21f4ac20ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2d88b93ea3b42832c57bd21f4ac20ad">&#9670;&nbsp;</a></span>isZero()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool isZero </td>
          <td>(</td>
          <td class="paramtype">const Element &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Zero equality. </p>
<p>Test if field element is equal to zero. This function assumes the field element has already been constructed and initialized. In this specialization, NTL's IsZero function is called. </p><dl class="section return"><dt>Returns</dt><dd>boolean true if equals zero, false if not. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>field element. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac3d8079da446c30e84d0db1f94ca6ed4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3d8079da446c30e84d0db1f94ca6ed4">&#9670;&nbsp;</a></span>isOne()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool isOne </td>
          <td>(</td>
          <td class="paramtype">const Element &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>One equality. </p>
<p>Test if field element is equal to one. This function assumes the field element has already been constructed and initialized. In this specialization, NTL's IsOne function is called. </p><dl class="section return"><dt>Returns</dt><dd>boolean true if equals one, false if not. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>field element. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2a0bab072ffee815b789cc912697fd93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a0bab072ffee815b789cc912697fd93">&#9670;&nbsp;</a></span>isMOne()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool isMOne </td>
          <td>(</td>
          <td class="paramtype">const Element &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>MOne equality. </p>
<p>Test if field element is equal to one. This function assumes the field element has already been constructed and initialized. In this specialization, NTL's IsMOne function is called. </p><dl class="section return"><dt>Returns</dt><dd>boolean true if equals one, false if not. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>field element. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a035f29a9ef299930eddcd1fc9a16d4ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a035f29a9ef299930eddcd1fc9a16d4ef">&#9670;&nbsp;</a></span>isUnit()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool isUnit </td>
          <td>(</td>
          <td class="paramtype">const Element &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unit test. </p>
<p>Test if field element is invertible. This function assumes the field element has already been constructed and initialized. In this specialization, NTL's InvModStatus function is called. inline long InvModStatus(ZZ&amp; x, const ZZ&amp; a, const ZZ&amp; n) // if gcd(a,n) = 1, then ReturnValue = 0, x = a^{-1} mod n // otherwise, ReturnValue = 1, x = gcd(a, n) </p><dl class="section return"><dt>Returns</dt><dd>boolean true if invertible, false if not. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>field element. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aad6eeaa33a4435e3f1de4d653d2df3e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad6eeaa33a4435e3f1de4d653d2df3e3">&#9670;&nbsp;</a></span>invin()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Element&amp; invin </td>
          <td>(</td>
          <td class="paramtype">Element &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inplace Multiplicative <a class="el" href="class_lin_box_1_1_inverse.html" title="A Blackbox for the inverse. ">Inverse</a>. </p>
<p>x = 1 / x This function assumes both field elements have already been constructed and initialized. </p><dl class="section return"><dt>Returns</dt><dd>reference to x. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>field element (reference returned). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0a318cf33cb3a667e37ffbdebc34053a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a318cf33cb3a667e37ffbdebc34053a">&#9670;&nbsp;</a></span>write() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; write </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Print field. </p>
<dl class="section return"><dt>Returns</dt><dd>output stream to which field is written. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">os</td><td>output stream to which field is written. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a68775eeaf377adef11f8949e3fcf4a38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68775eeaf377adef11f8949e3fcf4a38">&#9670;&nbsp;</a></span>write() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; write </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Element &amp;&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Print field. </p>
<dl class="section return"><dt>Returns</dt><dd>output stream to which field is written. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">os</td><td>output stream to which field is written. </td></tr>
    <tr><td class="paramname">x</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this struct was generated from the following file:<ul>
<li><a class="el" href="ntl-zz__p_8h.html">ntl-zz_p.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Wed Jun 5 2019 14:05:44 for linbox by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
