<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>linbox: examples/omp_block_rank.C</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">linbox
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',false,false,'search.php','Search');
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">examples/omp_block_rank.C</div>  </div>
</div><!--header-->
<div class="contents">
<p>Block Wiedemann Rank with OpenMP</p>
<div class="fragment"><div class="line"><span class="comment">/*</span></div><div class="line"><span class="comment"> * examples/omp_block_rank.C</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * Copyright (C) 2010 J-G Dumas</span></div><div class="line"><span class="comment"> * ========LICENCE========</span></div><div class="line"><span class="comment"> * This file is part of the library LinBox.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * LinBox is free software: you can redistribute it and/or modify</span></div><div class="line"><span class="comment"> * it under the terms of the  GNU Lesser General Public</span></div><div class="line"><span class="comment"> * License as published by the Free Software Foundation; either</span></div><div class="line"><span class="comment"> * version 2.1 of the License, or (at your option) any later version.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * This library is distributed in the hope that it will be useful,</span></div><div class="line"><span class="comment"> * but WITHOUT ANY WARRANTY; without even the implied warranty of</span></div><div class="line"><span class="comment"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU</span></div><div class="line"><span class="comment"> * Lesser General Public License for more details.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * You should have received a copy of the GNU Lesser General Public</span></div><div class="line"><span class="comment"> * License along with this library; if not, write to the Free Software</span></div><div class="line"><span class="comment"> * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA</span></div><div class="line"><span class="comment"> * ========LICENCE========</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment"> * This file is part of LinBox.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> *   LinBox is free software: you can redistribute it and/or modify</span></div><div class="line"><span class="comment"> *   it under the terms of the GNU Lesser General Public License as</span></div><div class="line"><span class="comment"> *   published by the Free Software Foundation, either version 2 of</span></div><div class="line"><span class="comment"> *   the License, or (at your option) any later version.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> *   LinBox is distributed in the hope that it will be useful,</span></div><div class="line"><span class="comment"> *   but WITHOUT ANY WARRANTY; without even the implied warranty of</span></div><div class="line"><span class="comment"> *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span></div><div class="line"><span class="comment"> *   GNU Lesser General Public License for more details.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> *   You should have received a copy of the GNU Lesser General Public</span></div><div class="line"><span class="comment"> *   License along with LinBox.  If not, see</span></div><div class="line"><span class="comment"> *   &lt;http://www.gnu.org/licenses/&gt;.</span></div><div class="line"><span class="comment"> */</span></div><div class="line"></div><div class="line"><span class="preprocessor">#ifndef __GIVARO_USE_OPENMP</span></div><div class="line"><span class="preprocessor">#define __GIVARO_USE_OPENMP</span></div><div class="line"><span class="preprocessor">#endif</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="linbox-config_8h.html">linbox/linbox-config.h</a>&gt;</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;omp.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;givaro/givtimer.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;givaro/givpoly1crt.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="integer_8h.html">linbox/integer.h</a>&gt;</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="preprocessor">#ifndef __LINBOX_USE_OPENMP</span></div><div class="line"><span class="preprocessor">#error &quot;you have to compile this example with openmp enabled&quot;</span></div><div class="line"><span class="preprocessor">#endif</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">// **********************************************************</span></div><div class="line"><span class="comment">// Variable globale pour fixer le générateurs des FFT primes</span></div><div class="line"><span class="keyword">struct </span>FFTSeeder {</div><div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> seed;</div><div class="line">    FFTSeeder(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> s=0) : seed(s) {}</div><div class="line">    <span class="keywordtype">void</span> setseed(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> s=0) { seed=s; }</div><div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> operator()()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> this-&gt;seed; }</div><div class="line">};</div><div class="line">FFTSeeder  FFTgenerator;</div><div class="line"><span class="preprocessor">#define FFT_PRIME_SEED FFTgenerator()</span></div><div class="line"><span class="comment">// **********************************************************</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="preprocessor">#define LINBOX_EXTENSION_DEGREE_MAX 20</span></div><div class="line"><span class="preprocessor">#include &lt;givaro/gfq.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="modular_8h.html">linbox/ring/modular.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;linbox/blackbox/zero-one.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="diagonal_8h.html">linbox/blackbox/diagonal.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;linbox/solutions/rank.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;linbox/solutions/trace.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;linbox/util/matrix-stream.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="sigma-basis_8h.html">linbox/algorithms/sigma-basis.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;linbox/algorithms/block-massey-domain.h&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> Field&gt;</div><div class="line"><span class="keywordtype">void</span> extractLeftSigma(<span class="keyword">const</span> Field &amp;F,</div><div class="line">              std::vector&lt;<a name="_a0"></a><a class="code" href="class_lin_box_1_1_blas_matrix.html">LinBox::DenseMatrix&lt;Field&gt;</a> &gt;        &amp;S,</div><div class="line">              std::vector&lt;<a class="code" href="class_lin_box_1_1_blas_matrix.html">LinBox::DenseMatrix&lt;Field&gt;</a> &gt;&amp;SigmaBase,</div><div class="line">              std::vector&lt;size_t&gt;                       &amp;defect,</div><div class="line">              <span class="keywordtype">size_t</span>                                      block)</div><div class="line">{</div><div class="line"></div><div class="line">    <a name="_a1"></a><a class="code" href="class_lin_box_1_1_blas_matrix_domain.html">LinBox::BlasMatrixDomain&lt;Field&gt;</a> _BMD(F);</div><div class="line">    <span class="comment">// take the block rows which have lowest defect</span></div><div class="line">    <span class="comment">// compute permutation such that first block rows have lowest defect</span></div><div class="line">    std::vector&lt;size_t&gt; Perm(2*block);</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i=0;i&lt;2*block;++i)</div><div class="line">        Perm[i]=i;</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i=0;i&lt;2*block;++i) {</div><div class="line">        <span class="keywordtype">size_t</span> idx_min=i;</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> j=i+1;j&lt;2*block;++j)</div><div class="line">            <span class="keywordflow">if</span> (defect[j]&lt; defect[idx_min])</div><div class="line">                idx_min=j;</div><div class="line">        std::swap(defect[i],defect[idx_min]);</div><div class="line">        Perm[i]=idx_min;</div><div class="line">    }</div><div class="line">    <a name="_a2"></a><a class="code" href="class_lin_box_1_1_blas_permutation.html">LinBox::BlasPermutation&lt;size_t&gt;</a>  BPerm(Perm);</div><div class="line"></div><div class="line">    <span class="comment">// Apply BPerm to the Sigma Base</span></div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i=0;i&lt;SigmaBase.size();++i)</div><div class="line">        _BMD.<a name="a3"></a><a class="code" href="class_lin_box_1_1_blas_matrix_domain.html#aca2c932148a2451ac47d1299f1d4cc4a">mulin_right</a>(BPerm,SigmaBase[i]);</div><div class="line"></div><div class="line">    <span class="keywordtype">size_t</span> max=defect[0];</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i=0;i&lt;block;++i)</div><div class="line">        <span class="keywordflow">if</span> (defect[i] &gt; max)</div><div class="line">            max=defect[i];</div><div class="line"></div><div class="line">    <span class="comment">// prepare S to receive the sigma base</span></div><div class="line">    <span class="keyword">const</span> <a class="code" href="class_lin_box_1_1_blas_matrix.html">LinBox::DenseMatrix&lt;Field&gt;</a> <a class="code" href="namespace_lin_box_1_1_protected.html#addcb4363c84182b0a6866bc86f19ecf7">Zero</a>(F,block,block);</div><div class="line">    S.resize(max+1, Zero);</div><div class="line"></div><div class="line">    <span class="comment">// extract the sigma base</span></div><div class="line">    <span class="comment">//for (size_t k=0;k&lt;S.size();++k){</span></div><div class="line">    <span class="comment">//  for(size_t i=0;i&lt;block;++i)</span></div><div class="line">    <span class="comment">//      for (size_t j=0;j&lt;block;++j)</span></div><div class="line">    <span class="comment">//          S[k].setEntry(i,j, SigmaBase[k].getEntry(i,j));</span></div><div class="line">    <span class="comment">//}</span></div><div class="line"></div><div class="line">    <span class="comment">// extract the reverse sigma base</span></div><div class="line">    <span class="keywordflow">for</span>(<span class="keywordtype">size_t</span> i=0;i&lt;block;++i)</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> j=0;j&lt;=defect[i];++j){</div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> k=0;k&lt;block;++k)</div><div class="line">                S[defect[i]-j].setEntry(i,k, SigmaBase[j].<a class="code" href="namespace_lin_box.html#ab391e49b8420d85600bb3b961add5489">getEntry</a>(i,k));</div><div class="line"></div><div class="line">        }</div><div class="line"></div><div class="line"></div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> Field&gt;</div><div class="line"><span class="keywordtype">void</span> write_sigma(<span class="keyword">const</span> Field &amp;F, <span class="keyword">const</span> <span class="keywordtype">char</span>* name, <span class="keyword">const</span> std::vector&lt;<a class="code" href="class_lin_box_1_1_blas_matrix.html">LinBox::DenseMatrix&lt;Field&gt;</a> &gt; &amp; P)</div><div class="line">{</div><div class="line">    <span class="keywordtype">size_t</span> m,n;</div><div class="line">    m = P[0].rowdim();</div><div class="line">    n = P[0].coldim();</div><div class="line">    std::cerr&lt;&lt;name&lt;&lt;<span class="stringliteral">&quot;:=[&quot;</span>;</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> k=0;k&lt;P.size()-1;++k){</div><div class="line">        std::cerr&lt;&lt;<span class="stringliteral">&quot;Matrix([&quot;</span>;</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i=0;i&lt;m-1;++i){</div><div class="line">            std::cerr&lt;&lt;<span class="stringliteral">&quot;[&quot;</span>;</div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> j=0;j&lt;n-1;++j)</div><div class="line">                F.write(std::cerr,P[k].getEntry(i,j))&lt;&lt;<span class="stringliteral">&quot;,&quot;</span>;</div><div class="line">            F.write(std::cerr, P[k].<a class="code" href="namespace_lin_box.html#ab391e49b8420d85600bb3b961add5489">getEntry</a>(i,n-1))&lt;&lt;<span class="stringliteral">&quot;] , &quot;</span>;</div><div class="line">        }</div><div class="line">        std::cerr&lt;&lt;<span class="stringliteral">&quot;[&quot;</span>;</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> j=0;j&lt;n-1;++j)</div><div class="line">            F.write(std::cerr,P[k].getEntry(m-1,j))&lt;&lt;<span class="stringliteral">&quot;,&quot;</span>;</div><div class="line">        F.write(std::cerr, P[k].<a class="code" href="namespace_lin_box.html#ab391e49b8420d85600bb3b961add5489">getEntry</a>(m-1,n-1))&lt;&lt;<span class="stringliteral">&quot;]]) , &quot;</span>;</div><div class="line">    }</div><div class="line"></div><div class="line">    std::cerr&lt;&lt;<span class="stringliteral">&quot;Matrix([&quot;</span>;</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i=0;i&lt;m-1;++i){</div><div class="line">        std::cerr&lt;&lt;<span class="stringliteral">&quot;[&quot;</span>;</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> j=0;j&lt;n-1;++j)</div><div class="line">            F.write(std::cerr,P[P.size()-1].getEntry(i,j))&lt;&lt;<span class="stringliteral">&quot;,&quot;</span>;</div><div class="line">        F.write(std::cerr, P[P.size()-1].getEntry(i,n-1))&lt;&lt;<span class="stringliteral">&quot;] , &quot;</span>;</div><div class="line">    }</div><div class="line">    std::cerr&lt;&lt;<span class="stringliteral">&quot;[&quot;</span>;</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> j=0;j&lt;n-1;++j)</div><div class="line">        F.write(std::cerr,P[P.size()-1].getEntry(m-1,j))&lt;&lt;<span class="stringliteral">&quot;,&quot;</span>;</div><div class="line">    F.write(std::cerr, P[P.size()-1].getEntry(m-1,n-1))&lt;&lt;<span class="stringliteral">&quot;]])]; \n&quot;</span>;</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> Container, <span class="keyword">class</span> Field&gt;</div><div class="line"><span class="keywordtype">void</span> scalarmulin(Container&amp; C, <span class="keyword">const</span> Field&amp; F, <span class="keyword">const</span> <span class="keyword">typename</span> Field::Element&amp; x)</div><div class="line">{</div><div class="line">    <span class="keywordflow">for</span>(<span class="keyword">typename</span> Container::Iterator it=C.Begin();it!=C.End();++it)</div><div class="line">        F.mulin(*it, x);</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> Container1, <span class="keyword">class</span> Field, <span class="keyword">class</span> Container2&gt;</div><div class="line"><span class="keywordtype">void</span> contaddin(Container1&amp; C, <span class="keyword">const</span> Field&amp; F, <span class="keyword">const</span> Container2&amp; V)</div><div class="line">{</div><div class="line">    <span class="keyword">typename</span> Container1::Iterator cit=C.Begin();</div><div class="line">    <span class="keyword">typename</span> Container2::ConstIterator vit=V.Begin();</div><div class="line">    <span class="keywordflow">for</span>( ; cit!=C.End(); ++cit, ++vit)</div><div class="line">        F.addin(*cit, *vit);</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> Field, <span class="keyword">class</span> Array, <span class="keyword">class</span> Matrix&gt;</div><div class="line"><span class="keywordtype">void</span> EvalPolyMat(Array&amp; EvalDets, <span class="keyword">const</span> Field&amp; F, <span class="keyword">const</span> <a class="code" href="class_lin_box_1_1_blas_matrix_domain.html">LinBox::BlasMatrixDomain&lt;Field&gt;</a>&amp; D, <span class="keyword">const</span> std::vector&lt;Matrix&gt;&amp; matminpol, <span class="keyword">const</span> Array&amp; Points)</div><div class="line">{</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">long</span> nump = Points.size();</div><div class="line">    std::cerr &lt;&lt; <span class="stringliteral">&quot;num procs: &quot;</span> &lt;&lt; omp_get_num_procs() &lt;&lt; std::endl;</div><div class="line">    std::cerr &lt;&lt; <span class="stringliteral">&quot;max threads: &quot;</span> &lt;&lt; omp_get_max_threads() &lt;&lt; std::endl;</div><div class="line">    std::cerr &lt;&lt; <span class="stringliteral">&quot;eval points: &quot;</span> &lt;&lt; nump &lt;&lt; std::endl;</div><div class="line"><span class="preprocessor">#pragma omp parallel for schedule(static)</span></div><div class="line">    <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=0; i&lt;nump; ++i) {</div><div class="line">        <span class="keyword">const</span> <span class="keywordtype">long</span> degree = matminpol.size()-1;</div><div class="line">        <a name="_a4"></a><a class="code" href="class_lin_box_1_1_blas_matrix.html">Matrix</a> mat=matminpol[degree];</div><div class="line">        <span class="keywordflow">for</span>(<span class="keywordtype">int</span> j=(<span class="keywordtype">int</span>)degree-1;j&gt;=0;--j) {</div><div class="line">            scalarmulin(mat, F, Points[i]);</div><div class="line">            contaddin(mat, F, matminpol[j]);</div><div class="line">        }</div><div class="line">        EvalDets[i] = D.<a name="a5"></a><a class="code" href="class_lin_box_1_1_blas_matrix_domain.html#a68ec61d979424bfdbc5a4d20fc8a00ed">det</a>(mat);</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">//     for(int i=0; i&lt;nump; ++i) {</span></div><div class="line">    <span class="comment">//         std::cerr &lt;&lt; Points[i] &lt;&lt; &quot;\t: &quot; &lt;&lt; EvalDets[i] &lt;&lt; std::endl;</span></div><div class="line">    <span class="comment">//     }</span></div><div class="line">}</div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="whisart__trace_8h.html">linbox/algorithms/whisart_trace.h</a>&gt;</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">using namespace </span><a class="code" href="namespace_givaro.html">Givaro</a>;</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> Field&gt;</div><div class="line"><span class="keywordtype">int</span> OMP_BLOCK_RANK_main (<span class="keyword">const</span> Field&amp; F, <span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> **argv)</div><div class="line">{</div><div class="line">    LinBox::commentator().<a name="a6"></a>setMaxDetailLevel (-1);</div><div class="line">    LinBox::commentator().<a name="a7"></a>setMaxDepth (-1);</div><div class="line">    LinBox::commentator().<a name="a8"></a>setReportStream (std::cerr);</div><div class="line"></div><div class="line">    OMPTimer chrono1,chrono2,chrono3,chrono4; chrono1.clear(); chrono2.clear(); chrono3.clear(); chrono4.clear();</div><div class="line"></div><div class="line">    Integer c; F.cardinality(c);</div><div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> seed = (argc&gt;4?atoi(argv[4]):0);</div><div class="line">    FFTgenerator.setseed(seed);</div><div class="line"></div><div class="line">    <span class="keyword">typename</span> Field::RandIter generator (F,c,seed);</div><div class="line">    LinBox::VectorDomain&lt;Field&gt; VD(F);</div><div class="line"></div><div class="line">    std::ifstream input (argv[1]);</div><div class="line">    <a name="_a9"></a><a class="code" href="class_lin_box_1_1_matrix_stream.html">LinBox::MatrixStream&lt;Field&gt;</a> ms( F, input );</div><div class="line">    <span class="keyword">typedef</span> LinBox::SparseMatrix&lt;Field, LinBox::SparseMatrixFormat::SparseSeq &gt; Blackbox;</div><div class="line">    <span class="keyword">typedef</span> <a class="code" href="class_lin_box_1_1_blas_matrix.html">LinBox::DenseMatrix&lt;Field&gt;</a> Block_t;</div><div class="line"></div><div class="line">    Blackbox B (ms);</div><div class="line"></div><div class="line">    std::cerr &lt;&lt; <span class="stringliteral">&quot;B is &quot;</span> &lt;&lt; B.rowdim() &lt;&lt; <span class="stringliteral">&quot; by &quot;</span> &lt;&lt; B.coldim() &lt;&lt; std::endl;</div><div class="line">    <span class="keywordtype">long</span> M = B.rowdim() ;</div><div class="line">    <span class="keywordtype">long</span> N = B.coldim();</div><div class="line">    <span class="keywordtype">long</span> R = (M&lt;N?M:N);</div><div class="line">    <span class="keywordtype">long</span> S = (M&gt;N?M:N);</div><div class="line"></div><div class="line">    <span class="keywordtype">int</span> nb = (argc&gt;3 ? atoi(argv[3]) : omp_get_max_threads() );</div><div class="line">    std::cerr &lt;&lt; <span class="stringliteral">&quot;block size: &quot;</span> &lt;&lt; nb &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    chrono1.start();</div><div class="line">    std::vector&lt; std::vector&lt; typename Field::Element &gt; &gt; LV(nb);</div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">typename</span> std::vector&lt; std::vector&lt; typename Field::Element &gt; &gt;::iterator it = LV.begin(); it != LV.end(); ++it) {</div><div class="line">        it-&gt;resize(R);</div><div class="line">        <span class="keywordflow">for</span>(<span class="keyword">typename</span> std::vector&lt;typename Field::Element&gt;::iterator vit=it-&gt;begin(); vit != it-&gt;end(); ++vit)</div><div class="line">            generator.random( *vit );</div><div class="line">        <span class="comment">//      VD.write(output, *it) &lt;&lt; std::endl;</span></div><div class="line">    }</div><div class="line"></div><div class="line">    Block_t LM(F, nb, R);</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i=0; i &lt; LM.rowdim(); ++i) {</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> j=0; j &lt; LM.coldim(); ++j) {</div><div class="line">            LM.setEntry(i,j, LV[i][j]);</div><div class="line">        }</div><div class="line">    }</div><div class="line"></div><div class="line">    chrono1.stop();</div><div class="line"></div><div class="line">    std::cerr &lt;&lt; <span class="stringliteral">&quot;Generated &quot;</span> &lt;&lt; nb &lt;&lt; <span class="charliteral">&#39; &#39;</span> &lt;&lt; R &lt;&lt; <span class="stringliteral">&quot;-vectors&quot;</span> &lt;&lt; std::endl;</div><div class="line">    std::cerr &lt;&lt; chrono1 &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    chrono2.start();</div><div class="line"></div><div class="line">    <span class="keyword">typedef</span> <a class="code" href="class_lin_box_1_1_blas_matrix.html">LinBox::DenseMatrix&lt;Field&gt;</a>        <a class="code" href="class_lin_box_1_1_blas_matrix.html">Matrix</a>;</div><div class="line">    <span class="keyword">typedef</span> std::vector&lt;Matrix&gt;   Polynomial;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">const</span> Matrix SigmaZero(F, 2*nb,2*nb);</div><div class="line">    <span class="keyword">const</span> Matrix SerieZero(F, 2*nb,nb);</div><div class="line"></div><div class="line">    <span class="keywordtype">long</span> d = 4+(R&lt;&lt;1)/nb;</div><div class="line"></div><div class="line">    <span class="comment">// define the serie and the sigmabase</span></div><div class="line">    Polynomial Serie(d, SerieZero);</div><div class="line">    Polynomial Sigma(d, SigmaZero);</div><div class="line"></div><div class="line"></div><div class="line">    LinBox::DenseVector&lt;Field&gt; d1(F,S);</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; S; i++)</div><div class="line">        <span class="keywordflow">do</span> generator.random (d1[i]); <span class="keywordflow">while</span> (F.isZero (d1[i]));</div><div class="line">    <a name="_a10"></a><a class="code" href="class_lin_box_1_1_diagonal.html">LinBox::Diagonal&lt;Field&gt;</a> D1 (d1);</div><div class="line">    LinBox::DenseVector&lt;Field&gt; d2(F,R);</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; R; i++)</div><div class="line">        <span class="keywordflow">do</span> generator.random (d2[i]); <span class="keywordflow">while</span> (F.isZero (d2[i]));</div><div class="line">    <a class="code" href="class_lin_box_1_1_diagonal.html">LinBox::Diagonal&lt;Field&gt;</a> D2 (d2);</div><div class="line"></div><div class="line">    std::cerr &lt;&lt; <span class="stringliteral">&quot;num procs: &quot;</span> &lt;&lt; omp_get_num_procs() &lt;&lt; std::endl;</div><div class="line">    std::cerr &lt;&lt; <span class="stringliteral">&quot;max threads: &quot;</span> &lt;&lt; omp_get_max_threads() &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> (M&gt;N) {</div><div class="line"><span class="preprocessor">#pragma omp parallel for firstprivate(B) schedule(static)</span></div><div class="line">        <span class="keywordflow">for</span>(<span class="keywordtype">int</span> j=0; j&lt;nb; ++j) {</div><div class="line">            std::vector&lt; typename Field::Element &gt; v(S),u(S),w(R);</div><div class="line">            std::vector&lt; typename Field::Element &gt; colonne(nb);</div><div class="line"></div><div class="line">            LM.apply(colonne, LV[j]);</div><div class="line">            <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=0;i&lt;nb;++i)</div><div class="line">                Serie[0].setEntry(i,j,colonne[i]);</div><div class="line"></div><div class="line">            <span class="keywordflow">for</span>(<span class="keywordtype">int</span> k=1;k&lt;d;++k) {</div><div class="line">                <span class="comment">// BlackBox Apply</span></div><div class="line">                D2.apply(w,LV[j]);</div><div class="line">                B.apply(v,w);</div><div class="line">                D1.apply(u,v);</div><div class="line">                B.applyTranspose(w,u);</div><div class="line">                D2.apply(LV[j],w);</div><div class="line"></div><div class="line">                <span class="comment">// Dot products</span></div><div class="line">                LM.apply(colonne, LV[j]);</div><div class="line">                <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=0;i&lt;nb;++i)</div><div class="line">                    Serie[k].setEntry(i,j,colonne[i]);</div><div class="line">            }</div><div class="line">            std::cerr &lt;&lt; <span class="stringliteral">&quot;Thread[&quot;</span> &lt;&lt; omp_get_thread_num() &lt;&lt; <span class="stringliteral">&quot;]: Done BTB-Serie[k][&quot;</span> &lt;&lt; j &lt;&lt; <span class="charliteral">&#39;]&#39;</span> &lt;&lt; std::endl;</div><div class="line">        }</div><div class="line">    }</div><div class="line">    <span class="keywordflow">else</span> {</div><div class="line"><span class="preprocessor">#pragma omp parallel for firstprivate(B) schedule(static)</span></div><div class="line">        <span class="keywordflow">for</span>(<span class="keywordtype">int</span> j=0; j&lt;nb; ++j) {</div><div class="line">            std::vector&lt; typename Field::Element &gt; v(S),u(S),w(R);</div><div class="line">            std::vector&lt; typename Field::Element &gt; colonne(nb);</div><div class="line"></div><div class="line">            LM.apply(colonne, LV[j]);</div><div class="line">            <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=0;i&lt;nb;++i)</div><div class="line">                Serie[0].setEntry(i,j,colonne[i]);</div><div class="line"></div><div class="line">            <span class="keywordflow">for</span>(<span class="keywordtype">int</span> k=1;k&lt;d;++k) {</div><div class="line">                <span class="comment">// BlackBox Apply</span></div><div class="line">                D2.apply(w,LV[j]);</div><div class="line">                B.applyTranspose(v,w);</div><div class="line">                D1.apply(u,v);</div><div class="line">                B.apply(w,u);</div><div class="line">                D2.apply(LV[j],w);</div><div class="line"></div><div class="line">                <span class="comment">// Dot products</span></div><div class="line">                LM.apply(colonne, LV[j]);</div><div class="line">                <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=0;i&lt;nb;++i)</div><div class="line">                    Serie[k].setEntry(i,j,colonne[i]);</div><div class="line"></div><div class="line">            }</div><div class="line">            std::cerr &lt;&lt; <span class="stringliteral">&quot;Thread[&quot;</span> &lt;&lt; omp_get_thread_num() &lt;&lt; <span class="stringliteral">&quot;]: Done BBT-Serie[k][&quot;</span> &lt;&lt; j &lt;&lt; <span class="charliteral">&#39;]&#39;</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">        }</div><div class="line">    }</div><div class="line"></div><div class="line">    chrono2.stop();</div><div class="line">    std::cerr &lt;&lt; <span class="stringliteral">&quot;Computed a degree &quot;</span> &lt;&lt; d &lt;&lt; <span class="charliteral">&#39; &#39;</span> &lt;&lt; nb &lt;&lt; <span class="charliteral">&#39;x&#39;</span> &lt;&lt; nb &lt;&lt; <span class="stringliteral">&quot;-series&quot;</span> &lt;&lt; std::endl;</div><div class="line">    std::cerr &lt;&lt; chrono2 &lt;&lt; std::endl;</div><div class="line">    <span class="comment">// write_sigma(F, &quot;serie&quot;, Serie);</span></div><div class="line"></div><div class="line">    chrono3.start();</div><div class="line">    <span class="comment">// append Identity to the serie</span></div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0;i&lt;nb;++i)</div><div class="line">        F.assign(Serie[0].refEntry(nb+i,i), F.one);</div><div class="line"></div><div class="line">    <span class="comment">// define defect</span></div><div class="line">    std::vector&lt;size_t&gt; defect(2*nb,0);</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=nb;i&lt;2*nb;++i){</div><div class="line">        defect[i]=1;</div><div class="line">    }</div><div class="line"></div><div class="line"></div><div class="line">    <a name="_a11"></a><a class="code" href="class_lin_box_1_1_sigma_basis.html">LinBox::SigmaBasis&lt;Field&gt;</a> SB(F, Serie);</div><div class="line">    std::cerr&lt;&lt;<span class="stringliteral">&quot;blockminpoly computation... &quot;</span>;</div><div class="line">    SB.<a name="a12"></a>PM_Basis(Sigma, Serie, d-1, defect);</div><div class="line">    std::cerr&lt;&lt;<span class="stringliteral">&quot;done\n&quot;</span>;</div><div class="line">    <span class="comment">// write_sigma(F, &quot;serie&quot;, Serie);</span></div><div class="line">    <span class="comment">// write_sigma(F, &quot;sigma&quot;, Sigma);</span></div><div class="line"></div><div class="line">    std::cerr&lt;&lt;<span class="stringliteral">&quot;extracting bminpoly... &quot;</span>;</div><div class="line">    std::vector&lt;Matrix&gt; LS2;</div><div class="line">    extractLeftSigma(F, LS2, Sigma, defect, nb);</div><div class="line">    std::cerr&lt;&lt;<span class="stringliteral">&quot;done with size: &quot;</span> &lt;&lt; LS2.size() &lt;&lt; std::endl;</div><div class="line">    std::cerr&lt;&lt;<span class="stringliteral">&quot;Rank of the highest degree coefficient...&quot;</span>;</div><div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> rdeg;</div><div class="line">    <a class="code" href="class_lin_box_1_1_blas_matrix_domain.html">LinBox::BlasMatrixDomain&lt;Field&gt;</a> D(F);</div><div class="line">    rdeg = D.<a name="a13"></a><a class="code" href="class_lin_box_1_1_blas_matrix_domain.html#a7ee81217964cbbed1c73849241f74456">rank</a>(LS2[LS2.size()-1]);</div><div class="line">    <span class="keyword">typename</span> Field::Element d0,de;</div><div class="line">    d0 = D.<a class="code" href="class_lin_box_1_1_blas_matrix_domain.html#a68ec61d979424bfdbc5a4d20fc8a00ed">det</a>(LS2[0]);</div><div class="line">    de = D.<a class="code" href="class_lin_box_1_1_blas_matrix_domain.html#a68ec61d979424bfdbc5a4d20fc8a00ed">det</a>(LS2[LS2.size()-2]);</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span>( ! ( F.isZero(d0) || F.isZero(de) ) )</div><div class="line">    {</div><div class="line">        <span class="keywordtype">int</span> <a name="a14"></a><a class="code" href="group__solutions.html#gaf81b9dc67cedf2044133b59399dd2334">rank</a> = (int) ((LS2.size()-2)*(LS2[0].rowdim())+rdeg);</div><div class="line"></div><div class="line">        chrono3.stop();</div><div class="line">        std::cerr&lt;&lt;<span class="stringliteral">&quot;is &quot;</span> &lt;&lt; rdeg &lt;&lt; <span class="stringliteral">&quot;, done.\n&quot;</span>;</div><div class="line">        std::cerr &lt;&lt; <span class="stringliteral">&quot;Estimated rank: &quot;</span> &lt;&lt; rank &lt;&lt; std::endl;</div><div class="line">    }</div><div class="line">    <span class="keywordflow">else</span> {</div><div class="line">        chrono3.stop();</div><div class="line">        std::cerr&lt;&lt;  <span class="stringliteral">&quot;\n*** WARNING *** Insufficient information, interpolation required. You might also try again with a larger field.\n&quot;</span>;</div><div class="line">        F.write(std::cerr&lt;&lt;  <span class="stringliteral">&quot;det(bm[0]): &quot;</span>, d0) &lt;&lt; std::endl;</div><div class="line">        std::cerr&lt;&lt;  <span class="stringliteral">&quot;rk(bm[0]): &quot;</span> &lt;&lt; D.<a class="code" href="class_lin_box_1_1_blas_matrix_domain.html#a7ee81217964cbbed1c73849241f74456">rank</a>(LS2[0])&lt;&lt; std::endl;</div><div class="line">        F.write(std::cerr&lt;&lt;  <span class="stringliteral">&quot;det(bm[&quot;</span> &lt;&lt; (LS2.size()-2) &lt;&lt; <span class="stringliteral">&quot;]): &quot;</span>, de) &lt;&lt; std::endl;</div><div class="line">        std::cerr&lt;&lt;  <span class="stringliteral">&quot;rk(bm[&quot;</span> &lt;&lt; (LS2.size()-2) &lt;&lt; <span class="stringliteral">&quot;]): &quot;</span>&lt;&lt; D.<a class="code" href="class_lin_box_1_1_blas_matrix_domain.html#a7ee81217964cbbed1c73849241f74456">rank</a>(LS2[LS2.size()-2]) &lt;&lt; std::endl;</div><div class="line">        std::cerr&lt;&lt;  <span class="stringliteral">&quot;rk(bm[&quot;</span> &lt;&lt; (LS2.size()-1) &lt;&lt; <span class="stringliteral">&quot;]): &quot;</span>&lt;&lt; rdeg &lt;&lt; std::endl;</div><div class="line">        <span class="keywordtype">long</span> def=0;</div><div class="line">        <span class="keywordflow">if</span> (F.isZero(d0)) ++def;</div><div class="line">        <span class="keywordflow">if</span> (F.isZero(de)) ++def;</div><div class="line">        <span class="keywordtype">int</span> <a class="code" href="group__solutions.html#gaf81b9dc67cedf2044133b59399dd2334">rank</a> =  (int) ((LS2.size()-2-def)*(LS2[0].rowdim())+rdeg);</div><div class="line">        std::cerr&lt;&lt; <span class="stringliteral">&quot;*** VERY ROUGH *** rank approximation  &quot;</span> &lt;&lt; rank &lt;&lt; std::endl;</div><div class="line">    }</div><div class="line">    std::cerr &lt;&lt; <span class="stringliteral">&quot;recursive PMBasis CPU time (s)  : &quot;</span> &lt;&lt; chrono3.usertime() &lt;&lt; std::endl&lt;&lt;std::endl;</div><div class="line">    std::cerr &lt;&lt; chrono3 &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    chrono4.start();</div><div class="line"></div><div class="line"></div><div class="line">    std::cerr&lt;&lt;<span class="stringliteral">&quot;Interpolation of matrix minpoly determinant ...&quot;</span>;</div><div class="line"></div><div class="line">    <span class="comment">// write_sigma(F, &quot;bminpoly&quot;, LS2);</span></div><div class="line"></div><div class="line">    <span class="keyword">typedef</span> Poly1CRT&lt;Field&gt;   PolyCRT;</div><div class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> PolyCRT::array_T VScal;</div><div class="line"></div><div class="line">    VScal EvalPoints( LS2.size()*nb );</div><div class="line">    <span class="keywordflow">for</span>(<span class="keyword">typename</span> VScal::iterator itp = EvalPoints.begin(); itp != EvalPoints.end(); ++itp) {</div><div class="line">        <span class="keywordflow">do</span> {</div><div class="line">            <span class="keywordflow">do</span> generator.random (*itp); <span class="keywordflow">while</span> (F.isZero (*itp));</div><div class="line">        } <span class="keywordflow">while</span> ( (std::find(EvalPoints.begin(), itp, *itp) != itp)) ;</div><div class="line">    }</div><div class="line"></div><div class="line">    VScal EvalDets( EvalPoints.size() );</div><div class="line">    EvalPolyMat(EvalDets, F, D, LS2, EvalPoints);</div><div class="line"></div><div class="line"></div><div class="line">    PolyCRT Interpolator(F, EvalPoints, <span class="stringliteral">&quot;Y&quot;</span>);</div><div class="line">    <span class="keyword">typename</span> PolyCRT::Element Determinant;</div><div class="line"></div><div class="line">    Interpolator.RnsToRing(Determinant, EvalDets);</div><div class="line">    chrono4.stop();</div><div class="line"></div><div class="line">    std::cerr &lt;&lt; <span class="stringliteral">&quot;done\n&quot;</span>;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">//     Interpolator.write(std::cerr &lt;&lt; &quot;Determinant of MinPoly: &quot;, Determinant) &lt;&lt; std::endl;</span></div><div class="line"></div><div class="line">    Degree deg; Interpolator.getpolydom().degree(deg, Determinant);</div><div class="line">    Degree val; Interpolator.getpolydom().val(val, Determinant);</div><div class="line"></div><div class="line"></div><div class="line">    F.write(std::cerr, Determinant[0]) &lt;&lt; <span class="stringliteral">&quot; + &quot;</span>;</div><div class="line">    <span class="keywordflow">if</span> (val &gt; 0) F.write(std::cerr&lt;&lt; <span class="stringliteral">&quot;... + &quot;</span>, Determinant[val.value()]) &lt;&lt; <span class="stringliteral">&quot;Y^&quot;</span> &lt;&lt; val &lt;&lt; <span class="stringliteral">&quot; + &quot;</span>;</div><div class="line">    std::cerr &lt;&lt; <span class="stringliteral">&quot;... + &quot;</span>;</div><div class="line">    <span class="keywordflow">if</span> (Determinant.size() &gt;= 2) {</div><div class="line">        F.write(std::cerr, Determinant[Determinant.size()-2]) &lt;&lt; <span class="stringliteral">&quot;Y^&quot;</span> &lt;&lt; (deg-1) &lt;&lt; <span class="stringliteral">&quot; + &quot;</span>;</div><div class="line">    }</div><div class="line">    F.write(std::cerr, Determinant[Determinant.size()-1]) &lt;&lt; <span class="stringliteral">&quot;Y^&quot;</span> &lt;&lt; deg &lt;&lt; std::endl;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">typename</span> Field::Element t, p2; F.assign(p2, F.zero);</div><div class="line">    <span class="keywordflow">if</span> (Determinant.size() &gt;= 2) {</div><div class="line">        F.neg(p2, Determinant[ Determinant.size()-2]);</div><div class="line">        F.divin(p2, Determinant[ Determinant.size()-1]);</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> (M&gt;N) {</div><div class="line">        <span class="keyword">typedef</span> <a name="_a15"></a><a class="code" href="class_lin_box_1_1_transpose.html">LinBox::Transpose&lt;Blackbox&gt;</a> AT_BB;</div><div class="line">        <span class="keyword">typedef</span> <a name="_a16"></a><a class="code" href="class_lin_box_1_1_compose.html">LinBox::Compose&lt; LinBox::Diagonal&lt;Field&gt;</a>, AT_BB &gt; DAT_BB ;</div><div class="line">        <span class="keyword">typedef</span> <a class="code" href="class_lin_box_1_1_compose.html">LinBox::Compose&lt; DAT_BB, LinBox::Diagonal&lt;Field&gt;</a> &gt; DATD_BB;</div><div class="line">        <span class="keyword">typedef</span> <a class="code" href="class_lin_box_1_1_compose.html">LinBox::Compose&lt; DATD_BB, Blackbox&gt;</a> DATDA_BB;</div><div class="line">        <span class="keyword">typedef</span> <a class="code" href="class_lin_box_1_1_compose.html">LinBox::Compose&lt; DATDA_BB, LinBox::Diagonal&lt;Field&gt;</a> &gt; DATDAD_BB;</div><div class="line"></div><div class="line">        AT_BB       AT(&amp;B);</div><div class="line">        DAT_BB      B1(&amp;D2, &amp;AT);   <span class="comment">// B1 = D2 B^T</span></div><div class="line">        DATD_BB     B2(&amp;B1, &amp;D1);   <span class="comment">// B2 = B1 D1 = D2 B^T D1</span></div><div class="line">        DATDA_BB    B3(&amp;B2, &amp;B);    <span class="comment">// B3 = B2 B  = D2 B^T D1 B</span></div><div class="line">        DATDAD_BB   B4(&amp;B3, &amp;D2);   <span class="comment">// B4 = B3 D2 = D2 B^T D1 B D2</span></div><div class="line">        std::cerr &lt;&lt; <span class="stringliteral">&quot;B4: &quot;</span> &lt;&lt; B4.rowdim() &lt;&lt; <span class="stringliteral">&quot;x&quot;</span> &lt;&lt; B4.coldim() &lt;&lt; std::endl;</div><div class="line"></div><div class="line">        <span class="comment">//         trace(t, B4);</span></div><div class="line">        LinBox::WhisartTraceTranspose(t, F, D2, B, D1);</div><div class="line"></div><div class="line">        F.write(std::cerr &lt;&lt; <span class="stringliteral">&quot;Trace D2 B^T D1 B D2: &quot;</span>, t) &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    }</div><div class="line">    <span class="keywordflow">else</span> {</div><div class="line">        <span class="keyword">typedef</span> <a class="code" href="class_lin_box_1_1_compose.html">LinBox::Compose&lt; LinBox::Diagonal&lt;Field&gt;</a>, Blackbox &gt; DA_BB;</div><div class="line">        <span class="keyword">typedef</span> <a class="code" href="class_lin_box_1_1_compose.html">LinBox::Compose&lt; DA_BB, LinBox::Diagonal&lt;Field&gt;</a> &gt; DAD_BB;</div><div class="line">        <span class="keyword">typedef</span> <a class="code" href="class_lin_box_1_1_transpose.html">LinBox::Transpose&lt;Blackbox&gt;</a> AT_BB;</div><div class="line">        <span class="keyword">typedef</span> <a class="code" href="class_lin_box_1_1_compose.html">LinBox::Compose&lt; DAD_BB, AT_BB&gt;</a> DADAT_BB;</div><div class="line">        <span class="keyword">typedef</span> <a class="code" href="class_lin_box_1_1_compose.html">LinBox::Compose&lt; DADAT_BB, LinBox::Diagonal&lt;Field&gt;</a> &gt; DADATD_BB;</div><div class="line"></div><div class="line">        DA_BB       B1(&amp;D2, &amp;B);    <span class="comment">// B1 = D2 B</span></div><div class="line">        DAD_BB      B2(&amp;B1, &amp;D1);   <span class="comment">// B2 = B1 D1 = D2 B D1</span></div><div class="line">        AT_BB       AT(&amp;B);</div><div class="line">        DADAT_BB    B3(&amp;B2, &amp;AT);   <span class="comment">// B3 = B2 B^T= D2 B D1 B^T</span></div><div class="line">        DADATD_BB   B4(&amp;B3, &amp;D2);   <span class="comment">// B4 = B3 D2 = D2 B D1 B^T D2</span></div><div class="line">        std::cerr &lt;&lt; <span class="stringliteral">&quot;B4: &quot;</span> &lt;&lt; B4.rowdim() &lt;&lt; <span class="stringliteral">&quot;x&quot;</span> &lt;&lt; B4.coldim() &lt;&lt; std::endl;</div><div class="line"></div><div class="line">        <span class="comment">//         trace(t, B4);</span></div><div class="line">        LinBox::WhisartTrace(t, F, D2, B, D1);</div><div class="line"></div><div class="line">        F.write(std::cerr &lt;&lt; <span class="stringliteral">&quot;Trace D2 B D1 B^T D2: &quot;</span>, t) &lt;&lt; std::endl;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> (! F.areEqual( t, p2 )) {</div><div class="line">        std::cerr &lt;&lt; <span class="stringliteral">&quot;*** FAILURE (&quot;</span> &lt;&lt; (deg-val) &lt;&lt; <span class="stringliteral">&quot;) ***&quot;</span> &lt;&lt; std::endl;</div><div class="line">        F.write(std::cerr &lt;&lt; <span class="stringliteral">&quot;Trace: &quot;</span>, t) &lt;&lt; std::endl;</div><div class="line">        F.write(std::cerr &lt;&lt; <span class="stringliteral">&quot;Minpo: &quot;</span>, p2) &lt;&lt; std::endl;</div><div class="line">    }</div><div class="line">    <span class="keywordflow">else</span> {</div><div class="line">        <span class="comment">//         std::cerr &lt;&lt; &quot;Degree - valuation: &quot; &lt;&lt; (deg-val) &lt;&lt; std::endl;</span></div><div class="line">        std::cerr &lt;&lt; <span class="stringliteral">&quot;MONTE CARLO RANK: &quot;</span> &lt;&lt; (deg-val) &lt;&lt; std::endl;</div><div class="line">    }</div><div class="line">    std::cerr &lt;&lt; chrono4 &lt;&lt; std::endl;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    std::cerr &lt;&lt; <span class="stringliteral">&quot;Rank |\t Time-genvect\t Time-seq\t Time-SB\t Time-Interp |\t Total-Time&quot;</span> &lt;&lt; std::endl;</div><div class="line">    std::cout &lt;&lt; (deg-val) &lt;&lt; std::scientific &lt;&lt; std::setprecision(3)</div><div class="line">    &lt;&lt; <span class="stringliteral">&quot; |\t&quot;</span> &lt;&lt; chrono1.usertime()</div><div class="line">    &lt;&lt; <span class="charliteral">&#39;\t&#39;</span> &lt;&lt; chrono2.usertime()</div><div class="line">    &lt;&lt; <span class="charliteral">&#39;\t&#39;</span> &lt;&lt; chrono3.usertime()</div><div class="line">    &lt;&lt; <span class="charliteral">&#39;\t&#39;</span> &lt;&lt; chrono4.usertime()</div><div class="line">    &lt;&lt; <span class="stringliteral">&quot; |\t&quot;</span> &lt;&lt; (chrono1.usertime()+chrono2.usertime()+chrono3.usertime()+chrono4.usertime())</div><div class="line">    &lt;&lt; std::endl;</div><div class="line">    <span class="keywordflow">return</span> 0;</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main (<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> **argv)</div><div class="line">{</div><div class="line">        <span class="comment">// argv[1]: matrix file name</span></div><div class="line">        <span class="comment">// argv[2]: [optional] field characteristic (default 65521)</span></div><div class="line">        <span class="comment">// argv[3]: [optional] block size (default omp_max_threads)</span></div><div class="line">        <span class="comment">// argv[4]: [optional] random generator seed</span></div><div class="line"></div><div class="line">    <span class="keywordtype">int</span> c = (argc&gt;2 ? atoi(argv[2]) : 65521);</div><div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> extend = (<span class="keywordtype">unsigned</span> long)FF_EXPONENT_MAX(c,(<span class="keywordtype">int</span>)LINBOX_EXTENSION_DEGREE_MAX);</div><div class="line">    <span class="keywordflow">if</span> (extend &gt; 1) {</div><div class="line">        std::cerr &lt;&lt; <span class="stringliteral">&quot;*** WARNING *** would be best using an extension field of degree &quot;</span> &lt;&lt; extend &lt;&lt; std::endl;</div><div class="line">    }</div><div class="line"><span class="preprocessor">#if 0</span></div><div class="line">    <span class="keywordflow">if</span> (extend &gt; 1) {</div><div class="line">        <span class="keyword">typedef</span> Givaro::GFqDom&lt;int64_t&gt; Field;</div><div class="line">        Field EF( (<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>)c, extend);</div><div class="line">        EF.write(std::cerr &lt;&lt; <span class="stringliteral">&quot;Using an extension field &quot;</span>) &lt;&lt; std::endl;</div><div class="line">        <span class="keywordflow">return</span> OMP_BLOCK_RANK_main(EF,argc,argv);</div><div class="line">    }</div><div class="line"><span class="preprocessor">#endif</span></div><div class="line">    <span class="comment">// else {</span></div><div class="line">    <span class="keyword">typedef</span> Givaro::Modular&lt;double&gt; Field;</div><div class="line">    Field F(c);</div><div class="line">    <span class="keywordflow">return</span> OMP_BLOCK_RANK_main(F,argc,argv);</div><div class="line">    <span class="comment">//     }</span></div><div class="line"></div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// Local Variables:</span></div><div class="line"><span class="comment">// mode: C++</span></div><div class="line"><span class="comment">// tab-width: 4</span></div><div class="line"><span class="comment">// indent-tabs-mode: nil</span></div><div class="line"><span class="comment">// c-basic-offset: 4</span></div><div class="line"><span class="comment">// End:</span></div><div class="line"><span class="comment">// vim:sts=4:sw=4:ts=4:et:sr:cino=&gt;s,f0,{0,g0,(0,\:0,t0,+0,=s</span></div></div><!-- fragment --> </div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Wed Jun 5 2019 14:05:42 for linbox by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
