<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>linbox: solutions</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">linbox
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',false,false,'search.php','Search');
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#groups">Modules</a> &#124;
<a href="#files">Files</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">solutions</div>  </div>
</div><!--header-->
<div class="contents">

<p>These are problem oriented drivers providing simple interfaces to the linear algebra algorithms.  
<a href="#details">More...</a></p>
<div id="dynsection-0" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-0-trigger" src="closed.png" alt="+"/> Collaboration diagram for solutions:</div>
<div id="dynsection-0-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-0-content" class="dyncontent" style="display:none;">
<center><table><tr><td><img src="group__solutions.png" border="0" alt="" usemap="#group____solutions"/>
<map name="group____solutions" id="group____solutions">
<area shape="rect" id="node1" href="group__minpoly.html" title="NO DOC YET. " alt="" coords="157,5,304,32"/>
<area shape="rect" id="node2" href="group__systemsolving.html" title="NO DOC YET. " alt="" coords="169,56,292,83"/>
<area shape="rect" id="node3" href="group__determin.html" title="NO DOC YET. " alt="" coords="175,107,286,133"/>
<area shape="rect" id="node5" href="group__nullsp.html" title="NO DOC YET. " alt="" coords="187,157,274,184"/>
<area shape="rect" id="node6" href="group__reducedforms.html" title="NO DOC YET. " alt="" coords="169,208,292,235"/>
<area shape="rect" id="node7" href="group__charpoly.html" title="NO DOC YET. " alt="" coords="135,259,327,285"/>
<area shape="rect" id="node8" href="group__rk.html" title="NO DOC YET. " alt="" coords="203,309,258,336"/>
</map>
</td></tr></table></center>
</div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="groups"></a>
Modules</h2></td></tr>
<tr class="memitem:group__charpoly"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__charpoly.html">Characteristic polynomial</a></td></tr>
<tr class="memdesc:group__charpoly"><td class="mdescLeft">&#160;</td><td class="mdescRight">NO DOC YET. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group__determin"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__determin.html">Determinant</a></td></tr>
<tr class="memdesc:group__determin"><td class="mdescLeft">&#160;</td><td class="mdescRight">NO DOC YET. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group__minpoly"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__minpoly.html">Minimal polynomial</a></td></tr>
<tr class="memdesc:group__minpoly"><td class="mdescLeft">&#160;</td><td class="mdescRight">NO DOC YET. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group__nullsp"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nullsp.html">Nullspace</a></td></tr>
<tr class="memdesc:group__nullsp"><td class="mdescLeft">&#160;</td><td class="mdescRight">NO DOC YET. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group__rk"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rk.html">Rank</a></td></tr>
<tr class="memdesc:group__rk"><td class="mdescLeft">&#160;</td><td class="mdescRight">NO DOC YET. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group__reducedforms"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__reducedforms.html">Recuded forms</a></td></tr>
<tr class="memdesc:group__reducedforms"><td class="mdescLeft">&#160;</td><td class="mdescRight">NO DOC YET. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group__systemsolving"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__systemsolving.html">System solving</a></td></tr>
<tr class="memdesc:group__systemsolving"><td class="mdescLeft">&#160;</td><td class="mdescRight">NO DOC YET. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="files"></a>
Files</h2></td></tr>
<tr class="memitem:det_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="det_8h.html">det.h</a></td></tr>
<tr class="memdesc:det_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">NO DOC. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:solution-tags_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="solution-tags_8h.html">solution-tags.h</a></td></tr>
<tr class="memdesc:solution-tags_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">This allows files defining objects that have traits concerning several solutions to get the tags and traits with one inclusion. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gadd341dddd79681523103d316cdf03a95"><td class="memTemplParams" colspan="2">template&lt;class Blackbox , class MyMethod &gt; </td></tr>
<tr class="memitem:gadd341dddd79681523103d316cdf03a95"><td class="memTemplItemLeft" align="right" valign="top">Blackbox::Field::Element &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__solutions.html#gadd341dddd79681523103d316cdf03a95">lif_cra_det</a> (typename Blackbox::Field::Element &amp;d, const Blackbox &amp;A, const <a class="el" href="struct_lin_box_1_1_ring_categories_1_1_integer_tag.html">RingCategories::IntegerTag</a> &amp;tag, const MyMethod &amp;M)</td></tr>
<tr class="memdesc:gadd341dddd79681523103d316cdf03a95"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the determinant of A over the integers.  <a href="group__solutions.html#gadd341dddd79681523103d316cdf03a95">More...</a><br /></td></tr>
<tr class="separator:gadd341dddd79681523103d316cdf03a95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga017678ad2851590ad3335371136f1730"><td class="memTemplParams" colspan="2">template&lt;class Blackbox , class DetMethod , class DomainCategory &gt; </td></tr>
<tr class="memitem:ga017678ad2851590ad3335371136f1730"><td class="memTemplItemLeft" align="right" valign="top">Blackbox::Field::Element &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__solutions.html#ga017678ad2851590ad3335371136f1730">det</a> (typename Blackbox::Field::Element &amp;d, const Blackbox &amp;A, const DomainCategory &amp;tag, const DetMethod &amp;Meth)</td></tr>
<tr class="memdesc:ga017678ad2851590ad3335371136f1730"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the determinant of A.  <a href="group__solutions.html#ga017678ad2851590ad3335371136f1730">More...</a><br /></td></tr>
<tr class="separator:ga017678ad2851590ad3335371136f1730"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae9cc01adf89ca79caaf864d908316d5d"><td class="memTemplParams" colspan="2">template&lt;class Field &gt; </td></tr>
<tr class="memitem:gae9cc01adf89ca79caaf864d908316d5d"><td class="memTemplItemLeft" align="right" valign="top">Field::Element &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__solutions.html#gae9cc01adf89ca79caaf864d908316d5d">detInPlace</a> (typename Field::Element &amp;d, <a class="el" href="class_lin_box_1_1_blas_matrix.html">BlasMatrix</a>&lt; Field &gt; &amp;A)</td></tr>
<tr class="memdesc:gae9cc01adf89ca79caaf864d908316d5d"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="namespace_lin_box_1_1_rank.html" title="Rank of the system, if known. ">Rank</a> of Blackbox <code>A</code>.  <a href="group__solutions.html#gae9cc01adf89ca79caaf864d908316d5d">More...</a><br /></td></tr>
<tr class="separator:gae9cc01adf89ca79caaf864d908316d5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf81b9dc67cedf2044133b59399dd2334"><td class="memTemplParams" colspan="2">template&lt;class Blackbox , class Method , class DomainCategory &gt; </td></tr>
<tr class="memitem:gaf81b9dc67cedf2044133b59399dd2334"><td class="memTemplItemLeft" align="right" valign="top">size_t &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__solutions.html#gaf81b9dc67cedf2044133b59399dd2334">rank</a> (size_t &amp;r, const Blackbox &amp;A, const DomainCategory &amp;tag, const <a class="el" href="struct_lin_box_1_1_method.html">Method</a> &amp;M)</td></tr>
<tr class="memdesc:gaf81b9dc67cedf2044133b59399dd2334"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the rank of a linear transform A over a field by selected method.  <a href="group__solutions.html#gaf81b9dc67cedf2044133b59399dd2334">More...</a><br /></td></tr>
<tr class="separator:gaf81b9dc67cedf2044133b59399dd2334"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab21084c47a378b924fb1bdb4e9a7db1b"><td class="memTemplParams" colspan="2">template&lt;class Blackbox &gt; </td></tr>
<tr class="memitem:gab21084c47a378b924fb1bdb4e9a7db1b"><td class="memTemplItemLeft" align="right" valign="top">size_t &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__solutions.html#gab21084c47a378b924fb1bdb4e9a7db1b">rank</a> (size_t &amp;r, const Blackbox &amp;A)</td></tr>
<tr class="memdesc:gab21084c47a378b924fb1bdb4e9a7db1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the rank of a linear transform A over a field.  <a href="group__solutions.html#gab21084c47a378b924fb1bdb4e9a7db1b">More...</a><br /></td></tr>
<tr class="separator:gab21084c47a378b924fb1bdb4e9a7db1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab0a01a9fc169d04294eab924e2655026"><td class="memTemplParams" colspan="2">template&lt;class Blackbox , class Method &gt; </td></tr>
<tr class="memitem:gab0a01a9fc169d04294eab924e2655026"><td class="memTemplItemLeft" align="right" valign="top">size_t &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__solutions.html#gab0a01a9fc169d04294eab924e2655026">rank</a> (size_t &amp;r, const Blackbox &amp;A, const <a class="el" href="struct_lin_box_1_1_method.html">Method</a> &amp;M)</td></tr>
<tr class="memdesc:gab0a01a9fc169d04294eab924e2655026"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the rank of a linear transform A over a field.  <a href="group__solutions.html#gab0a01a9fc169d04294eab924e2655026">More...</a><br /></td></tr>
<tr class="separator:gab0a01a9fc169d04294eab924e2655026"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8b19d94e7ebf1e2fbe716f9e344acf2d"><td class="memTemplParams" colspan="2">template&lt;class Blackbox , class Method &gt; </td></tr>
<tr class="memitem:ga8b19d94e7ebf1e2fbe716f9e344acf2d"><td class="memTemplItemLeft" align="right" valign="top">SmithList&lt; typename Blackbox::Field &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__solutions.html#ga8b19d94e7ebf1e2fbe716f9e344acf2d">smithForm</a> (SmithList&lt; typename Blackbox::Field &gt; &amp;S, const Blackbox &amp;A, const <a class="el" href="struct_lin_box_1_1_method.html">Method</a> &amp;M)</td></tr>
<tr class="memdesc:ga8b19d94e7ebf1e2fbe716f9e344acf2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the Smith form of A.  <a href="group__solutions.html#ga8b19d94e7ebf1e2fbe716f9e344acf2d">More...</a><br /></td></tr>
<tr class="separator:ga8b19d94e7ebf1e2fbe716f9e344acf2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2e2b7150bd78ae61406d8768554abd14"><td class="memTemplParams" colspan="2">template&lt;class Blackbox , class MyMethod &gt; </td></tr>
<tr class="memitem:ga2e2b7150bd78ae61406d8768554abd14"><td class="memTemplItemLeft" align="right" valign="top">Blackbox::Field::Element &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__solutions.html#ga2e2b7150bd78ae61406d8768554abd14">valence</a> (typename Blackbox::Field::Element &amp;v, const Blackbox &amp;A, const MyMethod &amp;M)</td></tr>
<tr class="memdesc:ga2e2b7150bd78ae61406d8768554abd14"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the valence of A.  <a href="group__solutions.html#ga2e2b7150bd78ae61406d8768554abd14">More...</a><br /></td></tr>
<tr class="separator:ga2e2b7150bd78ae61406d8768554abd14"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>These are problem oriented drivers providing simple interfaces to the linear algebra algorithms. </p>
<p>The arguments to each are discussed in detail in the documentation of each function. The optional method parameter is discussed in general terms just below the list. </p><ul>
<li>
<code>rank(r, A[, method])</code> r gets rank of A </li>
<li>
<code>determinant(d, A[, method])</code> d gets determinant of A </li>
<li>
<code>solve(x, A, b[, method[, status]])</code> get x such that Ax = b, random solution if sigular and consistent, x = 0 if inconsistent (also inconsistency is indicated in the status). The method parameter may include specifications that can make the computation faster. These include symmetry, nonsingularity, and that an arbitrary solution is acceptable rather than a random sample. </li>
<li>
<code>minpoly(m, A[, method, status])</code> m gets minimal polynomial of A </li>
<li>
<code>charpoly(c, A[, method, status])</code> c gets characteristic polynomial of A </li>
<li>
<p class="startli"><code>smithForm(S, A[, method])</code> S gets Smith Normal Form of A. Smith form is unitarily equivalent to A and is diag(s<sub>1</sub> .. s<sub>n</sub>) such that s<sub>i</sub> | s<sub>i+1</sub>. </p><dl class="todo"><dt><b><a class="el" href="todo.html#_todo000077">Todo:</a></b></dt><dd>its multipliers? its output form variants? </dd></dl>
<p class="endli"></p>
</li>
<li>
<p class="startli"><code>frobeniusForm(F, A, method, status)</code> F gets Frobenius (Rational) normal form of A. Frobenius form is similar to A and is a direct sum of companion matrices C<sub>f<sub>i</sub></sub> such that, f<sub>i</sub> divides f<sub>i+1</sub>.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000078">Todo:</a></b></dt><dd>primary form? Relative primary form of A? Primary form is similar to A and finest which is a direct sum of companion matrices C<sub>f<sub>i</sub></sub> such that, for all i, j, gcd(f<sub>i</sub>, f<sub>j</sub>) = 1 or f<sub>i</sub> or f<sub>j</sub>. Relative primary form is coarsest such decomposition.</dd></dl>
<p class="endli"></p>
</li>
<li>
<code>signature(s, A, method)</code> </li>
<li>
<code>bool isPositiveDefinite(A, method_symm)</code> </li>
<li>
<code>bool isPositiveSemidefinite(A, method_symm)</code> </li>
</ul>
<p>The algorithms are actively under development, and there is an algorithm choice to be made for each function. The choice is determined by an optional argument to the function which is a method object. The class of the method object determines the approach used and data in the object may help determine algorithm variants at run time. This makes it easy to try out and compare several approaches for a given matrix.</p>
<p>The first method classes to consider are the <a class="el" href="">Blackbox</a>, <a class="el" href="">Elimination</a>, and <a class="el" href="">Hybrid</a> classes. <code>Blackbox</code> and <code>Elimination</code> methods may be used for virtually every solution function.</p>
<ul>
<li>The <a class="el" href="">Elimination</a> class provides access to algorithms based on dense or sparse elimination and the algorithms take advantage of the numeric BLAS routines when the underlying field or ring is the integers or a prime field of appropriate cardinality.</li>
<li>The <a class="el" href="">Blackbox</a> class provides functions which are space efficient and are particularly effective for very large and very sparse systems. They are also fast and useful for structured systems such as Toeplitz, Hankel, Vandermonde, etc. Currently in LinBox the superfast methods for structured matrices are not implemented.</li>
<li>The <a class="el" href="">Hybrid</a> class chooses <code>Blackbox</code>, <code>Elimination</code>, or a mix of them based on matrix properties checked at runtime. It is the default method. Thus for each problem (e.g. rank) the function call without a method, <code>rank(r, A)</code>, is equivalent to a call using the default Hybrid object, <code>rank(r, A, Method::Hybrid())</code>.</li>
</ul>
<p>Hybrid algorithms are under development and not in final form. The method used under the Hybrid designation may be a sophisticated hybrid algorithm, a very basic one, or simply our guess of the most widely useful of the available algorithms. The basic hybrid method is to use the elimination approach if the matrix is small or in a dense representation, and a blackbox method otherwise. A dense representation is one which inherits from <code>DenseMatrix</code> or <code>BlasMatrix</code>. Small means both row and column dimensions are less than 10<sup>3</sup>. The threshold values can be changed in the hybrid method object. For instance </p><div class="fragment"><div class="line">Hybrid h;</div><div class="line">h.setSmallThreshold(5000);</div><div class="line"><a class="code" href="group__solutions.html#gaf81b9dc67cedf2044133b59399dd2334">rank</a>(r, A, h) ;</div></div><!-- fragment --><p>Additional method classes exist to focus in greater detail on the method. For instance, in the <code>Blackbox</code> situation there are the <a class="el" href="">Wiedemann</a>, <a class="el" href="">BlockWiedemann</a>, <a class="el" href="">Lanczos</a>, and <a class="el" href="">BlockLanczos</a> approaches, to name a few. Actually, for each solution function, the <code>Blackbox</code> class simply chooses from among these the best one as currently implemented. They may be used specifically to override that default. Thus <code>rank(r, A,Blackbox())</code> uses the Wiedemann method. But <code>rank(r, A, BlockLanczos())</code> could be called as well.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000079">Todo:</a></b></dt><dd>this may soon be reversed, in fact.</dd></dl>
<p>Also choice of preconditioner may be possible either at runtime by putting an indicator in the method object or at compile time by using a more special class of method such as <a class="el" href="">BlockWiedemannButterfly</a>.</p>
<p>Other method classes focus on algorithms attuned to specific matrix properties. For instance, there may be <a class="el" href="">HybridSymmetric</a>, <a class="el" href="">EliminationSymmetric</a>, and <a class="el" href="">BlackboxSymmetric</a>. Using these method choices, several functions are about twice as fast as those where the symmetry is unspecified. To get the same effect as a runtime choice, objects of the basic method classes may contain an indicator of symmetry, </p><div class="fragment"><div class="line">Method::Elimination e;</div><div class="line">e.setSymmetric();</div><div class="line"><a class="code" href="group__solutions.html#gaf81b9dc67cedf2044133b59399dd2334">rank</a>(r, A, e);</div></div><!-- fragment --><p>Not every implemented algorithm is available through solution functions and their methods, but this is a good starting point. See <a class="el" href="group__algorithms.html">algorithms</a> for the other possibilities and <code><a class="el" href="struct_lin_box_1_1_method.html" title="Define which method to use when working on a system. ">LinBox::Method</a></code> for available methods.</p>
<p>If the status parameter is given, it is used for output of side information. For instance the solve function will set it's <code>isConsistent()</code> property indicating whether or not the system was found to be consistent. Also an upper bound on the probability of error is given by <code>errorBound()</code>. In the future, it may even provide consistency certificates and cofactors for normal forms. </p>
<h2 class="groupheader">Function Documentation</h2>
<a id="gadd341dddd79681523103d316cdf03a95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadd341dddd79681523103d316cdf03a95">&#9670;&nbsp;</a></span>lif_cra_det()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Blackbox::Field::Element&amp; LinBox::lif_cra_det </td>
          <td>(</td>
          <td class="paramtype">typename Blackbox::Field::Element &amp;&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Blackbox &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_lin_box_1_1_ring_categories_1_1_integer_tag.html">RingCategories::IntegerTag</a> &amp;&#160;</td>
          <td class="paramname"><em>tag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MyMethod &amp;&#160;</td>
          <td class="paramname"><em>M</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the determinant of A over the integers. </p>
<p>The determinant of a linear operator A, represented as a black box, is computed over the integers.</p>
<p>This variant is a hybrid between Last Invariant Factor and Chinese Remaindering It performs several determinants mod primes Then switches to the LIF method, producing a factor of det. It then comes back to the CRA if necessary to compute the remaining (usually small) factor of the determinant.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">d</td><td>Field element into which to store the result </td></tr>
    <tr><td class="paramname">A</td><td>Black box of which to compute the determinant </td></tr>
    <tr><td class="paramname">tag</td><td>explicit over the integers </td></tr>
    <tr><td class="paramname">M</td><td>may be a Method::DenseElimination (default) or a Method::Wiedemann. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga017678ad2851590ad3335371136f1730"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga017678ad2851590ad3335371136f1730">&#9670;&nbsp;</a></span>det()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Blackbox::Field::Element&amp; LinBox::det </td>
          <td>(</td>
          <td class="paramtype">typename Blackbox::Field::Element &amp;&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Blackbox &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DomainCategory &amp;&#160;</td>
          <td class="paramname"><em>tag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DetMethod &amp;&#160;</td>
          <td class="paramname"><em>Meth</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the determinant of A. </p>
<p>The determinant of a linear operator A, represented as a black box, is computed over the ring or field of A.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">d</td><td>Field element into which to store the result </td></tr>
    <tr><td class="paramname">A</td><td>Black box of which to compute the determinant </td></tr>
    <tr><td class="paramname">tag</td><td>optional tag. Specifies Integer, Rational or modular ring/field </td></tr>
    <tr><td class="paramname">M</td><td>optional method. The default is <a class="el" href="namespace_lin_box.html#a10235377a5d8fe76c611f71b195cb97ea06b9281e396db002010bde1de57262eb" title="Let implementation decide what to use. ">Method::Auto()</a>, Other options include Blackbox, Elimination, Wiedemann, DenseElimination and SparseElimination. Sometimes it helps to indicate properties of the matrix in the method object (for instance symmetry). See class <a class="el" href="struct_lin_box_1_1_method.html" title="Define which method to use when working on a system. ">Method</a> for details. </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="examples_2det_8_c-example.html#a7">examples/det.C</a>, <a class="el" href="examples_2doubledet_8_c-example.html#a6">examples/doubledet.C</a>, and <a class="el" href="examples_2sparseelimdet_8_c-example.html#a3">examples/sparseelimdet.C</a>.</dd>
</dl>
</div>
</div>
<a id="gae9cc01adf89ca79caaf864d908316d5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae9cc01adf89ca79caaf864d908316d5d">&#9670;&nbsp;</a></span>detInPlace()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Field::Element&amp; LinBox::detInPlace </td>
          <td>(</td>
          <td class="paramtype">typename Field::Element &amp;&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_lin_box_1_1_blas_matrix.html">BlasMatrix</a>&lt; Field &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="namespace_lin_box_1_1_rank.html" title="Rank of the system, if known. ">Rank</a> of Blackbox <code>A</code>. </p>
<p>A will be modified. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">d</td><td>determinant of <code>A</code>. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">A</td><td>this <a class="el" href="class_lin_box_1_1_blas_matrix.html" title="Dense matrix representation. ">BlasMatrix</a> matrix will be modified in place in the process. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>d</code> </dd></dl>

</div>
</div>
<a id="gaf81b9dc67cedf2044133b59399dd2334"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf81b9dc67cedf2044133b59399dd2334">&#9670;&nbsp;</a></span>rank() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t&amp; LinBox::rank </td>
          <td>(</td>
          <td class="paramtype">size_t &amp;&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Blackbox &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DomainCategory &amp;&#160;</td>
          <td class="paramname"><em>tag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_lin_box_1_1_method.html">Method</a> &amp;&#160;</td>
          <td class="paramname"><em>M</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the rank of a linear transform A over a field by selected method. </p>
<p>For very large and/or very sparse matrices the Wiedemann method will be faster (and it is memory efficient). For some sparse matrices SparseElimination may outperform Wiedemann. For small or dense matrices DenseElimination will be faster. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">r</td><td>output rank of A. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">A</td><td>linear transform, member of any blackbox class. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">M</td><td>may be a <code><a class="el" href="namespace_lin_box.html#a10235377a5d8fe76c611f71b195cb97ea06b9281e396db002010bde1de57262eb" title="Let implementation decide what to use. ">Method::Auto</a></code> (the default), a <code>Method::Wiedemann</code>, a <code>Method::DenseElimination</code>, or a <code>Method::SparseElimination</code>.. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">tag</td><td>UNDOC </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to r. </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="examples_2grid_reduce_8_c-example.html#a0">examples/grid_reduce.C</a>, <a class="el" href="examples_2omp_block_rank_8_c-example.html#a14">examples/omp_block_rank.C</a>, <a class="el" href="examples_2rank_8_c-example.html#a4">examples/rank.C</a>, and <a class="el" href="examples_2sparseelimrank_8_c-example.html#a6">examples/sparseelimrank.C</a>.</dd>
</dl>
</div>
</div>
<a id="gab21084c47a378b924fb1bdb4e9a7db1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab21084c47a378b924fb1bdb4e9a7db1b">&#9670;&nbsp;</a></span>rank() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t&amp; LinBox::rank </td>
          <td>(</td>
          <td class="paramtype">size_t &amp;&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Blackbox &amp;&#160;</td>
          <td class="paramname"><em>A</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the rank of a linear transform A over a field. </p>
<p>The default method is Wiedemann(), using diagonal preconditioning and the minpoly. For small or dense matrices DenseElimination will be faster. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">A</td><td>linear transform, member of any blackbox class. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">r</td><td>rank of <code>A</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>r</code> rank of <code>A</code>. </dd></dl>

</div>
</div>
<a id="gab0a01a9fc169d04294eab924e2655026"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab0a01a9fc169d04294eab924e2655026">&#9670;&nbsp;</a></span>rank() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t&amp; LinBox::rank </td>
          <td>(</td>
          <td class="paramtype">size_t &amp;&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Blackbox &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_lin_box_1_1_method.html">Method</a> &amp;&#160;</td>
          <td class="paramname"><em>M</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the rank of a linear transform A over a field. </p>
<p>The default method is <code>Wiedemann()</code>, using diagonal preconditioning and the minpoly. For small or dense matrices <code>DenseElimination</code> will be faster. </p><dl class="section return"><dt>Returns</dt><dd><code>r</code> rank of <code>A</code>. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">A</td><td>linear transform, member of any blackbox class. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">r</td><td>rank of <code>A</code> </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">M</td><td>method (see ???) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga8b19d94e7ebf1e2fbe716f9e344acf2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8b19d94e7ebf1e2fbe716f9e344acf2d">&#9670;&nbsp;</a></span>smithForm()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SmithList&lt;typename Blackbox::Field&gt;&amp; LinBox::smithForm </td>
          <td>(</td>
          <td class="paramtype">SmithList&lt; typename Blackbox::Field &gt; &amp;&#160;</td>
          <td class="paramname"><em>S</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Blackbox &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_lin_box_1_1_method.html">Method</a> &amp;&#160;</td>
          <td class="paramname"><em>M</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the Smith form of A. </p>
<p>The Smith form of a linear operator A, represented as a black box, is computed over a representation of <img class="formulaInl" alt="$Z$" src="form_63.png"/> or <img class="formulaInl" alt="$Z_m$" src="form_64.png"/>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">S</td><td>a list of invariant/repcount pairs. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">A</td><td>Matrix of which to compute the Smith form </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">M</td><td>may be a <code><a class="el" href="namespace_lin_box.html#a10235377a5d8fe76c611f71b195cb97ea06b9281e396db002010bde1de57262eb" title="Let implementation decide what to use. ">Method::Auto</a></code> (default), which uses the algorithms/smith-form-adaptive. </td></tr>
  </table>
  </dd>
</dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000076">Todo:</a></b></dt><dd>Other methods will be provided later. For now see the <a class="el" href="smith_8_c.html">examples/smith.C</a> for ways to call other smith form algorithms. </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="examples_2smith_8_c-example.html#a4">examples/smith.C</a>.</dd>
</dl>
</div>
</div>
<a id="ga2e2b7150bd78ae61406d8768554abd14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2e2b7150bd78ae61406d8768554abd14">&#9670;&nbsp;</a></span>valence()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Blackbox::Field::Element&amp; LinBox::valence </td>
          <td>(</td>
          <td class="paramtype">typename Blackbox::Field::Element &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Blackbox &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MyMethod &amp;&#160;</td>
          <td class="paramname"><em>M</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the valence of A. </p>
<p>The valence of a linear operator A, represented as a black box, is computed over the ring or field of A.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>Field element into which to store the result </td></tr>
    <tr><td class="paramname">A</td><td>Black box of which to compute the determinant </td></tr>
    <tr><td class="paramname">M</td><td>may is a <a class="el" href="struct_lin_box_1_1_method.html" title="Define which method to use when working on a system. ">Method</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="examples_2smithsparse_8_c-example.html#a4">examples/smithsparse.C</a>.</dd>
</dl>
</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Wed Jun 5 2019 14:05:43 for linbox by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
