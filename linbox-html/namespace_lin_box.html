<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>linbox: LinBox Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">linbox
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',false,false,'search.php','Search');
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">LinBox Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Namespace in which all linbox code resides.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespace_lin_box_1_1_exceptions"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_lin_box_1_1_exceptions.html">Exceptions</a></td></tr>
<tr class="memdesc:namespace_lin_box_1_1_exceptions"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_lin_box_1_1_exception.html" title="This is the exception class in LinBox. ">Exception</a> class for invalid matrix input. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespace_lin_box_1_1_indexed_tags"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_lin_box_1_1_indexed_tags.html">IndexedTags</a></td></tr>
<tr class="memdesc:namespace_lin_box_1_1_indexed_tags"><td class="mdescLeft">&#160;</td><td class="mdescRight">limited doc so far <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespace_lin_box_1_1_iterator_categories"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_lin_box_1_1_iterator_categories.html">IteratorCategories</a></td></tr>
<tr class="memdesc:namespace_lin_box_1_1_iterator_categories"><td class="mdescLeft">&#160;</td><td class="mdescRight">Information about the type of Prime Iterator. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespace_lin_box_1_1_matrix_hom"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_lin_box_1_1_matrix_hom.html">MatrixHom</a></td></tr>
<tr class="memdesc:namespace_lin_box_1_1_matrix_hom"><td class="mdescLeft">&#160;</td><td class="mdescRight">Limited doc so far. Used in <a class="el" href="class_lin_box_1_1_rational_solver.html" title="Interface for the different specialization of p-adic lifting based solvers. ">RationalSolver</a>. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespace_lin_box_1_1_protected"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_lin_box_1_1_protected.html">Protected</a></td></tr>
<tr class="memdesc:namespace_lin_box_1_1_protected"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the namespace all <a class="el" href="namespace_lin_box.html" title="Namespace in which all linbox code resides. ">LinBox</a> internal code is in. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespace_lin_box_1_1_rank"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_lin_box_1_1_rank.html">Rank</a></td></tr>
<tr class="memdesc:namespace_lin_box_1_1_rank"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="namespace_lin_box_1_1_rank.html" title="Rank of the system, if known. ">Rank</a> of the system, if known. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespace_lin_box_1_1_ring_categories"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_lin_box_1_1_ring_categories.html">RingCategories</a></td></tr>
<tr class="memdesc:namespace_lin_box_1_1_ring_categories"><td class="mdescLeft">&#160;</td><td class="mdescRight">some basic information about each field or ring. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespace_lin_box_1_1_shape"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_lin_box_1_1_shape.html">Shape</a></td></tr>
<tr class="memdesc:namespace_lin_box_1_1_shape"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flags decribing the shape of the matrix. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespace_lin_box_1_1_sparse_file_format"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_lin_box_1_1_sparse_file_format.html">SparseFileFormat</a></td></tr>
<tr class="memdesc:namespace_lin_box_1_1_sparse_file_format"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sparse matrix format (file storage) <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespace_lin_box_1_1_sparse_matrix_format"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_lin_box_1_1_sparse_matrix_format.html">SparseMatrixFormat</a></td></tr>
<tr class="memdesc:namespace_lin_box_1_1_sparse_matrix_format"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sparse matrix format (memory storage) <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespace_lin_box_1_1_tag"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_lin_box_1_1_tag.html">Tag</a></td></tr>
<tr class="memdesc:namespace_lin_box_1_1_tag"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure for tags. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespace_lin_box_1_1_vector_wrapper"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_lin_box_1_1_vector_wrapper.html">VectorWrapper</a></td></tr>
<tr class="memdesc:namespace_lin_box_1_1_vector_wrapper"><td class="mdescLeft">&#160;</td><td class="mdescRight">limited doc so far. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lin_box_1_1algo_exception.html">algoException</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Algorithmic exception.  <a href="class_lin_box_1_1algo_exception.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lin_box_1_1_algorithm_meta_data.html">AlgorithmMetaData</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Algorithm metadata;.  <a href="class_lin_box_1_1_algorithm_meta_data.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lin_box_1_1_bad_input_exception.html">BadInputException</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The input is not as expected.  <a href="class_lin_box_1_1_bad_input_exception.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lin_box_1_1_benchmark_meta_data.html">BenchmarkMetaData</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Benchmark metadata;.  <a href="class_lin_box_1_1_benchmark_meta_data.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lin_box_1_1_bit_vector.html">BitVector</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Binary constant defined both for 32 and 64 bits.  <a href="class_lin_box_1_1_bit_vector.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lin_box_1_1_blackbox_archetype.html">BlackboxArchetype</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">showing the member functions provided by all blackbox matrix classes.  <a href="class_lin_box_1_1_blackbox_archetype.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lin_box_1_1_blackbox_block_container_base.html">BlackboxBlockContainerBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A base class for BlackboxBlockContainer.  <a href="class_lin_box_1_1_blackbox_block_container_base.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lin_box_1_1_blackbox_block_container_record.html">BlackboxBlockContainerRecord</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">no doc.  <a href="class_lin_box_1_1_blackbox_block_container_record.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lin_box_1_1_blackbox_container.html">BlackboxContainer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Limited doc so far.  <a href="class_lin_box_1_1_blackbox_container.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lin_box_1_1_blackbox_container_base.html">BlackboxContainerBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A base class for <a class="el" href="class_lin_box_1_1_blackbox_container.html" title="Limited doc so far. ">BlackboxContainer</a>.  <a href="class_lin_box_1_1_blackbox_container_base.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lin_box_1_1_blackbox_container_symmetric.html">BlackboxContainerSymmetric</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">See base class for doc.  <a href="class_lin_box_1_1_blackbox_container_symmetric.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lin_box_1_1_blackbox_container_symmetrize.html">BlackboxContainerSymmetrize</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Symmetrizing iterator (for rank computations).  <a href="class_lin_box_1_1_blackbox_container_symmetrize.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lin_box_1_1_blackbox_factory.html">BlackboxFactory</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A tool for computations with integer and rational matrices.  <a href="class_lin_box_1_1_blackbox_factory.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lin_box_1_1_blas_matrix.html">BlasMatrix</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dense matrix representation.  <a href="class_lin_box_1_1_blas_matrix.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lin_box_1_1_blas_matrix_3_01_multi_mod_double_01_4.html">BlasMatrix&lt; MultiModDouble &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">No Doc.  <a href="class_lin_box_1_1_blas_matrix_3_01_multi_mod_double_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lin_box_1_1_blas_matrix_domain.html">BlasMatrixDomain</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interface for all functionnalities provided for <a class="el" href="class_lin_box_1_1_blas_matrix.html" title="Dense matrix representation. ">BlasMatrix</a>.  <a href="class_lin_box_1_1_blas_matrix_domain.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lin_box_1_1_blas_matrix_domain_addin.html">BlasMatrixDomainAddin</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">C += A.  <a href="class_lin_box_1_1_blas_matrix_domain_addin.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lin_box_1_1_blas_matrix_domain_mul_add_3_01_blas_vector_3_01_field_01_4_00_01_blas_matrix_efb2dde2390c4f49bf9f771cb03af952.html">BlasMatrixDomainMulAdd&lt; BlasVector&lt; Field &gt;, BlasMatrix&lt; Field, _Rep &gt;, BlasVector&lt; Field &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">what about subvector/submatrices ?  <a href="class_lin_box_1_1_blas_matrix_domain_mul_add_3_01_blas_vector_3_01_field_01_4_00_01_blas_matrix_efb2dde2390c4f49bf9f771cb03af952.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lin_box_1_1_blas_matrix_domain_subin.html">BlasMatrixDomainSubin</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">C -= A.  <a href="class_lin_box_1_1_blas_matrix_domain_subin.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lin_box_1_1_blas_permutation.html">BlasPermutation</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lapack-style permutation.  <a href="class_lin_box_1_1_blas_permutation.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lin_box_1_1_blas_submatrix.html">BlasSubmatrix</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dense <a class="el" href="class_lin_box_1_1_submatrix.html" title="leading principal minor of existing matrix without copying. ">Submatrix</a> representation.  <a href="class_lin_box_1_1_blas_submatrix.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lin_box_1_1_block_b_b.html">BlockBB</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">converts a black box into a block black box  <a href="class_lin_box_1_1_block_b_b.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lin_box_1_1_block_compose.html">BlockCompose</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Blackbox of a product: <img class="formulaInl" alt="$C = AB$" src="form_22.png"/>, i.e <img class="formulaInl" alt="$Cx \gets A(Bx)$" src="form_23.png"/>.  <a href="class_lin_box_1_1_block_compose.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lin_box_1_1_block_coppersmith_domain.html">BlockCoppersmithDomain</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the linear generator of a sequence of matrices.  <a href="class_lin_box_1_1_block_coppersmith_domain.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lin_box_1_1_block_hankel_lifting_container.html">BlockHankelLiftingContainer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Block Hankel LiftingContianer.  <a href="class_lin_box_1_1_block_hankel_lifting_container.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lin_box_1_1_block_lanczos_solver.html">BlockLanczosSolver</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Block Lanczos iteration.  <a href="class_lin_box_1_1_block_lanczos_solver.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lin_box_1_1_block_massey_domain.html">BlockMasseyDomain</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the linear generator of a sequence of matrices.  <a href="class_lin_box_1_1_block_massey_domain.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lin_box_1_1_block_wiedemann_lifting_container.html">BlockWiedemannLiftingContainer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Block Wiedemann LiftingContianer.  <a href="class_lin_box_1_1_block_wiedemann_lifting_container.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lin_box_1_1_boolean_switch.html">BooleanSwitch</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Boolean switch object.  <a href="class_lin_box_1_1_boolean_switch.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lin_box_1_1_butterfly.html">Butterfly</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Switching Network based BlackBox Matrix.  <a href="class_lin_box_1_1_butterfly.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lin_box_1_1_cekstv_switch.html">CekstvSwitch</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The default butterfly switch object.  <a href="class_lin_box_1_1_cekstv_switch.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_lin_box_1_1_chinese_remainder.html">ChineseRemainder</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">No doc.  <a href="struct_lin_box_1_1_chinese_remainder.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_lin_box_1_1_chinese_remainder_sequential.html">ChineseRemainderSequential</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">No doc.  <a href="struct_lin_box_1_1_chinese_remainder_sequential.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_lin_box_1_1_classify_ring.html">ClassifyRing</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default ring category.  <a href="struct_lin_box_1_1_classify_ring.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lin_box_1_1_commentator.html">Commentator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Give information to user during runtime.  <a href="class_lin_box_1_1_commentator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_lin_box_1_1_companion.html">Companion</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Companion matrix of a monic polynomial.  <a href="struct_lin_box_1_1_companion.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lin_box_1_1_compose.html">Compose</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Blackbox of a product: <img class="formulaInl" alt="$C = AB$" src="form_22.png"/>, i.e <img class="formulaInl" alt="$Cx \gets A(Bx)$" src="form_23.png"/>.  <a href="class_lin_box_1_1_compose.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lin_box_1_1_compose_3_01___blackbox_00_01___blackbox_01_4.html">Compose&lt; _Blackbox, _Blackbox &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">specialization for _Blackbox1 = _Blackbox2  <a href="class_lin_box_1_1_compose_3_01___blackbox_00_01___blackbox_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lin_box_1_1_compose_owner.html">ComposeOwner</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Blackbox of a product: <img class="formulaInl" alt="$C = AB$" src="form_22.png"/>, i.e <img class="formulaInl" alt="$Cx \gets A(Bx)$" src="form_23.png"/>.  <a href="class_lin_box_1_1_compose_owner.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lin_box_1_1_compose_traits.html">ComposeTraits</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">used in ..., for example  <a href="class_lin_box_1_1_compose_traits.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lin_box_1_1_compose_traits_3_01_blas_matrix_3_01_field_00_01_rep_01_4_01_4.html">ComposeTraits&lt; BlasMatrix&lt; Field, Rep &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">used in smith-binary, for example  <a href="class_lin_box_1_1_compose_traits_3_01_blas_matrix_3_01_field_00_01_rep_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lin_box_1_1_constant_vector_stream.html">ConstantVectorStream</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constant vector factory.  <a href="class_lin_box_1_1_constant_vector_stream.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_lin_box_1_1_container_categories.html">ContainerCategories</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">used to separate BLAS2 and BLAS3 operations  <a href="struct_lin_box_1_1_container_categories.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_lin_box_1_1_container_traits.html">ContainerTraits</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trait for the Category.  <a href="struct_lin_box_1_1_container_traits.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_lin_box_1_1_container_traits_3_01std_1_1vector_3_01___rep_01_4_01_4.html">ContainerTraits&lt; std::vector&lt; _Rep &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_lin_box_1_1_c_r_a_builder_early_multip.html">CRABuilderEarlyMultip</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">NO DOC.  <a href="struct_lin_box_1_1_c_r_a_builder_early_multip.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_lin_box_1_1_c_r_a_builder_early_single.html">CRABuilderEarlySingle</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Heuristic Chinese Remaindering with early termination.  <a href="struct_lin_box_1_1_c_r_a_builder_early_single.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_lin_box_1_1_c_r_a_builder_full_multip.html">CRABuilderFullMultip</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Chinese remaindering of a vector of elements without early termination.  <a href="struct_lin_box_1_1_c_r_a_builder_full_multip.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_lin_box_1_1_c_r_a_builder_full_multip_fixed.html">CRABuilderFullMultipFixed</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Chinese Remaindering Algorithm for multiple residues.  <a href="struct_lin_box_1_1_c_r_a_builder_full_multip_fixed.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_lin_box_1_1_c_r_a_builder_full_multip_matrix.html">CRABuilderFullMultipMatrix</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">NO DOC.  <a href="struct_lin_box_1_1_c_r_a_builder_full_multip_matrix.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_lin_box_1_1_c_r_a_builder_full_single.html">CRABuilderFullSingle</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Chinese Remaindering with full precision and no chance of failure.  <a href="struct_lin_box_1_1_c_r_a_builder_full_single.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_lin_box_1_1_c_r_a_builder_prob_single.html">CRABuilderProbSingle</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Chinese Remaindering with guaranteed probability bound and early termination.  <a href="struct_lin_box_1_1_c_r_a_builder_prob_single.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_lin_box_1_1_c_r_a_builder_single_base.html">CRABuilderSingleBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abstract base class for CRA builders.  <a href="struct_lin_box_1_1_c_r_a_builder_single_base.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_lin_box_1_1_c_r_a_residue.html">CRAResidue</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type information for the residue in a CRA iteration.  <a href="struct_lin_box_1_1_c_r_a_residue.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_lin_box_1_1_c_r_a_residue_3_01_integer_00_01_function_01_4.html">CRAResidue&lt; Integer, Function &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type information for the residue in a CRA iteration.  <a href="struct_lin_box_1_1_c_r_a_residue_3_01_integer_00_01_function_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_lin_box_1_1_c_r_a_residue_3_01std_1_1vector_3_01_integer_01_4_00_01_function_01_4.html">CRAResidue&lt; std::vector&lt; Integer &gt;, Function &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type information for the residue in a CRA iteration.  <a href="struct_lin_box_1_1_c_r_a_residue_3_01std_1_1vector_3_01_integer_01_4_00_01_function_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lin_box_1_1_c_s_f.html">CSF</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Space efficient representation of sparse matrices.  <a href="class_lin_box_1_1_c_s_f.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_lin_box_1_1_data_series.html">DataSeries</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">this structure holds a bunch of timings.  <a href="struct_lin_box_1_1_data_series.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lin_box_1_1_dense_container.html">DenseContainer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Limited doc so far.  <a href="class_lin_box_1_1_dense_container.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lin_box_1_1_dense_mat.html">DenseMat</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">to be used in standard matrix domain  <a href="class_lin_box_1_1_dense_mat.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lin_box_1_1_dense_polynomial.html">DensePolynomial</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dense Polynomial representation using Givaro.  <a href="class_lin_box_1_1_dense_polynomial.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lin_box_1_1_diagonal.html">Diagonal</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Random diagonal matrices are used heavily as preconditioners.  <a href="class_lin_box_1_1_diagonal.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lin_box_1_1_diagonal_3_01___field_00_01_vector_categories_1_1_dense_vector_tag_01_4.html">Diagonal&lt; _Field, VectorCategories::DenseVectorTag &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization of <a class="el" href="class_lin_box_1_1_diagonal.html" title="Random diagonal matrices are used heavily as preconditioners. ">Diagonal</a> for application to dense vectors.  <a href="class_lin_box_1_1_diagonal_3_01___field_00_01_vector_categories_1_1_dense_vector_tag_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lin_box_1_1_diagonal_3_01___field_00_01_vector_categories_1_1_sparse_associative_vector_tag_01_4.html">Diagonal&lt; _Field, VectorCategories::SparseAssociativeVectorTag &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization of <a class="el" href="class_lin_box_1_1_diagonal.html" title="Random diagonal matrices are used heavily as preconditioners. ">Diagonal</a> for application to sparse associative vectors.  <a href="class_lin_box_1_1_diagonal_3_01___field_00_01_vector_categories_1_1_sparse_associative_vector_tag_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lin_box_1_1_diagonal_3_01___field_00_01_vector_categories_1_1_sparse_sequence_vector_tag_01_4.html">Diagonal&lt; _Field, VectorCategories::SparseSequenceVectorTag &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization of <a class="el" href="class_lin_box_1_1_diagonal.html" title="Random diagonal matrices are used heavily as preconditioners. ">Diagonal</a> for application to sparse sequence vectors.  <a href="class_lin_box_1_1_diagonal_3_01___field_00_01_vector_categories_1_1_sparse_sequence_vector_tag_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lin_box_1_1_dif.html">Dif</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Blackbox of a difference: <code>C := A - B</code>, i.e <code>Cx = Ax - Bx</code>.  <a href="class_lin_box_1_1_dif.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lin_box_1_1_diophantine_solver.html">DiophantineSolver</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">DiophantineSolver&lt;QSolver&gt; creates a diophantine solver using a QSolver to generate rational solutions.  <a href="class_lin_box_1_1_diophantine_solver.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lin_box_1_1_direct_sum.html">DirectSum</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">If C = DirectSum(A, B) and y = xA and z = wB, then (y,z) = (x,w)C.  <a href="class_lin_box_1_1_direct_sum.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lin_box_1_1_dixon_lifting_container.html">DixonLiftingContainer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dixon Lifting Container.  <a href="class_lin_box_1_1_dixon_lifting_container.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lin_box_1_1_dot_product_domain_3_01_givaro_1_1_modular_3_01uint16__t_00_01_compute__t_01_4_01_4.html">DotProductDomain&lt; Givaro::Modular&lt; uint16_t, Compute_t &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization of DotProductDomain for unsigned short modular field.  <a href="class_lin_box_1_1_dot_product_domain_3_01_givaro_1_1_modular_3_01uint16__t_00_01_compute__t_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lin_box_1_1_dot_product_domain_3_01_givaro_1_1_modular_3_01uint32__t_00_01_compute__t_01_4_01_4.html">DotProductDomain&lt; Givaro::Modular&lt; uint32_t, Compute_t &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization of DotProductDomain for uint32_t modular field.  <a href="class_lin_box_1_1_dot_product_domain_3_01_givaro_1_1_modular_3_01uint32__t_00_01_compute__t_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lin_box_1_1_dot_product_domain_3_01_givaro_1_1_modular_3_01uint64__t_00_01_compute__t_01_4_01_4.html">DotProductDomain&lt; Givaro::Modular&lt; uint64_t, Compute_t &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization of DotProductDomain for uint64_t modular field.  <a href="class_lin_box_1_1_dot_product_domain_3_01_givaro_1_1_modular_3_01uint64__t_00_01_compute__t_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lin_box_1_1_dot_product_domain_3_01_givaro_1_1_modular_3_01uint8__t_00_01_compute__t_01_4_01_4.html">DotProductDomain&lt; Givaro::Modular&lt; uint8_t, Compute_t &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization of DotProductDomain for unsigned short modular field.  <a href="class_lin_box_1_1_dot_product_domain_3_01_givaro_1_1_modular_3_01uint8__t_00_01_compute__t_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lin_box_1_1_dot_product_domain_3_01_givaro_1_1_modular_balanced_3_01double_01_4_01_4.html">DotProductDomain&lt; Givaro::ModularBalanced&lt; double &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization of DotProductDomain.  <a href="class_lin_box_1_1_dot_product_domain_3_01_givaro_1_1_modular_balanced_3_01double_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lin_box_1_1_element_abstract.html">ElementAbstract</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abstract element base class, a technicality.  <a href="class_lin_box_1_1_element_abstract.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lin_box_1_1_element_archetype.html">ElementArchetype</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Field and Ring element interface specification and archetypical instance class.  <a href="class_lin_box_1_1_element_archetype.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lin_box_1_1_element_envelope.html">ElementEnvelope</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adaptor from archetypical interface to abstract interface, a technicality.  <a href="class_lin_box_1_1_element_envelope.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lin_box_1_1_eliminator.html">Eliminator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Elimination system.  <a href="class_lin_box_1_1_eliminator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lin_box_1_1_environment_meta_data.html">EnvironmentMetaData</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Environment metadata;.  <a href="class_lin_box_1_1_environment_meta_data.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lin_box_1_1_exception.html">Exception</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the exception class in <a class="el" href="namespace_lin_box.html" title="Namespace in which all linbox code resides. ">LinBox</a>.  <a href="class_lin_box_1_1_exception.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lin_box_1_1_field_abstract.html">FieldAbstract</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">field base class.  <a href="class_lin_box_1_1_field_abstract.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lin_box_1_1_field_archetype.html">FieldArchetype</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">field specification and archetypical instance.  <a href="class_lin_box_1_1_field_archetype.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lin_box_1_1_field_a_x_p_y.html">FieldAXPY</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_lin_box_1_1_field_a_x_p_y.html" title="FieldAXPY object. ">FieldAXPY</a> object.  <a href="class_lin_box_1_1_field_a_x_p_y.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lin_box_1_1_field_a_x_p_y_3_01_givaro_1_1_modular_3_01uint16__t_00_01_compute__t_01_4_01_4.html">FieldAXPY&lt; Givaro::Modular&lt; uint16_t, Compute_t &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization of <a class="el" href="class_lin_box_1_1_field_a_x_p_y.html" title="FieldAXPY object. ">FieldAXPY</a> for uint16_t modular field.  <a href="class_lin_box_1_1_field_a_x_p_y_3_01_givaro_1_1_modular_3_01uint16__t_00_01_compute__t_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lin_box_1_1_field_a_x_p_y_3_01_givaro_1_1_modular_3_01uint32__t_00_01_compute__t_01_4_01_4.html">FieldAXPY&lt; Givaro::Modular&lt; uint32_t, Compute_t &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization of <a class="el" href="class_lin_box_1_1_field_a_x_p_y.html" title="FieldAXPY object. ">FieldAXPY</a> for unsigned short modular field.  <a href="class_lin_box_1_1_field_a_x_p_y_3_01_givaro_1_1_modular_3_01uint32__t_00_01_compute__t_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lin_box_1_1_field_a_x_p_y_3_01_givaro_1_1_modular_3_01uint64__t_00_01_compute__t_01_4_01_4.html">FieldAXPY&lt; Givaro::Modular&lt; uint64_t, Compute_t &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization of <a class="el" href="class_lin_box_1_1_field_a_x_p_y.html" title="FieldAXPY object. ">FieldAXPY</a> for unsigned short modular field.  <a href="class_lin_box_1_1_field_a_x_p_y_3_01_givaro_1_1_modular_3_01uint64__t_00_01_compute__t_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lin_box_1_1_field_a_x_p_y_3_01_givaro_1_1_modular_3_01uint8__t_00_01_compute__t_01_4_01_4.html">FieldAXPY&lt; Givaro::Modular&lt; uint8_t, Compute_t &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization of <a class="el" href="class_lin_box_1_1_field_a_x_p_y.html" title="FieldAXPY object. ">FieldAXPY</a> for uint8_t modular field.  <a href="class_lin_box_1_1_field_a_x_p_y_3_01_givaro_1_1_modular_3_01uint8__t_00_01_compute__t_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lin_box_1_1_field_a_x_p_y_3_01_givaro_1_1_modular_balanced_3_01double_01_4_01_4.html">FieldAXPY&lt; Givaro::ModularBalanced&lt; double &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization of <a class="el" href="class_lin_box_1_1_field_a_x_p_y.html" title="FieldAXPY object. ">FieldAXPY</a>.  <a href="class_lin_box_1_1_field_a_x_p_y_3_01_givaro_1_1_modular_balanced_3_01double_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lin_box_1_1_field_documentation.html">FieldDocumentation</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This field base class exists solely to aid documentation organization.  <a href="class_lin_box_1_1_field_documentation.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lin_box_1_1_field_envelope.html">FieldEnvelope</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Derived class used to implement the field archetypeHelps to minimize code bloat.  <a href="class_lin_box_1_1_field_envelope.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lin_box_1_1_field_meta_data.html">FieldMetaData</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Field metadata.  <a href="class_lin_box_1_1_field_meta_data.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_lin_box_1_1_field_traits.html">FieldTraits</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">FieldTrait.  <a href="struct_lin_box_1_1_field_traits.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lin_box_1_1_gauss_domain.html">GaussDomain</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Repository of functions for rank by elimination on sparse matrices.  <a href="class_lin_box_1_1_gauss_domain.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lin_box_1_1_generator_meta_data.html">GeneratorMetaData</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generator metadata;.  <a href="class_lin_box_1_1_generator_meta_data.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lin_box_1_1_generic_rand_iter.html">GenericRandIter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Random field base element generator.  <a href="class_lin_box_1_1_generic_rand_iter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_lin_box_1_1_get_entry_category.html">GetEntryCategory</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="struct_lin_box_1_1_get_entry_category.html" title="GetEntryCategory is specialized for BB classes that offer a local getEntry. ">GetEntryCategory</a> is specialized for BB classes that offer a local getEntry.  <a href="struct_lin_box_1_1_get_entry_category.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_lin_box_1_1_givaro_rns_fixed_c_r_a.html">GivaroRnsFixedCRA</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">NO DOC...  <a href="struct_lin_box_1_1_givaro_rns_fixed_c_r_a.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lin_box_1_1_gmp_random_prime.html">GmpRandomPrime</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">generating random prime integers, using the gmp library.  <a href="class_lin_box_1_1_gmp_random_prime.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lin_box_1_1_g_m_p_rational_element.html">GMPRationalElement</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">elements of GMP_Rationals.  <a href="class_lin_box_1_1_g_m_p_rational_element.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lin_box_1_1_hilbert.html">Hilbert</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Example of a blackbox that is space efficient, though not time efficient.  <a href="class_lin_box_1_1_hilbert.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lin_box_1_1_hilbert___j_i_t___entry.html">Hilbert_JIT_Entry</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The object needed to build a <a class="el" href="class_lin_box_1_1_hilbert.html" title="Example of a blackbox that is space efficient, though not time efficient. ">Hilbert</a> matrix as a JIT matrix.  <a href="class_lin_box_1_1_hilbert___j_i_t___entry.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lin_box_1_1_hom.html">Hom</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">map element of source ring(field) to target ringAn instance of <a class="el" href="class_lin_box_1_1_hom.html" title="map element of source ring(field) to target ringAn instance of Hom is a homomorphism from a ring of t...">Hom</a> is a homomorphism from a ring of type Source to a ring (usually field) of type Target.  <a href="class_lin_box_1_1_hom.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lin_box_1_1_inconsistent_system.html">InconsistentSystem</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_lin_box_1_1_exception.html" title="This is the exception class in LinBox. ">Exception</a> thrown when the system to be solved is inconsistent.  <a href="class_lin_box_1_1_inconsistent_system.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lin_box_1_1index_domain.html">indexDomain</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class used for permuting indices.  <a href="class_lin_box_1_1index_domain.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_lin_box_1_1_indexed_category.html">IndexedCategory</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trait to show whether or not the BB class has a Indexed iterator.  <a href="struct_lin_box_1_1_indexed_category.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_lin_box_1_1_indexed_category_3_01_blas_matrix_3_01_field_00_01___rep_01_4_01_4.html">IndexedCategory&lt; BlasMatrix&lt; Field, _Rep &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lin_box_1_1_inverse.html">Inverse</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A Blackbox for the inverse.  <a href="class_lin_box_1_1_inverse.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lin_box_1_1_invert_textbook_domain.html">InvertTextbookDomain</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assumes that Field is a field, not a ring.  <a href="class_lin_box_1_1_invert_textbook_domain.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lin_box_1_1_irrecuperable_exception.html">IrrecuperableException</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Something bad an unexpected happened.  <a href="class_lin_box_1_1_irrecuperable_exception.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lin_box_1_1_j_i_t___matrix.html">JIT_Matrix</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">example of a blackbox that is space efficient, though not time efficient.  <a href="class_lin_box_1_1_j_i_t___matrix.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lin_box_1_1_l_a_block_lanczos_solver.html">LABlockLanczosSolver</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Biorthogonalising block Lanczos iteration.  <a href="class_lin_box_1_1_l_a_block_lanczos_solver.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lin_box_1_1_lanczos_solver.html">LanczosSolver</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solve a linear system using the conjugate Lanczos iteration.  <a href="class_lin_box_1_1_lanczos_solver.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lin_box_1_1_large_double.html">LargeDouble</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">NO DOC.  <a href="class_lin_box_1_1_large_double.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lin_box_1_1_last_invariant_factor.html">LastInvariantFactor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is used in a Smith Form algorithm.  <a href="class_lin_box_1_1_last_invariant_factor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lin_box_1_1lattice_method.html">latticeMethod</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">NTL methods.  <a href="class_lin_box_1_1lattice_method.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lin_box_1_1_linbox_error.html">LinboxError</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">base class for execption handling in <a class="el" href="namespace_lin_box.html" title="Namespace in which all linbox code resides. ">LinBox</a>  <a href="class_lin_box_1_1_linbox_error.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_lin_box_1_1_local2__32.html">Local2_32</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fast arithmetic mod 2^32, including gcd.  <a href="struct_lin_box_1_1_local2__32.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lin_box_1_1_masked_prime_iterator.html">MaskedPrimeIterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Masked Prime Iterator.  <a href="class_lin_box_1_1_masked_prime_iterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lin_box_1_1_massey_domain.html">MasseyDomain</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Berlekamp/Massey algorithm.  <a href="class_lin_box_1_1_massey_domain.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lin_box_1_1_matrix_archetype.html">MatrixArchetype</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Directly-represented matrix archetype.  <a href="class_lin_box_1_1_matrix_archetype.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lin_box_1_1_matrix_blackbox.html">MatrixBlackbox</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matrix black box.  <a href="class_lin_box_1_1_matrix_blackbox.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_lin_box_1_1_matrix_categories.html">MatrixCategories</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">For specializing matrix arithmetic.  <a href="struct_lin_box_1_1_matrix_categories.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lin_box_1_1_matrix_container_trait.html">MatrixContainerTrait</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">NODOC.  <a href="class_lin_box_1_1_matrix_container_trait.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lin_box_1_1_matrix_domain.html">MatrixDomain</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class of matrix arithmetic functions.  <a href="class_lin_box_1_1_matrix_domain.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lin_box_1_1_matrix_domain_3_01_g_f2_01_4.html">MatrixDomain&lt; GF2 &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization of <a class="el" href="class_lin_box_1_1_matrix_domain.html" title="Class of matrix arithmetic functions. ">MatrixDomain</a> for GF2.  <a href="class_lin_box_1_1_matrix_domain_3_01_g_f2_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_lin_box_1_1_matrix_hom_trait.html">MatrixHomTrait</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">try to map a blackbox over a homorphic ring The most suitable type  <a href="struct_lin_box_1_1_matrix_hom_trait.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lin_box_1_1_matrix_meta_data.html">MatrixMetaData</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matrix metadata.  <a href="class_lin_box_1_1_matrix_meta_data.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lin_box_1_1_matrix_permutation.html">MatrixPermutation</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Permutation classique.  <a href="class_lin_box_1_1_matrix_permutation.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lin_box_1_1_matrix_rank.html">MatrixRank</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the rank of an integer matrix in place over a finite field by Gaussian elimination.  <a href="class_lin_box_1_1_matrix_rank.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lin_box_1_1_matrix_stream.html">MatrixStream</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_lin_box_1_1_matrix_stream.html" title="MatrixStream. ">MatrixStream</a>.  <a href="class_lin_box_1_1_matrix_stream.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lin_box_1_1_matrix_stream_reader.html">MatrixStreamReader</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An abstract base class to represent readers for specific formats.  <a href="class_lin_box_1_1_matrix_stream_reader.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_lin_box_1_1_matrix_traits.html">MatrixTraits</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">NO DOC.  <a href="struct_lin_box_1_1_matrix_traits.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lin_box_1_1_meta_data.html">MetaData</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the general metadata class.  <a href="class_lin_box_1_1_meta_data.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_lin_box_1_1_method.html">Method</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Define which method to use when working on a system.  <a href="struct_lin_box_1_1_method.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_lin_box_1_1_method_base.html">MethodBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Holds everything a method needs to know about the problem.  <a href="struct_lin_box_1_1_method_base.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lin_box_1_1_m_g_block_lanczos_solver.html">MGBlockLanczosSolver</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Block Lanczos iteration.  <a href="class_lin_box_1_1_m_g_block_lanczos_solver.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lin_box_1_1_modular_crooked_rand_iter.html">ModularCrookedRandIter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Random field base element generator.  <a href="class_lin_box_1_1_modular_crooked_rand_iter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lin_box_1_1_moore_penrose.html">MoorePenrose</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generalized inverse of a blackbox.  <a href="class_lin_box_1_1_moore_penrose.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lin_box_1_1_m_v_product_domain.html">MVProductDomain</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper class to allow specializations of certain matrix-vector products.  <a href="class_lin_box_1_1_m_v_product_domain.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lin_box_1_1_m_v_product_domain_3_01_givaro_1_1_modular_3_01uint16__t_00_01_compute__t_01_4_01_4.html">MVProductDomain&lt; Givaro::Modular&lt; uint16_t, Compute_t &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization of <a class="el" href="class_lin_box_1_1_m_v_product_domain.html" title="Helper class to allow specializations of certain matrix-vector products. ">MVProductDomain</a> for uint16_t modular field.  <a href="class_lin_box_1_1_m_v_product_domain_3_01_givaro_1_1_modular_3_01uint16__t_00_01_compute__t_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lin_box_1_1_m_v_product_domain_3_01_givaro_1_1_modular_3_01uint32__t_00_01_compute__t_01_4_01_4.html">MVProductDomain&lt; Givaro::Modular&lt; uint32_t, Compute_t &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization of <a class="el" href="class_lin_box_1_1_m_v_product_domain.html" title="Helper class to allow specializations of certain matrix-vector products. ">MVProductDomain</a> for uint32_t modular field.  <a href="class_lin_box_1_1_m_v_product_domain_3_01_givaro_1_1_modular_3_01uint32__t_00_01_compute__t_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lin_box_1_1_m_v_product_domain_3_01_givaro_1_1_modular_3_01uint64__t_00_01_compute__t_01_4_01_4.html">MVProductDomain&lt; Givaro::Modular&lt; uint64_t, Compute_t &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization of <a class="el" href="class_lin_box_1_1_m_v_product_domain.html" title="Helper class to allow specializations of certain matrix-vector products. ">MVProductDomain</a> for uint64_t modular field.  <a href="class_lin_box_1_1_m_v_product_domain_3_01_givaro_1_1_modular_3_01uint64__t_00_01_compute__t_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lin_box_1_1_m_v_product_domain_3_01_givaro_1_1_modular_3_01uint8__t_00_01_compute__t_01_4_01_4.html">MVProductDomain&lt; Givaro::Modular&lt; uint8_t, Compute_t &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization of <a class="el" href="class_lin_box_1_1_m_v_product_domain.html" title="Helper class to allow specializations of certain matrix-vector products. ">MVProductDomain</a> for uint8_t modular field.  <a href="class_lin_box_1_1_m_v_product_domain_3_01_givaro_1_1_modular_3_01uint8__t_00_01_compute__t_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lin_box_1_1_no_hom_error.html">NoHomError</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Error object for attempt to establish a <a class="el" href="class_lin_box_1_1_hom.html" title="map element of source ring(field) to target ringAn instance of Hom is a homomorphism from a ring of t...">Hom</a> that cannot exist.  <a href="class_lin_box_1_1_no_hom_error.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lin_box_1_1_not_implemented_yet_exception.html">NotImplementedYetException</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Not implemented yet.  <a href="class_lin_box_1_1_not_implemented_yet_exception.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_lin_box_1_1_n_t_l___p_i_d__zz__p.html">NTL_PID_zz_p</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">extend Wrapper of zz_p from NTL.  <a href="struct_lin_box_1_1_n_t_l___p_i_d__zz__p.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lin_box_1_1_n_t_l___z_z.html">NTL_ZZ</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">the integer ring.  <a href="class_lin_box_1_1_n_t_l___z_z.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_lin_box_1_1_n_t_l___z_z__p.html">NTL_ZZ_p</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper of zz_p from NTL.  <a href="struct_lin_box_1_1_n_t_l___z_z__p.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_lin_box_1_1_n_t_l__zz__p.html">NTL_zz_p</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">long ints modulo a positive integer.  <a href="struct_lin_box_1_1_n_t_l__zz__p.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lin_box_1_1_n_t_l___z_z__p_e.html">NTL_ZZ_pE</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper of ZZ_pE from NTL Define a parameterized class to handle easily Givaro::ZRing&lt;NTL::ZZ_pE&gt; field.  <a href="class_lin_box_1_1_n_t_l___z_z__p_e.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lin_box_1_1_n_t_l__zz__p_e.html">NTL_zz_pE</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">zz_pE Define a parameterized class to easily handle Givaro::ZRing&lt;NTL::zz_pE&gt; field  <a href="class_lin_box_1_1_n_t_l__zz__p_e.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lin_box_1_1_n_t_l__zz__p_e___initialiser.html">NTL_zz_pE_Initialiser</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">use ZZ_pEBak mechanism too ?  <a href="class_lin_box_1_1_n_t_l__zz__p_e___initialiser.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lin_box_1_1_n_t_l__zz__p_e_x.html">NTL_zz_pEX</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ring (in fact, a unique factorization domain) of polynomial with coefficients in class <a class="el" href="struct_lin_box_1_1_n_t_l__zz__p.html" title="long ints modulo a positive integer. ">NTL_zz_p</a> (integers mod a wordsize prime).  <a href="class_lin_box_1_1_n_t_l__zz__p_e_x.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lin_box_1_1_n_t_l__zz__p_x.html">NTL_zz_pX</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ring (in fact, a unique factorization domain) of polynomial with coefficients in class <a class="el" href="struct_lin_box_1_1_n_t_l__zz__p.html" title="long ints modulo a positive integer. ">NTL_zz_p</a> (integers mod a wordsize prime).  <a href="class_lin_box_1_1_n_t_l__zz__p_x.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lin_box_1_1_n_t_l___z_z__p_x.html">NTL_ZZ_pX</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ring (in fact, a unique factorization domain) of polynomial with coefficients in class <a class="el" href="struct_lin_box_1_1_n_t_l___z_z__p.html" title="Wrapper of zz_p from NTL. ">NTL_ZZ_p</a> (integers mod a wordsize prime).  <a href="class_lin_box_1_1_n_t_l___z_z__p_x.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lin_box_1_1_null_matrix.html">NullMatrix</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a representation of the 0 by 0 empty matrix which does not occupy memory.  <a href="class_lin_box_1_1_null_matrix.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lin_box_1_1_one_invariant_factor.html">OneInvariantFactor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Limited doc so far.  <a href="class_lin_box_1_1_one_invariant_factor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lin_box_1_1_open_c_l_environ.html">OpenCLEnviron</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Container for all pertenant information needed to use an OpenCL device, compile kernels for the device, track resource usage, and gain exclusive access to the device.  <a href="class_lin_box_1_1_open_c_l_environ.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lin_box_1_1_open_c_l_matrix_domain.html">OpenCLMatrixDomain</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interface for all functionnalities provided for <a class="el" href="class_lin_box_1_1_blas_matrix.html" title="Dense matrix representation. ">BlasMatrix</a> using GPUs.  <a href="class_lin_box_1_1_open_c_l_matrix_domain.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lin_box_1_1_param_fuzzy.html">ParamFuzzy</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abstract parameterized field of "fuzzy" doubles.  <a href="class_lin_box_1_1_param_fuzzy.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lin_box_1_1_p_i_r__ntl___z_z__p.html">PIR_ntl_ZZ_p</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">extend Wrapper of ZZ_p from NTL.  <a href="class_lin_box_1_1_p_i_r__ntl___z_z__p.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lin_box_1_1_plain_submatrix.html">PlainSubmatrix</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">to be used in reference matrix domain (PlainDomain).  <a href="class_lin_box_1_1_plain_submatrix.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lin_box_1_1_plot_data.html">PlotData</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The raw data to plot.  <a href="class_lin_box_1_1_plot_data.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lin_box_1_1_plot_graph.html">PlotGraph</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The graph (2D).  <a href="class_lin_box_1_1_plot_graph.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lin_box_1_1_plot_style.html">PlotStyle</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a table of values to plot (2D).  <a href="class_lin_box_1_1_plot_style.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lin_box_1_1_p_l_u_q_matrix.html">PLUQMatrix</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">PLUQ factorisation.  <a href="class_lin_box_1_1_p_l_u_q_matrix.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lin_box_1_1_polynomial_b_b.html">PolynomialBB</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">represent the matrix P(A) where A is a blackbox and P a polynomial  <a href="class_lin_box_1_1_polynomial_b_b.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lin_box_1_1_polynomial_b_b_owner.html">PolynomialBBOwner</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">represent the matrix P(A) where A is a blackbox and P a polynomial  <a href="class_lin_box_1_1_polynomial_b_b_owner.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lin_box_1_1_polynomial_ring.html">PolynomialRing</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Polynomials.  <a href="class_lin_box_1_1_polynomial_ring.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lin_box_1_1_power_gauss_domain.html">PowerGaussDomain</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Repository of functions for rank modulo a prime power by elimination on sparse matrices.  <a href="class_lin_box_1_1_power_gauss_domain.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lin_box_1_1_power_gauss_domain_power_of_two.html">PowerGaussDomainPowerOfTwo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Repository of functions for rank modulo a prime power by elimination on sparse matrices.  <a href="class_lin_box_1_1_power_gauss_domain_power_of_two.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lin_box_1_1_precondition_failed.html">PreconditionFailed</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A precondition failed.  <a href="class_lin_box_1_1_precondition_failed.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lin_box_1_1_prime_iterator.html">PrimeIterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prime Iterator.  <a href="class_lin_box_1_1_prime_iterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lin_box_1_1_prime_sequence.html">PrimeSequence</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adaptor class to make a fixed-length sequence behave like a <a class="el" href="class_lin_box_1_1_prime_iterator.html" title="Prime Iterator. ">PrimeIterator</a>.  <a href="class_lin_box_1_1_prime_sequence.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lin_box_1_1_prime_stream.html">PrimeStream</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prime number stream.  <a href="class_lin_box_1_1_prime_stream.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lin_box_1_1_rand_iter_abstract.html">RandIterAbstract</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Random field element generator.  <a href="class_lin_box_1_1_rand_iter_abstract.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lin_box_1_1_rand_iter_archetype.html">RandIterArchetype</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Random field element generator archetype.  <a href="class_lin_box_1_1_rand_iter_archetype.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lin_box_1_1_rand_iter_envelope.html">RandIterEnvelope</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Random field base element generator.  <a href="class_lin_box_1_1_rand_iter_envelope.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lin_box_1_1_random_dense_matrix.html">RandomDenseMatrix</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Random Dense Matrix builder.  <a href="class_lin_box_1_1_random_dense_matrix.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lin_box_1_1_random_dense_stream.html">RandomDenseStream</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Random dense vector stream.  <a href="class_lin_box_1_1_random_dense_stream.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lin_box_1_1_random_dense_stream_3_01_field_00_01___vector_00_01_rand_iter_00_01_vector_cat589381417933a6db12f95d32a4c5da0e.html">RandomDenseStream&lt; Field, _Vector, RandIter, VectorCategories::DenseVectorTag &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization of random dense stream for dense vectors.  <a href="class_lin_box_1_1_random_dense_stream_3_01_field_00_01___vector_00_01_rand_iter_00_01_vector_cat589381417933a6db12f95d32a4c5da0e.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lin_box_1_1_random_sparse_stream.html">RandomSparseStream</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Random sparse vector stream.  <a href="class_lin_box_1_1_random_sparse_stream.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lin_box_1_1_random_sparse_stream_3_01_field_00_01___vector_00_01_rand_iter_00_01_vector_ca883e5ca445c8a45322c951afc9074c1d.html">RandomSparseStream&lt; Field, _Vector, RandIter, VectorCategories::DenseVectorTag &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization of <a class="el" href="class_lin_box_1_1_random_sparse_stream.html" title="Random sparse vector stream. ">RandomSparseStream</a> for dense vectors.  <a href="class_lin_box_1_1_random_sparse_stream_3_01_field_00_01___vector_00_01_rand_iter_00_01_vector_ca883e5ca445c8a45322c951afc9074c1d.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lin_box_1_1_random_sparse_stream_3_01_field_00_01___vector_00_01_rand_iter_00_01_vector_ca076d5b0790f7cce9e4742b9ee96c71e3.html">RandomSparseStream&lt; Field, _Vector, RandIter, VectorCategories::SparseAssociativeVectorTag &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization of <a class="el" href="class_lin_box_1_1_random_sparse_stream.html" title="Random sparse vector stream. ">RandomSparseStream</a> for sparse associative vectors.  <a href="class_lin_box_1_1_random_sparse_stream_3_01_field_00_01___vector_00_01_rand_iter_00_01_vector_ca076d5b0790f7cce9e4742b9ee96c71e3.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lin_box_1_1_random_sparse_stream_3_01_field_00_01___vector_00_01_rand_iter_00_01_vector_ca276d66c5e49e11847c8660dd91684cda.html">RandomSparseStream&lt; Field, _Vector, RandIter, VectorCategories::SparseParallelVectorTag &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization of <a class="el" href="class_lin_box_1_1_random_sparse_stream.html" title="Random sparse vector stream. ">RandomSparseStream</a> for sparse parallel vectors.  <a href="class_lin_box_1_1_random_sparse_stream_3_01_field_00_01___vector_00_01_rand_iter_00_01_vector_ca276d66c5e49e11847c8660dd91684cda.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lin_box_1_1_random_sparse_stream_3_01_field_00_01___vector_00_01_rand_iter_00_01_vector_ca61dfcd16fddd3b2ca4b1974ad2d160c4.html">RandomSparseStream&lt; Field, _Vector, RandIter, VectorCategories::SparseSequenceVectorTag &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization of <a class="el" href="class_lin_box_1_1_random_sparse_stream.html" title="Random sparse vector stream. ">RandomSparseStream</a> for sparse sequence vectors.  <a href="class_lin_box_1_1_random_sparse_stream_3_01_field_00_01___vector_00_01_rand_iter_00_01_vector_ca61dfcd16fddd3b2ca4b1974ad2d160c4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_lin_box_1_1_rank_builder.html">RankBuilder</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">random method for constructing rank  <a href="struct_lin_box_1_1_rank_builder.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_lin_box_1_1_rational_chinese_remainder.html">RationalChineseRemainder</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Chinese remainder of rationals.  <a href="struct_lin_box_1_1_rational_chinese_remainder.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_lin_box_1_1_rational_chinese_remainder_var_prec.html">RationalChineseRemainderVarPrec</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Chinese remainder of vector of rationals.  <a href="struct_lin_box_1_1_rational_chinese_remainder_var_prec.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lin_box_1_1_rational_reconstruction.html">RationalReconstruction</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Limited doc so far.  <a href="class_lin_box_1_1_rational_reconstruction.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lin_box_1_1_rational_solver.html">RationalSolver</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interface for the different specialization of p-adic lifting based solvers.  <a href="class_lin_box_1_1_rational_solver.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lin_box_1_1_rational_solver_3_01_ring_00_01_field_00_01_random_prime_00_01_method_1_1_block_hankel_01_4.html">RationalSolver&lt; Ring, Field, RandomPrime, Method::BlockHankel &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Block Hankel.  <a href="class_lin_box_1_1_rational_solver_3_01_ring_00_01_field_00_01_random_prime_00_01_method_1_1_block_hankel_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lin_box_1_1_rational_solver_3_01_ring_00_01_field_00_01_random_prime_00_01_method_1_1_block_wiedemann_01_4.html">RationalSolver&lt; Ring, Field, RandomPrime, Method::BlockWiedemann &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">partial specialization of p-adic based solver with block Wiedemann algorithm.  <a href="class_lin_box_1_1_rational_solver_3_01_ring_00_01_field_00_01_random_prime_00_01_method_1_1_block_wiedemann_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lin_box_1_1_rational_solver_3_01_ring_00_01_field_00_01_random_prime_00_01_method_1_1_dixon_01_4.html">RationalSolver&lt; Ring, Field, RandomPrime, Method::Dixon &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">partial specialization of p-adic based solver with Dixon algorithm.  <a href="class_lin_box_1_1_rational_solver_3_01_ring_00_01_field_00_01_random_prime_00_01_method_1_1_dixon_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lin_box_1_1_rational_solver_3_01_ring_00_01_field_00_01_random_prime_00_01_method_1_1_sparse_elimination_01_4.html">RationalSolver&lt; Ring, Field, RandomPrime, Method::SparseElimination &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sparse LU.  <a href="class_lin_box_1_1_rational_solver_3_01_ring_00_01_field_00_01_random_prime_00_01_method_1_1_sparse_elimination_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lin_box_1_1_rational_solver_3_01_ring_00_01_field_00_01_random_prime_00_01_method_1_1_symbolic_numeric_norm_01_4.html">RationalSolver&lt; Ring, Field, RandomPrime, Method::SymbolicNumericNorm &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">solver using a hybrid Numeric/Symbolic computation.  <a href="class_lin_box_1_1_rational_solver_3_01_ring_00_01_field_00_01_random_prime_00_01_method_1_1_symbolic_numeric_norm_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lin_box_1_1_rational_solver_3_01_ring_00_01_field_00_01_random_prime_00_01_method_1_1_wiedemann_01_4.html">RationalSolver&lt; Ring, Field, RandomPrime, Method::Wiedemann &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial specialization of p-adic based solver with Wiedemann algorithm.  <a href="class_lin_box_1_1_rational_solver_3_01_ring_00_01_field_00_01_random_prime_00_01_method_1_1_wiedemann_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_lin_box_1_1_raw_vector.html">RawVector</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Canonical vector types.  <a href="struct_lin_box_1_1_raw_vector.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_lin_box_1_1_rebind.html">Rebind</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">used in support of <a class="el" href="class_lin_box_1_1_hom.html" title="map element of source ring(field) to target ringAn instance of Hom is a homomorphism from a ring of t...">Hom</a>, <a class="el" href="namespace_lin_box_1_1_matrix_hom.html" title="Limited doc so far. Used in RationalSolver. ">MatrixHom</a>  <a href="struct_lin_box_1_1_rebind.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_lin_box_1_1_rebind_3_01std_1_1vector_3_01_t_01_4_00_01_u_01_4.html">Rebind&lt; std::vector&lt; T &gt;, U &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="struct_lin_box_1_1_rebind.html" title="used in support of Hom, MatrixHom ">Rebind</a>.  <a href="struct_lin_box_1_1_rebind_3_01std_1_1vector_3_01_t_01_4_00_01_u_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lin_box_1_1_reverse_vector.html">ReverseVector</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reverse vector class This class wraps an existing vector type and reverses its direction.  <a href="class_lin_box_1_1_reverse_vector.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lin_box_1_1_ring_abstract.html">RingAbstract</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abstract ring base class.  <a href="class_lin_box_1_1_ring_abstract.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lin_box_1_1_ring_archetype.html">RingArchetype</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">specification and archetypic instance for the ring interfaceThe <a class="el" href="class_lin_box_1_1_ring_archetype.html">RingArchetype</a> and its encapsulated element class contain pointers to the <a class="el" href="class_lin_box_1_1_ring_abstract.html">RingAbstract</a> and its encapsulated ring element, respectively.  <a href="class_lin_box_1_1_ring_archetype.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lin_box_1_1_ring_envelope.html">RingEnvelope</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">implement the ring archetype to minimize code bloat.  <a href="class_lin_box_1_1_ring_envelope.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lin_box_1_1_ring_interface.html">RingInterface</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This ring base class exists solely to aid documentation organization.  <a href="class_lin_box_1_1_ring_interface.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lin_box_1_1_r_n_s.html">RNS</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_lin_box_1_1_r_n_s.html" title="RNS. ">RNS</a>.  <a href="class_lin_box_1_1_r_n_s.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lin_box_1_1_scalar_matrix.html">ScalarMatrix</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Blackbox for <code>aI</code>.  <a href="class_lin_box_1_1_scalar_matrix.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lin_box_1_1_semi_d_iteration.html">SemiDIteration</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">CRA iteration to get a diagonal with the same signature.  <a href="class_lin_box_1_1_semi_d_iteration.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lin_box_1_1show_progression.html">showProgression</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Show progression on the terminal (helper)  <a href="class_lin_box_1_1show_progression.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lin_box_1_1_sigma_basis.html">SigmaBasis</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">implementation of <img class="formulaInl" alt="$\sigma$" src="form_18.png"/>-basis (minimal basis).  <a href="class_lin_box_1_1_sigma_basis.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lin_box_1_1_sliced.html">Sliced</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="class_lin_box_1_1_sliced.html" title="The Sliced Matrix class _Domain must be a GF(3) rep, BaseT must be an unsigned int type...">Sliced</a> Matrix class _Domain must be a GF(3) rep, BaseT must be an unsigned int type.  <a href="class_lin_box_1_1_sliced.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lin_box_1_1_sliced_polynomial_matrix_addin.html">SlicedPolynomialMatrixAddin</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">C += A.  <a href="class_lin_box_1_1_sliced_polynomial_matrix_addin.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lin_box_1_1_sliced_polynomial_matrix_subin.html">SlicedPolynomialMatrixSubin</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">C -= A.  <a href="class_lin_box_1_1_sliced_polynomial_matrix_subin.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lin_box_1_1_sliced_polynomial_vector_addin.html">SlicedPolynomialVectorAddin</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">C += A.  <a href="class_lin_box_1_1_sliced_polynomial_vector_addin.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lin_box_1_1_sliced_polynomial_vector_subin.html">SlicedPolynomialVectorSubin</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">C -= A.  <a href="class_lin_box_1_1_sliced_polynomial_vector_subin.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lin_box_1_1_smith_form_binary.html">SmithFormBinary</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute Smith form.  <a href="class_lin_box_1_1_smith_form_binary.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lin_box_1_1_smith_form_iliopoulos.html">SmithFormIliopoulos</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is Iliopoulos' algorithm to diagonalize.  <a href="class_lin_box_1_1_smith_form_iliopoulos.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lin_box_1_1_smith_form_local.html">SmithFormLocal</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Smith normal form (invariant factors) of a matrix over a local ring.  <a href="class_lin_box_1_1_smith_form_local.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lin_box_1_1_sparse___vector.html">Sparse_Vector</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">vector&lt; Pair&lt;T,I&gt; &gt; and actualsize  <a href="class_lin_box_1_1_sparse___vector.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lin_box_1_1_sparse_l_u_lifting_container.html">SparseLULiftingContainer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_lin_box_1_1_sparse_l_u_lifting_container.html" title="SparseLULiftingContainer. ">SparseLULiftingContainer</a>.  <a href="class_lin_box_1_1_sparse_l_u_lifting_container.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lin_box_1_1_sparse_matrix_3_01___field_00_01_sparse_matrix_format_1_1_c_o_o_01_4.html">SparseMatrix&lt; _Field, SparseMatrixFormat::COO &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sparse matrix, Coordinate storage.  <a href="class_lin_box_1_1_sparse_matrix_3_01___field_00_01_sparse_matrix_format_1_1_c_o_o_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lin_box_1_1_sparse_matrix_3_01___field_00_01_sparse_matrix_format_1_1_c_o_o_1_1implicit_01_4.html">SparseMatrix&lt; _Field, SparseMatrixFormat::COO::implicit &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sparse matrix, Coordinate storage.  <a href="class_lin_box_1_1_sparse_matrix_3_01___field_00_01_sparse_matrix_format_1_1_c_o_o_1_1implicit_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lin_box_1_1_sparse_matrix_3_01___field_00_01_sparse_matrix_format_1_1_c_s_r_01_4.html">SparseMatrix&lt; _Field, SparseMatrixFormat::CSR &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sparse matrix, Coordinate storage.  <a href="class_lin_box_1_1_sparse_matrix_3_01___field_00_01_sparse_matrix_format_1_1_c_s_r_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lin_box_1_1_sparse_matrix_3_01___field_00_01_sparse_matrix_format_1_1_e_l_l_01_4.html">SparseMatrix&lt; _Field, SparseMatrixFormat::ELL &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sparse matrix, Coordinate storage.  <a href="class_lin_box_1_1_sparse_matrix_3_01___field_00_01_sparse_matrix_format_1_1_e_l_l_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lin_box_1_1_sparse_matrix_3_01___field_00_01_sparse_matrix_format_1_1_e_l_l___r_01_4.html">SparseMatrix&lt; _Field, SparseMatrixFormat::ELL_R &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sparse matrix, Coordinate storage.  <a href="class_lin_box_1_1_sparse_matrix_3_01___field_00_01_sparse_matrix_format_1_1_e_l_l___r_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lin_box_1_1_sparse_matrix_3_01___field_00_01_sparse_matrix_format_1_1_h_y_b_01_4.html">SparseMatrix&lt; _Field, SparseMatrixFormat::HYB &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sparse matrix, Coordinate storage.  <a href="class_lin_box_1_1_sparse_matrix_3_01___field_00_01_sparse_matrix_format_1_1_h_y_b_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lin_box_1_1_sparse_matrix_3_01_field___00_01_sparse_matrix_format_1_1_t_p_l_01_4.html">SparseMatrix&lt; Field_, SparseMatrixFormat::TPL &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sparse Matrix in Triples storage.  <a href="class_lin_box_1_1_sparse_matrix_3_01_field___00_01_sparse_matrix_format_1_1_t_p_l_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lin_box_1_1_sparse_matrix_3_01_field___00_01_sparse_matrix_format_1_1_t_p_l__omp_01_4.html">SparseMatrix&lt; Field_, SparseMatrixFormat::TPL_omp &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sparse matrix representation which stores nonzero entries by i,j,value triples.  <a href="class_lin_box_1_1_sparse_matrix_3_01_field___00_01_sparse_matrix_format_1_1_t_p_l__omp_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lin_box_1_1_sparse_matrix_read_helper.html">SparseMatrixReadHelper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read helper.  <a href="class_lin_box_1_1_sparse_matrix_read_helper.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lin_box_1_1_sparse_matrix_write_helper.html">SparseMatrixWriteHelper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write helper.  <a href="class_lin_box_1_1_sparse_matrix_write_helper.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lin_box_1_1_squarize.html">Squarize</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">transpose matrix without copying.  <a href="class_lin_box_1_1_squarize.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lin_box_1_1_standard_basis_stream.html">StandardBasisStream</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stream for <img class="formulaInl" alt="$e_1,\cdots,e_n$" src="form_65.png"/>.  <a href="class_lin_box_1_1_standard_basis_stream.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lin_box_1_1_standard_basis_stream_3_01_field_00_01___vector_00_01_vector_categories_1_1_dense_vector_tag_01_4.html">StandardBasisStream&lt; Field, _Vector, VectorCategories::DenseVectorTag &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization of standard basis stream for dense vectors.  <a href="class_lin_box_1_1_standard_basis_stream_3_01_field_00_01___vector_00_01_vector_categories_1_1_dense_vector_tag_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lin_box_1_1_standard_basis_stream_3_01_field_00_01___vector_00_01_vector_categories_1_1_speb533800f9a893196e1a53ada766ae00.html">StandardBasisStream&lt; Field, _Vector, VectorCategories::SparseAssociativeVectorTag &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization of standard basis stream for sparse associative vectors.  <a href="class_lin_box_1_1_standard_basis_stream_3_01_field_00_01___vector_00_01_vector_categories_1_1_speb533800f9a893196e1a53ada766ae00.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lin_box_1_1_standard_basis_stream_3_01_field_00_01___vector_00_01_vector_categories_1_1_sparse_parallel_vector_tag_01_4.html">StandardBasisStream&lt; Field, _Vector, VectorCategories::SparseParallelVectorTag &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization of standard basis stream for sparse parallel vectors.  <a href="class_lin_box_1_1_standard_basis_stream_3_01_field_00_01___vector_00_01_vector_categories_1_1_sparse_parallel_vector_tag_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lin_box_1_1_standard_basis_stream_3_01_field_00_01___vector_00_01_vector_categories_1_1_sparse_sequence_vector_tag_01_4.html">StandardBasisStream&lt; Field, _Vector, VectorCategories::SparseSequenceVectorTag &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization of standard basis stream for sparse sequence vectors.  <a href="class_lin_box_1_1_standard_basis_stream_3_01_field_00_01___vector_00_01_vector_categories_1_1_sparse_sequence_vector_tag_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lin_box_1_1_storage_meta_data.html">StorageMetaData</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Storage metadata;.  <a href="class_lin_box_1_1_storage_meta_data.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lin_box_1_1_subiterator.html">Subiterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_lin_box_1_1_subvector.html" title="Dense subvectorThis class provides a statically sized subvector of a random access container (such as...">Subvector</a> iterator class provides striding iterators.  <a href="class_lin_box_1_1_subiterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lin_box_1_1_submatrix.html">Submatrix</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">leading principal minor of existing matrix without copying.  <a href="class_lin_box_1_1_submatrix.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lin_box_1_1_submatrix_3_01_blackbox_00_01_vector_categories_1_1_dense_vector_tag_01_4.html">Submatrix&lt; Blackbox, VectorCategories::DenseVectorTag &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization for dense vectors.  <a href="class_lin_box_1_1_submatrix_3_01_blackbox_00_01_vector_categories_1_1_dense_vector_tag_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lin_box_1_1_submatrix_3_01_blackbox_00_01_vector_categories_1_1_dense_zero_one_vector_tag_01_4.html">Submatrix&lt; Blackbox, VectorCategories::DenseZeroOneVectorTag &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization for dense <a class="el" href="class_lin_box_1_1_zero_one.html" title="Time and space efficient representation of sparse {0,1}-matrices. ">ZeroOne</a> vectors.  <a href="class_lin_box_1_1_submatrix_3_01_blackbox_00_01_vector_categories_1_1_dense_zero_one_vector_tag_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lin_box_1_1_submatrix_3_01_blas_matrix_3_01___field_01_4_00_01_vector_categories_1_1_dense_vector_tag_01_4.html">Submatrix&lt; BlasMatrix&lt; _Field &gt;, VectorCategories::DenseVectorTag &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization for <a class="el" href="class_lin_box_1_1_blas_matrix.html" title="Dense matrix representation. ">BlasMatrix</a>.  <a href="class_lin_box_1_1_submatrix_3_01_blas_matrix_3_01___field_01_4_00_01_vector_categories_1_1_dense_vector_tag_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lin_box_1_1_submatrix_adapter.html">SubmatrixAdapter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic submatrix view adapter used internally in the <a class="el" href="class_lin_box_1_1_open_c_l_matrix_domain.html" title="Interface for all functionnalities provided for BlasMatrix using GPUs. ">OpenCLMatrixDomain</a>.  <a href="class_lin_box_1_1_submatrix_adapter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lin_box_1_1_submatrix_owner_3_01_blackbox_00_01_vector_categories_1_1_dense_vector_tag_01_4.html">SubmatrixOwner&lt; Blackbox, VectorCategories::DenseVectorTag &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization for dense vectors.  <a href="class_lin_box_1_1_submatrix_owner_3_01_blackbox_00_01_vector_categories_1_1_dense_vector_tag_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lin_box_1_1_subvector.html">Subvector</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dense subvectorThis class provides a statically sized subvector of a random access container (such as std::vector, deque).  <a href="class_lin_box_1_1_subvector.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lin_box_1_1_sum.html">Sum</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">blackbox of a matrix sum without copying.  <a href="class_lin_box_1_1_sum.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lin_box_1_1_sum_owner.html">SumOwner</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">blackbox of a matrix sum without copying.  <a href="class_lin_box_1_1_sum_owner.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lin_box_1_1_sylvester.html">Sylvester</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a representation of the <a class="el" href="class_lin_box_1_1_sylvester.html" title="This is a representation of the Sylvester matrix of two polynomials. ">Sylvester</a> matrix of two polynomials.  <a href="class_lin_box_1_1_sylvester.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lin_box_1_1_ternary_lattice.html">TernaryLattice</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">NO DOC.  <a href="class_lin_box_1_1_ternary_lattice.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lin_box_1_1_time_watcher.html">TimeWatcher</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper.  <a href="class_lin_box_1_1_time_watcher.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lin_box_1_1_toeplitz.html">Toeplitz</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the blackbox representation of a <a class="el" href="class_lin_box_1_1_toeplitz.html" title="This is the blackbox representation of a Toeplitz matrix. ">Toeplitz</a> matrix.  <a href="class_lin_box_1_1_toeplitz.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lin_box_1_1_toeplitz_3_01typename_01___p_ring_1_1_coeff_field_00_01___p_ring_01_4.html">Toeplitz&lt; typename _PRing::CoeffField, _PRing &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization for when the field of matrix elements is the same as the coefficient field of the polynomial field.  <a href="class_lin_box_1_1_toeplitz_3_01typename_01___p_ring_1_1_coeff_field_00_01___p_ring_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_lin_box_1_1_trace_category.html">TraceCategory</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trait to show whether or not the BB class has a local trace function.  <a href="struct_lin_box_1_1_trace_category.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lin_box_1_1_transpose.html">Transpose</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">transpose matrix without copying.  <a href="class_lin_box_1_1_transpose.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lin_box_1_1_transposed_blas_matrix.html">TransposedBlasMatrix</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_lin_box_1_1_transposed_blas_matrix.html" title="TransposedBlasMatrix. ">TransposedBlasMatrix</a>.  <a href="class_lin_box_1_1_transposed_blas_matrix.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lin_box_1_1_transposed_blas_matrix_3_01_transposed_blas_matrix_3_01_matrix_01_4_01_4.html">TransposedBlasMatrix&lt; TransposedBlasMatrix&lt; Matrix &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_lin_box_1_1_transposed_blas_matrix.html" title="TransposedBlasMatrix. ">TransposedBlasMatrix</a>.  <a href="class_lin_box_1_1_transposed_blas_matrix_3_01_transposed_blas_matrix_3_01_matrix_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lin_box_1_1_transpose_matrix.html">TransposeMatrix</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matrix transpose.  <a href="class_lin_box_1_1_transpose_matrix.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lin_box_1_1_transpose_owner.html">TransposeOwner</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">transpose matrix without copying.  <a href="class_lin_box_1_1_transpose_owner.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lin_box_1_1_triangular_blas_matrix.html">TriangularBlasMatrix</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Triangular BLAS matrix.  <a href="class_lin_box_1_1_triangular_blas_matrix.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_lin_box_1_1_unique_sampling_trait.html">UniqueSamplingTrait</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether a prime generator generates a sequence with non repeating numbers.  <a href="struct_lin_box_1_1_unique_sampling_trait.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lin_box_1_1_unparametric_rand_iter_3_01_n_t_l_1_1_z_z__p_01_4.html">UnparametricRandIter&lt; NTL::ZZ_p &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor for random field element generator.  <a href="class_lin_box_1_1_unparametric_rand_iter_3_01_n_t_l_1_1_z_z__p_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_lin_box_1_1_vector.html">Vector</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="struct_lin_box_1_1_vector.html" title="Vector ?? ">Vector</a> ??  <a href="struct_lin_box_1_1_vector.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_lin_box_1_1_vector_categories.html">VectorCategories</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">List of vector categories.  <a href="struct_lin_box_1_1_vector_categories.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lin_box_1_1_vector_fraction.html">VectorFraction</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">VectorFraction&lt;Domain&gt; is a vector of rational elements with common reduced denominator.  <a href="class_lin_box_1_1_vector_fraction.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lin_box_1_1_vector_stream.html">VectorStream</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="struct_lin_box_1_1_vector.html" title="Vector ?? ">Vector</a> factory.  <a href="class_lin_box_1_1_vector_stream.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_lin_box_1_1_vector_traits.html">VectorTraits</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="struct_lin_box_1_1_vector.html" title="Vector ?? ">Vector</a> traits template structure.  <a href="struct_lin_box_1_1_vector_traits.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lin_box_1_1_wiedemann_lifting_container.html">WiedemannLiftingContainer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wiedemann LiftingContianer.  <a href="class_lin_box_1_1_wiedemann_lifting_container.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lin_box_1_1_wiedemann_solver.html">WiedemannSolver</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Linear system solvers based on Wiedemann's method.  <a href="class_lin_box_1_1_wiedemann_solver.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lin_box_1_1_zero_one.html">ZeroOne</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Time and space efficient representation of sparse {0,1}-matrices.  <a href="class_lin_box_1_1_zero_one.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lin_box_1_1_zero_one_3_01_g_f2_01_4.html">ZeroOne&lt; GF2 &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Time and space efficient representation of sparse matrices over GF2.  <a href="class_lin_box_1_1_zero_one_3_01_g_f2_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lin_box_1_1_z_o_quad.html">ZOQuad</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class of striped or block-decomposed zero-one matrices.  <a href="class_lin_box_1_1_z_o_quad.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:gabc49444d9b849965e6961c10cb44bcf7"><td class="memTemplParams" colspan="2">template&lt;class CRABase &gt; </td></tr>
<tr class="memitem:gabc49444d9b849965e6961c10cb44bcf7"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___c_r_a.html#gabc49444d9b849965e6961c10cb44bcf7">ChineseRemainder</a> = <a class="el" href="struct_lin_box_1_1_chinese_remainder_sequential.html">ChineseRemainderSequential</a>&lt; CRABase &gt;</td></tr>
<tr class="memdesc:gabc49444d9b849965e6961c10cb44bcf7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper around OMP/SEQ version of ChineseRemainderXXX&lt;CRABase&gt;.  <a href="group___c_r_a.html#gabc49444d9b849965e6961c10cb44bcf7">More...</a><br /></td></tr>
<tr class="separator:gabc49444d9b849965e6961c10cb44bcf7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga69460c665a80daebb395e45f6f76db54"><td class="memItemLeft" align="right" valign="top">typedef Givaro::Integer&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__integers.html#ga69460c665a80daebb395e45f6f76db54">integer</a></td></tr>
<tr class="memdesc:ga69460c665a80daebb395e45f6f76db54"><td class="mdescLeft">&#160;</td><td class="mdescRight">Integers in <a class="el" href="namespace_lin_box.html" title="Namespace in which all linbox code resides. ">LinBox</a>.  <a href="group__integers.html#ga69460c665a80daebb395e45f6f76db54">More...</a><br /></td></tr>
<tr class="separator:ga69460c665a80daebb395e45f6f76db54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94cbbcce791d72e74c60f9fbe3ad2921"><td class="memItemLeft" align="right" valign="top"><a id="a94cbbcce791d72e74c60f9fbe3ad2921"></a>
typedef std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_lin_box.html#a94cbbcce791d72e74c60f9fbe3ad2921">dvector_t</a></td></tr>
<tr class="memdesc:a94cbbcce791d72e74c60f9fbe3ad2921"><td class="mdescLeft">&#160;</td><td class="mdescRight">vector of double <br /></td></tr>
<tr class="separator:a94cbbcce791d72e74c60f9fbe3ad2921"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1cb5079586bf243ee34e7b468c81a68d"><td class="memItemLeft" align="right" valign="top"><a id="a1cb5079586bf243ee34e7b468c81a68d"></a>
typedef std::vector&lt; <a class="el" href="namespace_lin_box.html#a94cbbcce791d72e74c60f9fbe3ad2921">dvector_t</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_lin_box.html#a1cb5079586bf243ee34e7b468c81a68d">dmatrix_t</a></td></tr>
<tr class="memdesc:a1cb5079586bf243ee34e7b468c81a68d"><td class="mdescLeft">&#160;</td><td class="mdescRight">matrix of double <br /></td></tr>
<tr class="separator:a1cb5079586bf243ee34e7b468c81a68d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:aa01a95537fc86573cc753898e378253b"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_lin_box.html#aa01a95537fc86573cc753898e378253b">IterationResult</a> { <a class="el" href="namespace_lin_box.html#aa01a95537fc86573cc753898e378253ba2f453cfe638e57e27bb0c9512436111e">CONTINUE</a>, 
<a class="el" href="namespace_lin_box.html#aa01a95537fc86573cc753898e378253bab85df04e922fe1dd3c1f0692faeaacef">SKIP</a>, 
<a class="el" href="namespace_lin_box.html#aa01a95537fc86573cc753898e378253ba1104c54a9ec6549e4ef9562b687596fb">RESTART</a>
 }<tr class="memdesc:aa01a95537fc86573cc753898e378253b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return type for CRA iteration.  <a href="namespace_lin_box.html#aa01a95537fc86573cc753898e378253b">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:aa01a95537fc86573cc753898e378253b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabf95d1fb4fcd12ca89717f0be14212a1"><td class="memItemLeft" align="right" valign="top"><a id="gabf95d1fb4fcd12ca89717f0be14212a1"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__padic.html#gabf95d1fb4fcd12ca89717f0be14212a1">SolverReturnStatus</a> <tr class="memdesc:gabf95d1fb4fcd12ca89717f0be14212a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">define the different return status of the p-adic based solver's computation. <br /></td></tr>
</td></tr>
<tr class="separator:gabf95d1fb4fcd12ca89717f0be14212a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaee2ff986111a9d28c71343fbdc651a9f"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__padic.html#gaee2ff986111a9d28c71343fbdc651a9f">SolverLevel</a> <tr class="memdesc:gaee2ff986111a9d28c71343fbdc651a9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Define the different strategy which can be used in the p-adic based solver.  <a href="group__padic.html#gaee2ff986111a9d28c71343fbdc651a9f">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:gaee2ff986111a9d28c71343fbdc651a9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac48d19db31bc6518994e9a0e2aafbe55"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_lin_box.html#ac48d19db31bc6518994e9a0e2aafbe55">Singularity</a> { <a class="el" href="namespace_lin_box.html#ac48d19db31bc6518994e9a0e2aafbe55a88183b946cc5f0e8c96b2e66e1c74a7e">Unknown</a>, 
<a class="el" href="namespace_lin_box.html#ac48d19db31bc6518994e9a0e2aafbe55ad8d948ef62e0cd4caec19ca9c0e29438">Singular</a>, 
<a class="el" href="namespace_lin_box.html#ac48d19db31bc6518994e9a0e2aafbe55a2f8ab52628435cfcfbf74aa206b84c54">NonSingular</a>
 }<tr class="memdesc:ac48d19db31bc6518994e9a0e2aafbe55"><td class="mdescLeft">&#160;</td><td class="mdescRight">Singularity of the system.  <a href="namespace_lin_box.html#ac48d19db31bc6518994e9a0e2aafbe55">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:ac48d19db31bc6518994e9a0e2aafbe55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10235377a5d8fe76c611f71b195cb97e"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_lin_box.html#a10235377a5d8fe76c611f71b195cb97e">Dispatch</a> { <br />
&#160;&#160;<a class="el" href="namespace_lin_box.html#a10235377a5d8fe76c611f71b195cb97ea06b9281e396db002010bde1de57262eb">Auto</a>, 
<a class="el" href="namespace_lin_box.html#a10235377a5d8fe76c611f71b195cb97eaa7e82daa7280af25afbaa076ac16eb1e">Sequential</a>, 
<a class="el" href="namespace_lin_box.html#a10235377a5d8fe76c611f71b195cb97eaedb3c4d18c4d80ab94156b7df8669c17">SMP</a>, 
<a class="el" href="namespace_lin_box.html#a10235377a5d8fe76c611f71b195cb97ea8c16cbebef45d87fd2b36ce69f46c526">Distributed</a>, 
<br />
&#160;&#160;<a class="el" href="namespace_lin_box.html#a10235377a5d8fe76c611f71b195cb97ea55f4b4a94111759e08b3acb1acd12b8c">Combined</a>
<br />
 }<tr class="memdesc:a10235377a5d8fe76c611f71b195cb97e"><td class="mdescLeft">&#160;</td><td class="mdescRight">For integer-based methods that evaluate multiple times the system at different moduli, decides how to dispatch each sub-computations.  <a href="namespace_lin_box.html#a10235377a5d8fe76c611f71b195cb97e">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:a10235377a5d8fe76c611f71b195cb97e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bb2ba2f883b980c7f099ff88780c979"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_lin_box.html#a8bb2ba2f883b980c7f099ff88780c979">SingularSolutionType</a> { <a class="el" href="namespace_lin_box.html#a8bb2ba2f883b980c7f099ff88780c979ac172d0b7b7d4c61a931d50369d37b11f">Deterministic</a>, 
<a class="el" href="namespace_lin_box.html#a8bb2ba2f883b980c7f099ff88780c979a64663f4646781c9c0110838b905daa23">Random</a>, 
<a class="el" href="namespace_lin_box.html#a8bb2ba2f883b980c7f099ff88780c979a66ce80e4c8c2f9e396a68443123e9a9b">Diophantine</a>
 }<tr class="memdesc:a8bb2ba2f883b980c7f099ff88780c979"><td class="mdescLeft">&#160;</td><td class="mdescRight">For Dixon method, which solution type to get when the system is singular.  <a href="namespace_lin_box.html#a8bb2ba2f883b980c7f099ff88780c979">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:a8bb2ba2f883b980c7f099ff88780c979"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adac1c2aa74e98e485c02f73279b71a38"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_lin_box.html#adac1c2aa74e98e485c02f73279b71a38">Preconditioner</a> { <br />
&#160;&#160;<a class="el" href="namespace_lin_box.html#adac1c2aa74e98e485c02f73279b71a38a6adf97f83acf6453d4a6a4b1070f3754">None</a>, 
<a class="el" href="namespace_lin_box.html#adac1c2aa74e98e485c02f73279b71a38a29ecfc45c7bd93061222062f86d4161d">Butterfly</a>, 
<a class="el" href="namespace_lin_box.html#adac1c2aa74e98e485c02f73279b71a38a7407fb7e6a4df6392aaabd2368157312">Sparse</a>, 
<a class="el" href="namespace_lin_box.html#adac1c2aa74e98e485c02f73279b71a38a0997ef5d0d6bb91dd9f45c07f854cfc6">Toeplitz</a>, 
<br />
&#160;&#160;<a class="el" href="namespace_lin_box.html#adac1c2aa74e98e485c02f73279b71a38aed6d39beb2a6a848f7a46781bee2a6d9">Symmetrize</a>, 
<a class="el" href="namespace_lin_box.html#adac1c2aa74e98e485c02f73279b71a38a969dc23d80808af65801199eb634693a">PartialDiagonal</a>, 
<a class="el" href="namespace_lin_box.html#adac1c2aa74e98e485c02f73279b71a38ae0b27830bfdf7a0c6a232085ddd9fb69">PartialDiagonalSymmetrize</a>, 
<a class="el" href="namespace_lin_box.html#adac1c2aa74e98e485c02f73279b71a38a8e5f43eeeda5a7d8b1d188981c45213b">FullDiagonal</a>, 
<br />
&#160;&#160;<a class="el" href="namespace_lin_box.html#adac1c2aa74e98e485c02f73279b71a38a9a71a13863c84ba34fc41595fc2ee0c6">Dense</a>
<br />
 }<tr class="memdesc:adac1c2aa74e98e485c02f73279b71a38"><td class="mdescLeft">&#160;</td><td class="mdescRight">Preconditioner to ensure generic rank profile.  <a href="namespace_lin_box.html#adac1c2aa74e98e485c02f73279b71a38">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:adac1c2aa74e98e485c02f73279b71a38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a001800b53b776b368a84dc646ee6499d"><td class="memItemLeft" align="right" valign="top"><a id="a001800b53b776b368a84dc646ee6499d"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_lin_box.html#a001800b53b776b368a84dc646ee6499d">PivotStrategy</a> <tr class="memdesc:a001800b53b776b368a84dc646ee6499d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pivoting strategy for elimination-based methods. <br /></td></tr>
</td></tr>
<tr class="separator:a001800b53b776b368a84dc646ee6499d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gaf8b9af317f1f9509e7dedcc0fd5da5bd"><td class="memTemplParams" colspan="2">template&lt;class Polynomial , class Blackbox &gt; </td></tr>
<tr class="memitem:gaf8b9af317f1f9509e7dedcc0fd5da5bd"><td class="memTemplItemLeft" align="right" valign="top">Polynomial &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__algorithms.html#gaf8b9af317f1f9509e7dedcc0fd5da5bd">cia</a> (Polynomial &amp;P, const Blackbox &amp;A, const Method::DenseElimination &amp;M)</td></tr>
<tr class="memdesc:gaf8b9af317f1f9509e7dedcc0fd5da5bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Algorithm computing the integer characteristic polynomial of a dense matrix.  <a href="group__algorithms.html#gaf8b9af317f1f9509e7dedcc0fd5da5bd">More...</a><br /></td></tr>
<tr class="separator:gaf8b9af317f1f9509e7dedcc0fd5da5bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8ed0690d6e590bc71b4653ce434f20ba"><td class="memItemLeft" align="right" valign="top">
uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_r_a.html#ga8ed0690d6e590bc71b4653ce434f20ba">primes_count</a> (size_t pbits)</td></tr>
<tr class="memdesc:ga8ed0690d6e590bc71b4653ce434f20ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lower bound on number of b-bit primes. <br /></td></tr>
<tr class="separator:ga8ed0690d6e590bc71b4653ce434f20ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd31751f8254901f546a014ff89ae8dc"><td class="memTemplParams" colspan="2">template&lt;class Field &gt; </td></tr>
<tr class="memitem:afd31751f8254901f546a014ff89ae8dc"><td class="memTemplItemLeft" align="right" valign="top">size_t &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_lin_box.html#afd31751f8254901f546a014ff89ae8dc">NullSpaceBasisIn</a> (const <a class="el" href="namespace_lin_box_1_1_tag.html#a9cb105f1dce242753103f15ee5e767a6">Tag::Side</a> Side, <a class="el" href="class_lin_box_1_1_blas_matrix.html">BlasMatrix</a>&lt; Field &gt; &amp;A, <a class="el" href="class_lin_box_1_1_blas_matrix.html">BlasMatrix</a>&lt; Field &gt; &amp;Ker, size_t &amp;kerdim)</td></tr>
<tr class="memdesc:afd31751f8254901f546a014ff89ae8dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Nullspace of a dense matrix on a finite field.  <a href="#afd31751f8254901f546a014ff89ae8dc">More...</a><br /></td></tr>
<tr class="separator:afd31751f8254901f546a014ff89ae8dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a864a1c4b74c1472ee876af306a1a1c76"><td class="memTemplParams" colspan="2">template&lt;class DenseMat &gt; </td></tr>
<tr class="memitem:a864a1c4b74c1472ee876af306a1a1c76"><td class="memTemplItemLeft" align="right" valign="top">size_t &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_lin_box.html#a864a1c4b74c1472ee876af306a1a1c76">NullSpaceBasisIn</a> (const <a class="el" href="namespace_lin_box_1_1_tag.html#a9cb105f1dce242753103f15ee5e767a6">Tag::Side</a> Side, <a class="el" href="class_lin_box_1_1_blas_submatrix.html">BlasSubmatrix</a>&lt; <a class="el" href="class_lin_box_1_1_dense_mat.html">DenseMat</a> &gt; &amp;A, <a class="el" href="class_lin_box_1_1_blas_matrix.html">BlasMatrix</a>&lt; typename DenseMat::Field &gt; &amp;Ker, size_t &amp;kerdim)</td></tr>
<tr class="separator:a864a1c4b74c1472ee876af306a1a1c76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a459cc873d0c9b59fd8206cb878d734e0"><td class="memTemplParams" colspan="2">template&lt;class Field &gt; </td></tr>
<tr class="memitem:a459cc873d0c9b59fd8206cb878d734e0"><td class="memTemplItemLeft" align="right" valign="top">size_t &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_lin_box.html#a459cc873d0c9b59fd8206cb878d734e0">NullSpaceBasis</a> (const <a class="el" href="namespace_lin_box_1_1_tag.html#a9cb105f1dce242753103f15ee5e767a6">Tag::Side</a> Side, const <a class="el" href="class_lin_box_1_1_blas_matrix.html">BlasMatrix</a>&lt; Field &gt; &amp;A, <a class="el" href="class_lin_box_1_1_blas_matrix.html">BlasMatrix</a>&lt; Field &gt; &amp;Ker, size_t &amp;kerdim)</td></tr>
<tr class="memdesc:a459cc873d0c9b59fd8206cb878d734e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Nullspace of a dense matrix on a finite field.  <a href="#a459cc873d0c9b59fd8206cb878d734e0">More...</a><br /></td></tr>
<tr class="separator:a459cc873d0c9b59fd8206cb878d734e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff1c51aeaaf27483111a6e82abe344e6"><td class="memTemplParams" colspan="2">template&lt;class Field &gt; </td></tr>
<tr class="memitem:aff1c51aeaaf27483111a6e82abe344e6"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_lin_box.html#aff1c51aeaaf27483111a6e82abe344e6">NullSpaceBasisIn</a> (const Field &amp;F, const <a class="el" href="namespace_lin_box_1_1_tag.html#a9cb105f1dce242753103f15ee5e767a6">Tag::Side</a> Side, const size_t &amp;m, const size_t &amp;n, typename Field::Element *A, const size_t &amp;lda, typename Field::Element *&amp;Ker, size_t &amp;ldk, size_t &amp;kerdim)</td></tr>
<tr class="memdesc:aff1c51aeaaf27483111a6e82abe344e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the kernel of a dense matrix using <code>LQUP</code>.  <a href="#aff1c51aeaaf27483111a6e82abe344e6">More...</a><br /></td></tr>
<tr class="separator:aff1c51aeaaf27483111a6e82abe344e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4da40968c90f38c6f0c0f5a0a9d7478"><td class="memTemplParams" colspan="2">template&lt;class Ring &gt; </td></tr>
<tr class="memitem:ad4da40968c90f38c6f0c0f5a0a9d7478"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_lin_box.html#ad4da40968c90f38c6f0c0f5a0a9d7478">partial_hegcd</a> (Ring &amp;Z, typename Ring::Element &amp;e, typename Ring::Element &amp;b, const typename Ring::Element &amp;n, const typename Ring::Element &amp;d, const typename Ring::Element &amp;denBound)</td></tr>
<tr class="memdesc:ad4da40968c90f38c6f0c0f5a0a9d7478"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="namespace_lin_box.html#ad4da40968c90f38c6f0c0f5a0a9d7478" title="partial_hegcd() sets e, b from the remainder sequence of n,d. ">partial_hegcd()</a> sets e, b from the remainder sequence of n,d.  <a href="#ad4da40968c90f38c6f0c0f5a0a9d7478">More...</a><br /></td></tr>
<tr class="separator:ad4da40968c90f38c6f0c0f5a0a9d7478"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a291ce9ee1caffc6a62e86e773e943cae"><td class="memTemplParams" colspan="2">template&lt;class Ring &gt; </td></tr>
<tr class="memitem:a291ce9ee1caffc6a62e86e773e943cae"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_lin_box.html#a291ce9ee1caffc6a62e86e773e943cae">dyadicToRational</a> (const Ring &amp;Z, typename Ring::Element &amp;a, typename Ring::Element &amp;b, const typename Ring::Element &amp;n, const typename Ring::Element &amp;d, const typename Ring::Element &amp;B)</td></tr>
<tr class="memdesc:a291ce9ee1caffc6a62e86e773e943cae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rational reconstruction of a/b from n/d with denominator bound B.  <a href="#a291ce9ee1caffc6a62e86e773e943cae">More...</a><br /></td></tr>
<tr class="separator:a291ce9ee1caffc6a62e86e773e943cae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadd341dddd79681523103d316cdf03a95"><td class="memTemplParams" colspan="2">template&lt;class Blackbox , class MyMethod &gt; </td></tr>
<tr class="memitem:gadd341dddd79681523103d316cdf03a95"><td class="memTemplItemLeft" align="right" valign="top">Blackbox::Field::Element &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__solutions.html#gadd341dddd79681523103d316cdf03a95">lif_cra_det</a> (typename Blackbox::Field::Element &amp;d, const Blackbox &amp;A, const <a class="el" href="struct_lin_box_1_1_ring_categories_1_1_integer_tag.html">RingCategories::IntegerTag</a> &amp;tag, const MyMethod &amp;M)</td></tr>
<tr class="memdesc:gadd341dddd79681523103d316cdf03a95"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the determinant of A over the integers.  <a href="group__solutions.html#gadd341dddd79681523103d316cdf03a95">More...</a><br /></td></tr>
<tr class="separator:gadd341dddd79681523103d316cdf03a95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabc0d17f244bcbc1ceaaea39f3c9169d"><td class="memItemLeft" align="right" valign="top"><a id="aabc0d17f244bcbc1ceaaea39f3c9169d"></a>
std::vector&lt; cl_platform_id &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_lin_box.html#aabc0d17f244bcbc1ceaaea39f3c9169d">enumPlatforms</a> ()</td></tr>
<tr class="memdesc:aabc0d17f244bcbc1ceaaea39f3c9169d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enumerate all of the platforms currently available on the system. <br /></td></tr>
<tr class="separator:aabc0d17f244bcbc1ceaaea39f3c9169d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83021aff81a9da3ee8a0cf33ad07828e"><td class="memItemLeft" align="right" valign="top"><a id="a83021aff81a9da3ee8a0cf33ad07828e"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_lin_box.html#a83021aff81a9da3ee8a0cf33ad07828e">getPlatformName</a> (cl_platform_id platform)</td></tr>
<tr class="memdesc:a83021aff81a9da3ee8a0cf33ad07828e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the platform name associated with the platform. <br /></td></tr>
<tr class="separator:a83021aff81a9da3ee8a0cf33ad07828e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70da039ea6723b52ef9d7641344ca38f"><td class="memItemLeft" align="right" valign="top"><a id="a70da039ea6723b52ef9d7641344ca38f"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_lin_box.html#a70da039ea6723b52ef9d7641344ca38f">getPlatformVersion</a> (cl_platform_id platform)</td></tr>
<tr class="memdesc:a70da039ea6723b52ef9d7641344ca38f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the platform version associated with the platform. <br /></td></tr>
<tr class="separator:a70da039ea6723b52ef9d7641344ca38f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa794a5954fdcd55f552b79cfd0bd5be1"><td class="memItemLeft" align="right" valign="top"><a id="aa794a5954fdcd55f552b79cfd0bd5be1"></a>
std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_lin_box.html#aa794a5954fdcd55f552b79cfd0bd5be1">getPlatformExtensions</a> (cl_platform_id platform)</td></tr>
<tr class="memdesc:aa794a5954fdcd55f552b79cfd0bd5be1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the platform extensions associated with the platform. <br /></td></tr>
<tr class="separator:aa794a5954fdcd55f552b79cfd0bd5be1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad972a69782b338ed5e8c761818cacf5d"><td class="memItemLeft" align="right" valign="top"><a id="ad972a69782b338ed5e8c761818cacf5d"></a>
std::vector&lt; cl_device_id &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_lin_box.html#ad972a69782b338ed5e8c761818cacf5d">enumDevices</a> (cl_platform_id platform)</td></tr>
<tr class="memdesc:ad972a69782b338ed5e8c761818cacf5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enumerate all of the devices currently available on the platform. <br /></td></tr>
<tr class="separator:ad972a69782b338ed5e8c761818cacf5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2705dad9caa7a18f21f4ff7d4fddfcc9"><td class="memItemLeft" align="right" valign="top"><a id="a2705dad9caa7a18f21f4ff7d4fddfcc9"></a>
cl_context&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_lin_box.html#a2705dad9caa7a18f21f4ff7d4fddfcc9">createContext</a> (cl_platform_id platform, cl_device_id device)</td></tr>
<tr class="memdesc:a2705dad9caa7a18f21f4ff7d4fddfcc9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an OpenCL context from a platfrom and device. <br /></td></tr>
<tr class="separator:a2705dad9caa7a18f21f4ff7d4fddfcc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34c6fa70e417caf67f6ae08942d4a4c0"><td class="memTemplParams" colspan="2">template&lt;class Prime &gt; </td></tr>
<tr class="memitem:a34c6fa70e417caf67f6ae08942d4a4c0"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_lin_box.html#a34c6fa70e417caf67f6ae08942d4a4c0">checkBlasPrime</a> (const Prime p)</td></tr>
<tr class="memdesc:a34c6fa70e417caf67f6ae08942d4a4c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">NO DOC !  <a href="#a34c6fa70e417caf67f6ae08942d4a4c0">More...</a><br /></td></tr>
<tr class="separator:a34c6fa70e417caf67f6ae08942d4a4c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34eb4fcb62935f82612309c432c9be90"><td class="memItemLeft" align="right" valign="top"><a id="a34eb4fcb62935f82612309c432c9be90"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_lin_box.html#a34eb4fcb62935f82612309c432c9be90">large_double_division</a> (<a class="el" href="group__integers.html#ga69460c665a80daebb395e45f6f76db54">integer</a> &amp;x, const <a class="el" href="group__integers.html#ga69460c665a80daebb395e45f6f76db54">integer</a> &amp;y, const <a class="el" href="group__integers.html#ga69460c665a80daebb395e45f6f76db54">integer</a> &amp;z)</td></tr>
<tr class="memdesc:a34eb4fcb62935f82612309c432c9be90"><td class="mdescLeft">&#160;</td><td class="mdescRight">NO DOC. <br /></td></tr>
<tr class="separator:a34eb4fcb62935f82612309c432c9be90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54184071e65cc180eee2b801a829506d"><td class="memTemplParams" colspan="2"><a id="a54184071e65cc180eee2b801a829506d"></a>
template&lt;class Domain &gt; </td></tr>
<tr class="memitem:a54184071e65cc180eee2b801a829506d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_lin_box.html#a54184071e65cc180eee2b801a829506d">reduceIn</a> (<a class="el" href="class_lin_box_1_1_matrix_domain.html">Domain</a> &amp;D, std::pair&lt; typename Domain::Element, typename Domain::Element &gt; &amp;frac)</td></tr>
<tr class="memdesc:a54184071e65cc180eee2b801a829506d"><td class="mdescLeft">&#160;</td><td class="mdescRight">utility function to reduce a rational pair to lowest form <br /></td></tr>
<tr class="separator:a54184071e65cc180eee2b801a829506d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6860664661b209a88f390202a1b2c2c"><td class="memTemplParams" colspan="2"><a id="af6860664661b209a88f390202a1b2c2c"></a>
template&lt;class Domain , class Vector &gt; </td></tr>
<tr class="memitem:af6860664661b209a88f390202a1b2c2c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_lin_box.html#af6860664661b209a88f390202a1b2c2c">vectorGcdIn</a> (typename Domain::Element &amp;result, <a class="el" href="class_lin_box_1_1_matrix_domain.html">Domain</a> &amp;D, <a class="el" href="struct_lin_box_1_1_vector.html">Vector</a> &amp;v)</td></tr>
<tr class="memdesc:af6860664661b209a88f390202a1b2c2c"><td class="mdescLeft">&#160;</td><td class="mdescRight">utility function to gcd-in a vector of elements over a domain <br /></td></tr>
<tr class="separator:af6860664661b209a88f390202a1b2c2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66ba4ad65fa55c7e9e685cd0bb8fff4e"><td class="memTemplParams" colspan="2"><a id="a66ba4ad65fa55c7e9e685cd0bb8fff4e"></a>
template&lt;class Domain , class Vector &gt; </td></tr>
<tr class="memitem:a66ba4ad65fa55c7e9e685cd0bb8fff4e"><td class="memTemplItemLeft" align="right" valign="top">Domain::Element&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_lin_box.html#a66ba4ad65fa55c7e9e685cd0bb8fff4e">vectorGcd</a> (<a class="el" href="class_lin_box_1_1_matrix_domain.html">Domain</a> &amp;D, <a class="el" href="struct_lin_box_1_1_vector.html">Vector</a> &amp;v)</td></tr>
<tr class="memdesc:a66ba4ad65fa55c7e9e685cd0bb8fff4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">utility function, returns gcd of a vector of elements over a domain <br /></td></tr>
<tr class="separator:a66ba4ad65fa55c7e9e685cd0bb8fff4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3cc295b1c4afedee8007e8d17d9315a"><td class="memTemplParams" colspan="2">template&lt;class Domain , class IMatrix &gt; </td></tr>
<tr class="memitem:ad3cc295b1c4afedee8007e8d17d9315a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_lin_box.html#ad3cc295b1c4afedee8007e8d17d9315a">create_MatrixQadic</a> (const Domain &amp;D, const IMatrix &amp;<a class="el" href="class_lin_box_1_1_blas_matrix.html">Mat</a>, double *chunks, size_t num_chunks, const <a class="el" href="group__integers.html#ga69460c665a80daebb395e45f6f76db54">integer</a> shift)</td></tr>
<tr class="memdesc:ad3cc295b1c4afedee8007e8d17d9315a"><td class="mdescLeft">&#160;</td><td class="mdescRight">split an integer matrix into a padic chunk representation  <a href="#ad3cc295b1c4afedee8007e8d17d9315a">More...</a><br /></td></tr>
<tr class="separator:ad3cc295b1c4afedee8007e8d17d9315a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71dc6f175dd9ce18d05876d4df55f9ae"><td class="memTemplParams" colspan="2">template&lt;class Domain , class Vector &gt; </td></tr>
<tr class="memitem:a71dc6f175dd9ce18d05876d4df55f9ae"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_lin_box.html#a71dc6f175dd9ce18d05876d4df55f9ae">create_VectorQadic</a> (const Domain &amp;D, const <a class="el" href="struct_lin_box_1_1_vector.html">Vector</a> &amp;V, double *chunks, size_t num_chunks)</td></tr>
<tr class="memdesc:a71dc6f175dd9ce18d05876d4df55f9ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">split an integer vector into a padic chunk representation  <a href="#a71dc6f175dd9ce18d05876d4df55f9ae">More...</a><br /></td></tr>
<tr class="separator:a71dc6f175dd9ce18d05876d4df55f9ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ddbba67773a02edfc666b3aa7bd2d9c"><td class="memTemplParams" colspan="2">template&lt;class Domain , class Vector &gt; </td></tr>
<tr class="memitem:a6ddbba67773a02edfc666b3aa7bd2d9c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_lin_box.html#a6ddbba67773a02edfc666b3aa7bd2d9c">create_VectorQadic_32</a> (const Domain &amp;D, const <a class="el" href="struct_lin_box_1_1_vector.html">Vector</a> &amp;V, double *chunks, size_t num_chunks)</td></tr>
<tr class="memdesc:a6ddbba67773a02edfc666b3aa7bd2d9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">split an integer vector into a padic chunk representation  <a href="#a6ddbba67773a02edfc666b3aa7bd2d9c">More...</a><br /></td></tr>
<tr class="separator:a6ddbba67773a02edfc666b3aa7bd2d9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3e30a631eb4c03a29025d24e778b461"><td class="memTemplParams" colspan="2"><a id="ad3e30a631eb4c03a29025d24e778b461"></a>
template&lt;class Field &gt; </td></tr>
<tr class="memitem:ad3e30a631eb4c03a29025d24e778b461"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_lin_box_1_1_blas_matrix.html">DenseMatrix</a>&lt; Field &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_lin_box.html#ad3e30a631eb4c03a29025d24e778b461">genericNullspaceRandomRight</a> (<a class="el" href="class_lin_box_1_1_blas_matrix.html">DenseMatrix</a>&lt; Field &gt; &amp;N, const FIBB&lt; Field &gt; &amp;A)</td></tr>
<tr class="memdesc:ad3e30a631eb4c03a29025d24e778b461"><td class="mdescLeft">&#160;</td><td class="mdescRight">N: AN = 0, each col random. <br /></td></tr>
<tr class="separator:ad3e30a631eb4c03a29025d24e778b461"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a371d5c71e5e94019b102f1e4932a4cd3"><td class="memTemplParams" colspan="2"><a id="a371d5c71e5e94019b102f1e4932a4cd3"></a>
template&lt;class Field &gt; </td></tr>
<tr class="memitem:a371d5c71e5e94019b102f1e4932a4cd3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_lin_box_1_1_blas_matrix.html">DenseMatrix</a>&lt; Field &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_lin_box.html#a371d5c71e5e94019b102f1e4932a4cd3">genericNullspaceRandomLeft</a> (<a class="el" href="class_lin_box_1_1_blas_matrix.html">DenseMatrix</a>&lt; Field &gt; &amp;N, const FIBB&lt; Field &gt; &amp;A)</td></tr>
<tr class="memdesc:a371d5c71e5e94019b102f1e4932a4cd3"><td class="mdescLeft">&#160;</td><td class="mdescRight">N: NA = 0, each row random. <br /></td></tr>
<tr class="separator:a371d5c71e5e94019b102f1e4932a4cd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a685681f5c16e22c4b3dbbedd3aa09f32"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_lin_box.html#a685681f5c16e22c4b3dbbedd3aa09f32">naturallog</a> (const Givaro::Integer &amp;a)</td></tr>
<tr class="memdesc:a685681f5c16e22c4b3dbbedd3aa09f32"><td class="mdescLeft">&#160;</td><td class="mdescRight">Natural logarithm (ln).  <a href="#a685681f5c16e22c4b3dbbedd3aa09f32">More...</a><br /></td></tr>
<tr class="separator:a685681f5c16e22c4b3dbbedd3aa09f32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1532e1a9a6996527a47cdcda184e4972"><td class="memTemplParams" colspan="2">template&lt;class _Field , class _Storage &gt; </td></tr>
<tr class="memitem:a1532e1a9a6996527a47cdcda184e4972"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_lin_box.html#a1532e1a9a6996527a47cdcda184e4972">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="class_lin_box_1_1_blas_matrix.html">BlasMatrix</a>&lt; _Field, _Storage &gt; &amp;<a class="el" href="class_lin_box_1_1_blas_matrix.html">Mat</a>)</td></tr>
<tr class="memdesc:a1532e1a9a6996527a47cdcda184e4972"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write a matrix to a stream.  <a href="#a1532e1a9a6996527a47cdcda184e4972">More...</a><br /></td></tr>
<tr class="separator:a1532e1a9a6996527a47cdcda184e4972"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23bda014eb3e127b6d6e4853a937d92a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_lin_box.html#a23bda014eb3e127b6d6e4853a937d92a">RandomBlasPermutation</a> (<a class="el" href="class_lin_box_1_1_blas_permutation.html">BlasPermutation</a>&lt; size_t &gt; &amp;P)</td></tr>
<tr class="separator:a23bda014eb3e127b6d6e4853a937d92a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adac36fcecbe6faa1f650365eaf2ada9e"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:adac36fcecbe6faa1f650365eaf2ada9e"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_lin_box.html#adac36fcecbe6faa1f650365eaf2ada9e">operator&lt;&lt;</a> (std::ostream &amp;o, const <a class="el" href="class_lin_box_1_1_dense_mat.html">DenseMat</a>&lt; T &gt; &amp;<a class="el" href="class_lin_box_1_1_blas_matrix.html">Mat</a>)</td></tr>
<tr class="memdesc:adac36fcecbe6faa1f650365eaf2ada9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write a matrix to a stream.  <a href="#adac36fcecbe6faa1f650365eaf2ada9e">More...</a><br /></td></tr>
<tr class="separator:adac36fcecbe6faa1f650365eaf2ada9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5dce21ab38ae1f7de0e6d8a96ab0b95d"><td class="memTemplParams" colspan="2">template&lt;class Field , class Vector &gt; </td></tr>
<tr class="memitem:a5dce21ab38ae1f7de0e6d8a96ab0b95d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="struct_lin_box_1_1_vector.html">Vector</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_lin_box.html#a5dce21ab38ae1f7de0e6d8a96ab0b95d">prepare</a> (const Field &amp;F, <a class="el" href="struct_lin_box_1_1_vector.html">Vector</a> &amp;y, const typename Field::Element &amp;a)</td></tr>
<tr class="memdesc:a5dce21ab38ae1f7de0e6d8a96ab0b95d"><td class="mdescLeft">&#160;</td><td class="mdescRight">y &lt;- ay.  <a href="#a5dce21ab38ae1f7de0e6d8a96ab0b95d">More...</a><br /></td></tr>
<tr class="separator:a5dce21ab38ae1f7de0e6d8a96ab0b95d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a740a339db9f98fa431d9c35a2608bb74"><td class="memTemplParams" colspan="2">template&lt;typename Container &gt; </td></tr>
<tr class="memitem:a740a339db9f98fa431d9c35a2608bb74"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_lin_box_1_1_prime_sequence.html">PrimeSequence</a>&lt; typename Container::const_iterator &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_lin_box.html#a740a339db9f98fa431d9c35a2608bb74">create_prime_sequence</a> (const Container &amp;cont)</td></tr>
<tr class="memdesc:a740a339db9f98fa431d9c35a2608bb74"><td class="mdescLeft">&#160;</td><td class="mdescRight">convenience factory to create a <a class="el" href="class_lin_box_1_1_prime_sequence.html" title="Adaptor class to make a fixed-length sequence behave like a PrimeIterator. ">PrimeSequence</a> from an STL-like container.  <a href="#a740a339db9f98fa431d9c35a2608bb74">More...</a><br /></td></tr>
<tr class="separator:a740a339db9f98fa431d9c35a2608bb74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10620e33be02e43a88f6bcab547b6d9b"><td class="memTemplParams" colspan="2">template&lt;class Blackbox , class Polynomial , class MyMethod &gt; </td></tr>
<tr class="memitem:a10620e33be02e43a88f6bcab547b6d9b"><td class="memTemplItemLeft" align="right" valign="top">Polynomial &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_lin_box.html#a10620e33be02e43a88f6bcab547b6d9b">charpoly</a> (Polynomial &amp;P, const Blackbox &amp;A, const MyMethod &amp;M)</td></tr>
<tr class="memdesc:a10620e33be02e43a88f6bcab547b6d9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">...using an optional <a class="el" href="struct_lin_box_1_1_method.html" title="Define which method to use when working on a system. ">Method</a> parameter  <a href="#a10620e33be02e43a88f6bcab547b6d9b">More...</a><br /></td></tr>
<tr class="separator:a10620e33be02e43a88f6bcab547b6d9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fefe0ee0dda0dbf12cfac0181e73697"><td class="memTemplParams" colspan="2"><a id="a5fefe0ee0dda0dbf12cfac0181e73697"></a>
template&lt;class Blackbox , class Polynomial &gt; </td></tr>
<tr class="memitem:a5fefe0ee0dda0dbf12cfac0181e73697"><td class="memTemplItemLeft" align="right" valign="top">Polynomial &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_lin_box.html#a5fefe0ee0dda0dbf12cfac0181e73697">charpoly</a> (Polynomial &amp;P, const Blackbox &amp;A)</td></tr>
<tr class="memdesc:a5fefe0ee0dda0dbf12cfac0181e73697"><td class="mdescLeft">&#160;</td><td class="mdescRight">...using default method <br /></td></tr>
<tr class="separator:a5fefe0ee0dda0dbf12cfac0181e73697"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a283f87fdb8f32c71024bbf3df97812"><td class="memTemplParams" colspan="2">template&lt;class Blackbox , class Polynomial &gt; </td></tr>
<tr class="memitem:a8a283f87fdb8f32c71024bbf3df97812"><td class="memTemplItemLeft" align="right" valign="top">Polynomial &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_lin_box.html#a8a283f87fdb8f32c71024bbf3df97812">charpoly</a> (Polynomial &amp;P, const Blackbox &amp;A, const <a class="el" href="struct_lin_box_1_1_ring_categories_1_1_modular_tag.html">RingCategories::ModularTag</a> &amp;tag, const Method::DenseElimination &amp;M)</td></tr>
<tr class="memdesc:a8a283f87fdb8f32c71024bbf3df97812"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the characteristic polynomial over <img class="formulaInl" alt="$\mathbf{Z}_p$" src="form_61.png"/>.  <a href="#a8a283f87fdb8f32c71024bbf3df97812">More...</a><br /></td></tr>
<tr class="separator:a8a283f87fdb8f32c71024bbf3df97812"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48263ffbcd961eb72f8999d17d1845b6"><td class="memTemplParams" colspan="2">template&lt;class Blackbox , class Polynomial &gt; </td></tr>
<tr class="memitem:a48263ffbcd961eb72f8999d17d1845b6"><td class="memTemplItemLeft" align="right" valign="top">Polynomial &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_lin_box.html#a48263ffbcd961eb72f8999d17d1845b6">charpoly</a> (Polynomial &amp;P, const Blackbox &amp;A, const <a class="el" href="struct_lin_box_1_1_ring_categories_1_1_modular_tag.html">RingCategories::ModularTag</a> &amp;tag, const Method::Blackbox &amp;M)</td></tr>
<tr class="memdesc:a48263ffbcd961eb72f8999d17d1845b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the characteristic polynomial over <img class="formulaInl" alt="$\mathbf{Z}_p$" src="form_61.png"/>.  <a href="#a48263ffbcd961eb72f8999d17d1845b6">More...</a><br /></td></tr>
<tr class="separator:a48263ffbcd961eb72f8999d17d1845b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga017678ad2851590ad3335371136f1730"><td class="memTemplParams" colspan="2">template&lt;class Blackbox , class DetMethod , class DomainCategory &gt; </td></tr>
<tr class="memitem:ga017678ad2851590ad3335371136f1730"><td class="memTemplItemLeft" align="right" valign="top">Blackbox::Field::Element &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__solutions.html#ga017678ad2851590ad3335371136f1730">det</a> (typename Blackbox::Field::Element &amp;d, const Blackbox &amp;A, const DomainCategory &amp;tag, const DetMethod &amp;Meth)</td></tr>
<tr class="memdesc:ga017678ad2851590ad3335371136f1730"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the determinant of A.  <a href="group__solutions.html#ga017678ad2851590ad3335371136f1730">More...</a><br /></td></tr>
<tr class="separator:ga017678ad2851590ad3335371136f1730"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae9cc01adf89ca79caaf864d908316d5d"><td class="memTemplParams" colspan="2">template&lt;class Field &gt; </td></tr>
<tr class="memitem:gae9cc01adf89ca79caaf864d908316d5d"><td class="memTemplItemLeft" align="right" valign="top">Field::Element &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__solutions.html#gae9cc01adf89ca79caaf864d908316d5d">detInPlace</a> (typename Field::Element &amp;d, <a class="el" href="class_lin_box_1_1_blas_matrix.html">BlasMatrix</a>&lt; Field &gt; &amp;A)</td></tr>
<tr class="memdesc:gae9cc01adf89ca79caaf864d908316d5d"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="namespace_lin_box_1_1_rank.html" title="Rank of the system, if known. ">Rank</a> of Blackbox <code>A</code>.  <a href="group__solutions.html#gae9cc01adf89ca79caaf864d908316d5d">More...</a><br /></td></tr>
<tr class="separator:gae9cc01adf89ca79caaf864d908316d5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12a1efe065e4ab3063078f4aac637d63"><td class="memTemplParams" colspan="2"><a id="a12a1efe065e4ab3063078f4aac637d63"></a>
template&lt;class Matrix , class CategoryTag &gt; </td></tr>
<tr class="memitem:a12a1efe065e4ab3063078f4aac637d63"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_lin_box.html#a12a1efe065e4ab3063078f4aac637d63">rowEchelon</a> (<a class="el" href="class_lin_box_1_1_blas_matrix.html">Matrix</a> &amp;E, const <a class="el" href="class_lin_box_1_1_blas_matrix.html">Matrix</a> &amp;A, const CategoryTag &amp;tag, const <a class="el" href="namespace_lin_box.html#a10235377a5d8fe76c611f71b195cb97ea06b9281e396db002010bde1de57262eb">Method::Auto</a> &amp;m)</td></tr>
<tr class="memdesc:a12a1efe065e4ab3063078f4aac637d63"><td class="mdescLeft">&#160;</td><td class="mdescRight">rowEchelon specialisation for Auto. <br /></td></tr>
<tr class="separator:a12a1efe065e4ab3063078f4aac637d63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b9323b68e2423506edd8430da11f3cd"><td class="memTemplParams" colspan="2"><a id="a6b9323b68e2423506edd8430da11f3cd"></a>
template&lt;class Field &gt; </td></tr>
<tr class="memitem:a6b9323b68e2423506edd8430da11f3cd"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_lin_box.html#a6b9323b68e2423506edd8430da11f3cd">rowEchelon</a> (<a class="el" href="class_lin_box_1_1_blas_matrix.html">DenseMatrix</a>&lt; Field &gt; &amp;E, const <a class="el" href="class_lin_box_1_1_blas_matrix.html">DenseMatrix</a>&lt; Field &gt; &amp;A, const <a class="el" href="struct_lin_box_1_1_ring_categories_1_1_modular_tag.html">RingCategories::ModularTag</a> &amp;tag, const <a class="el" href="namespace_lin_box.html#a10235377a5d8fe76c611f71b195cb97ea06b9281e396db002010bde1de57262eb">Method::Auto</a> &amp;m)</td></tr>
<tr class="memdesc:a6b9323b68e2423506edd8430da11f3cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">rowEchelon specialisation for Auto with DenseMatrix and ModularTag. <br /></td></tr>
<tr class="separator:a6b9323b68e2423506edd8430da11f3cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3872dcbe0bfc97cbeb582b949285739"><td class="memTemplParams" colspan="2"><a id="ab3872dcbe0bfc97cbeb582b949285739"></a>
template&lt;class Matrix , class CategoryTag &gt; </td></tr>
<tr class="memitem:ab3872dcbe0bfc97cbeb582b949285739"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_lin_box.html#ab3872dcbe0bfc97cbeb582b949285739">rowEchelon</a> (<a class="el" href="class_lin_box_1_1_blas_matrix.html">Matrix</a> &amp;E, <a class="el" href="class_lin_box_1_1_blas_matrix.html">Matrix</a> &amp;T, const <a class="el" href="class_lin_box_1_1_blas_matrix.html">Matrix</a> &amp;A, const CategoryTag &amp;tag, const <a class="el" href="namespace_lin_box.html#a10235377a5d8fe76c611f71b195cb97ea06b9281e396db002010bde1de57262eb">Method::Auto</a> &amp;m)</td></tr>
<tr class="memdesc:ab3872dcbe0bfc97cbeb582b949285739"><td class="mdescLeft">&#160;</td><td class="mdescRight">rowEchelon specialisation for Auto. <br /></td></tr>
<tr class="separator:ab3872dcbe0bfc97cbeb582b949285739"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0e7da6ff7c7508fb4e75f426af5d66e"><td class="memTemplParams" colspan="2"><a id="ae0e7da6ff7c7508fb4e75f426af5d66e"></a>
template&lt;class Field &gt; </td></tr>
<tr class="memitem:ae0e7da6ff7c7508fb4e75f426af5d66e"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_lin_box.html#ae0e7da6ff7c7508fb4e75f426af5d66e">rowEchelon</a> (<a class="el" href="class_lin_box_1_1_blas_matrix.html">DenseMatrix</a>&lt; Field &gt; &amp;E, <a class="el" href="class_lin_box_1_1_blas_matrix.html">DenseMatrix</a>&lt; Field &gt; &amp;T, const <a class="el" href="class_lin_box_1_1_blas_matrix.html">DenseMatrix</a>&lt; Field &gt; &amp;A, const <a class="el" href="struct_lin_box_1_1_ring_categories_1_1_modular_tag.html">RingCategories::ModularTag</a> &amp;tag, const <a class="el" href="namespace_lin_box.html#a10235377a5d8fe76c611f71b195cb97ea06b9281e396db002010bde1de57262eb">Method::Auto</a> &amp;m)</td></tr>
<tr class="memdesc:ae0e7da6ff7c7508fb4e75f426af5d66e"><td class="mdescLeft">&#160;</td><td class="mdescRight">rowEchelon specialisation for Auto with DenseMatrix and ModularTag. <br /></td></tr>
<tr class="separator:ae0e7da6ff7c7508fb4e75f426af5d66e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb9714fd11b6431325774d9c1ebe9ffe"><td class="memTemplParams" colspan="2"><a id="abb9714fd11b6431325774d9c1ebe9ffe"></a>
template&lt;class Matrix , class CategoryTag &gt; </td></tr>
<tr class="memitem:abb9714fd11b6431325774d9c1ebe9ffe"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_lin_box.html#abb9714fd11b6431325774d9c1ebe9ffe">rowEchelonize</a> (<a class="el" href="class_lin_box_1_1_blas_matrix.html">Matrix</a> &amp;A, const CategoryTag &amp;tag, const <a class="el" href="namespace_lin_box.html#a10235377a5d8fe76c611f71b195cb97ea06b9281e396db002010bde1de57262eb">Method::Auto</a> &amp;m)</td></tr>
<tr class="memdesc:abb9714fd11b6431325774d9c1ebe9ffe"><td class="mdescLeft">&#160;</td><td class="mdescRight">rowEchelonize specialisation for Auto. <br /></td></tr>
<tr class="separator:abb9714fd11b6431325774d9c1ebe9ffe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a290ae67486d2b6aab5d20d0abd612673"><td class="memTemplParams" colspan="2"><a id="a290ae67486d2b6aab5d20d0abd612673"></a>
template&lt;class Field &gt; </td></tr>
<tr class="memitem:a290ae67486d2b6aab5d20d0abd612673"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_lin_box.html#a290ae67486d2b6aab5d20d0abd612673">rowEchelonize</a> (<a class="el" href="class_lin_box_1_1_blas_matrix.html">DenseMatrix</a>&lt; Field &gt; &amp;A, const <a class="el" href="struct_lin_box_1_1_ring_categories_1_1_modular_tag.html">RingCategories::ModularTag</a> &amp;tag, const <a class="el" href="namespace_lin_box.html#a10235377a5d8fe76c611f71b195cb97ea06b9281e396db002010bde1de57262eb">Method::Auto</a> &amp;m)</td></tr>
<tr class="memdesc:a290ae67486d2b6aab5d20d0abd612673"><td class="mdescLeft">&#160;</td><td class="mdescRight">rowEchelonize specialisation for Auto with DenseMatrix and ModularTag. <br /></td></tr>
<tr class="separator:a290ae67486d2b6aab5d20d0abd612673"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92ed2e301742533a14d818a07db4e459"><td class="memTemplParams" colspan="2"><a id="a92ed2e301742533a14d818a07db4e459"></a>
template&lt;class Matrix , class CategoryTag &gt; </td></tr>
<tr class="memitem:a92ed2e301742533a14d818a07db4e459"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_lin_box.html#a92ed2e301742533a14d818a07db4e459">rowEchelonize</a> (<a class="el" href="class_lin_box_1_1_blas_matrix.html">Matrix</a> &amp;A, <a class="el" href="class_lin_box_1_1_blas_matrix.html">Matrix</a> &amp;T, const CategoryTag &amp;tag, const <a class="el" href="namespace_lin_box.html#a10235377a5d8fe76c611f71b195cb97ea06b9281e396db002010bde1de57262eb">Method::Auto</a> &amp;m)</td></tr>
<tr class="memdesc:a92ed2e301742533a14d818a07db4e459"><td class="mdescLeft">&#160;</td><td class="mdescRight">rowEchelonize specialisation for Auto. <br /></td></tr>
<tr class="separator:a92ed2e301742533a14d818a07db4e459"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a993950a31ec3dd265f9324fca1d06dc7"><td class="memTemplParams" colspan="2"><a id="a993950a31ec3dd265f9324fca1d06dc7"></a>
template&lt;class Field &gt; </td></tr>
<tr class="memitem:a993950a31ec3dd265f9324fca1d06dc7"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_lin_box.html#a993950a31ec3dd265f9324fca1d06dc7">rowEchelonize</a> (<a class="el" href="class_lin_box_1_1_blas_matrix.html">DenseMatrix</a>&lt; Field &gt; &amp;A, <a class="el" href="class_lin_box_1_1_blas_matrix.html">DenseMatrix</a>&lt; Field &gt; &amp;T, const <a class="el" href="struct_lin_box_1_1_ring_categories_1_1_modular_tag.html">RingCategories::ModularTag</a> &amp;tag, const <a class="el" href="namespace_lin_box.html#a10235377a5d8fe76c611f71b195cb97ea06b9281e396db002010bde1de57262eb">Method::Auto</a> &amp;m)</td></tr>
<tr class="memdesc:a993950a31ec3dd265f9324fca1d06dc7"><td class="mdescLeft">&#160;</td><td class="mdescRight">rowEchelonize specialisation for Auto with DenseMatrix and ModularTag. <br /></td></tr>
<tr class="separator:a993950a31ec3dd265f9324fca1d06dc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a438b584864f9f7e27de07f89e2544d22"><td class="memTemplParams" colspan="2"><a id="a438b584864f9f7e27de07f89e2544d22"></a>
template&lt;class Matrix , class CategoryTag &gt; </td></tr>
<tr class="memitem:a438b584864f9f7e27de07f89e2544d22"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_lin_box.html#a438b584864f9f7e27de07f89e2544d22">reducedRowEchelon</a> (<a class="el" href="class_lin_box_1_1_blas_matrix.html">Matrix</a> &amp;E, const <a class="el" href="class_lin_box_1_1_blas_matrix.html">Matrix</a> &amp;A, const CategoryTag &amp;tag, const <a class="el" href="namespace_lin_box.html#a10235377a5d8fe76c611f71b195cb97ea06b9281e396db002010bde1de57262eb">Method::Auto</a> &amp;m)</td></tr>
<tr class="memdesc:a438b584864f9f7e27de07f89e2544d22"><td class="mdescLeft">&#160;</td><td class="mdescRight">reducedRowEchelon specialisation for Auto. <br /></td></tr>
<tr class="separator:a438b584864f9f7e27de07f89e2544d22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa85ce50896270b1dfd2c2654ddad5551"><td class="memTemplParams" colspan="2"><a id="aa85ce50896270b1dfd2c2654ddad5551"></a>
template&lt;class Field &gt; </td></tr>
<tr class="memitem:aa85ce50896270b1dfd2c2654ddad5551"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_lin_box.html#aa85ce50896270b1dfd2c2654ddad5551">reducedRowEchelon</a> (<a class="el" href="class_lin_box_1_1_blas_matrix.html">DenseMatrix</a>&lt; Field &gt; &amp;E, const <a class="el" href="class_lin_box_1_1_blas_matrix.html">DenseMatrix</a>&lt; Field &gt; &amp;A, const <a class="el" href="struct_lin_box_1_1_ring_categories_1_1_modular_tag.html">RingCategories::ModularTag</a> &amp;tag, const <a class="el" href="namespace_lin_box.html#a10235377a5d8fe76c611f71b195cb97ea06b9281e396db002010bde1de57262eb">Method::Auto</a> &amp;m)</td></tr>
<tr class="memdesc:aa85ce50896270b1dfd2c2654ddad5551"><td class="mdescLeft">&#160;</td><td class="mdescRight">reducedRowEchelon specialisation for Auto with DenseMatrix and ModularTag. <br /></td></tr>
<tr class="separator:aa85ce50896270b1dfd2c2654ddad5551"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab499d48d51b9ae78c77ada7f44dcc5aa"><td class="memTemplParams" colspan="2"><a id="ab499d48d51b9ae78c77ada7f44dcc5aa"></a>
template&lt;class Matrix , class CategoryTag &gt; </td></tr>
<tr class="memitem:ab499d48d51b9ae78c77ada7f44dcc5aa"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_lin_box.html#ab499d48d51b9ae78c77ada7f44dcc5aa">reducedRowEchelon</a> (<a class="el" href="class_lin_box_1_1_blas_matrix.html">Matrix</a> &amp;E, <a class="el" href="class_lin_box_1_1_blas_matrix.html">Matrix</a> &amp;T, const <a class="el" href="class_lin_box_1_1_blas_matrix.html">Matrix</a> &amp;A, const CategoryTag &amp;tag, const <a class="el" href="namespace_lin_box.html#a10235377a5d8fe76c611f71b195cb97ea06b9281e396db002010bde1de57262eb">Method::Auto</a> &amp;m)</td></tr>
<tr class="memdesc:ab499d48d51b9ae78c77ada7f44dcc5aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">reducedRowEchelon specialisation for Auto. <br /></td></tr>
<tr class="separator:ab499d48d51b9ae78c77ada7f44dcc5aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9b5f1547e56779479dfa8de8e6d5996"><td class="memTemplParams" colspan="2"><a id="ab9b5f1547e56779479dfa8de8e6d5996"></a>
template&lt;class Field &gt; </td></tr>
<tr class="memitem:ab9b5f1547e56779479dfa8de8e6d5996"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_lin_box.html#ab9b5f1547e56779479dfa8de8e6d5996">reducedRowEchelon</a> (<a class="el" href="class_lin_box_1_1_blas_matrix.html">DenseMatrix</a>&lt; Field &gt; &amp;E, <a class="el" href="class_lin_box_1_1_blas_matrix.html">DenseMatrix</a>&lt; Field &gt; &amp;T, const <a class="el" href="class_lin_box_1_1_blas_matrix.html">DenseMatrix</a>&lt; Field &gt; &amp;A, const <a class="el" href="struct_lin_box_1_1_ring_categories_1_1_modular_tag.html">RingCategories::ModularTag</a> &amp;tag, const <a class="el" href="namespace_lin_box.html#a10235377a5d8fe76c611f71b195cb97ea06b9281e396db002010bde1de57262eb">Method::Auto</a> &amp;m)</td></tr>
<tr class="memdesc:ab9b5f1547e56779479dfa8de8e6d5996"><td class="mdescLeft">&#160;</td><td class="mdescRight">reducedRowEchelon specialisation for Auto with DenseMatrix and ModularTag. <br /></td></tr>
<tr class="separator:ab9b5f1547e56779479dfa8de8e6d5996"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91ce6bdb94eea813ac897aa2b02ee55c"><td class="memTemplParams" colspan="2"><a id="a91ce6bdb94eea813ac897aa2b02ee55c"></a>
template&lt;class Matrix , class CategoryTag &gt; </td></tr>
<tr class="memitem:a91ce6bdb94eea813ac897aa2b02ee55c"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_lin_box.html#a91ce6bdb94eea813ac897aa2b02ee55c">reducedRowEchelonize</a> (<a class="el" href="class_lin_box_1_1_blas_matrix.html">Matrix</a> &amp;A, const CategoryTag &amp;tag, const <a class="el" href="namespace_lin_box.html#a10235377a5d8fe76c611f71b195cb97ea06b9281e396db002010bde1de57262eb">Method::Auto</a> &amp;m)</td></tr>
<tr class="memdesc:a91ce6bdb94eea813ac897aa2b02ee55c"><td class="mdescLeft">&#160;</td><td class="mdescRight">reducedRowEchelonize specialisation for Auto. <br /></td></tr>
<tr class="separator:a91ce6bdb94eea813ac897aa2b02ee55c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45263faf31142ccaa8438e73987130d4"><td class="memTemplParams" colspan="2"><a id="a45263faf31142ccaa8438e73987130d4"></a>
template&lt;class Field &gt; </td></tr>
<tr class="memitem:a45263faf31142ccaa8438e73987130d4"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_lin_box.html#a45263faf31142ccaa8438e73987130d4">reducedRowEchelonize</a> (<a class="el" href="class_lin_box_1_1_blas_matrix.html">DenseMatrix</a>&lt; Field &gt; &amp;A, const <a class="el" href="struct_lin_box_1_1_ring_categories_1_1_modular_tag.html">RingCategories::ModularTag</a> &amp;tag, const <a class="el" href="namespace_lin_box.html#a10235377a5d8fe76c611f71b195cb97ea06b9281e396db002010bde1de57262eb">Method::Auto</a> &amp;m)</td></tr>
<tr class="memdesc:a45263faf31142ccaa8438e73987130d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">reducedRowEchelonize specialisation for Auto with DenseMatrix and ModularTag. <br /></td></tr>
<tr class="separator:a45263faf31142ccaa8438e73987130d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92aac7d4ff3c0a88bc2f1bb57de87e49"><td class="memTemplParams" colspan="2"><a id="a92aac7d4ff3c0a88bc2f1bb57de87e49"></a>
template&lt;class Matrix , class CategoryTag &gt; </td></tr>
<tr class="memitem:a92aac7d4ff3c0a88bc2f1bb57de87e49"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_lin_box.html#a92aac7d4ff3c0a88bc2f1bb57de87e49">reducedRowEchelonize</a> (<a class="el" href="class_lin_box_1_1_blas_matrix.html">Matrix</a> &amp;A, <a class="el" href="class_lin_box_1_1_blas_matrix.html">Matrix</a> &amp;T, const CategoryTag &amp;tag, const <a class="el" href="namespace_lin_box.html#a10235377a5d8fe76c611f71b195cb97ea06b9281e396db002010bde1de57262eb">Method::Auto</a> &amp;m)</td></tr>
<tr class="memdesc:a92aac7d4ff3c0a88bc2f1bb57de87e49"><td class="mdescLeft">&#160;</td><td class="mdescRight">reducedRowEchelonize specialisation for Auto. <br /></td></tr>
<tr class="separator:a92aac7d4ff3c0a88bc2f1bb57de87e49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46f04b484095408609cf0501b63ccb06"><td class="memTemplParams" colspan="2"><a id="a46f04b484095408609cf0501b63ccb06"></a>
template&lt;class Field &gt; </td></tr>
<tr class="memitem:a46f04b484095408609cf0501b63ccb06"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_lin_box.html#a46f04b484095408609cf0501b63ccb06">reducedRowEchelonize</a> (<a class="el" href="class_lin_box_1_1_blas_matrix.html">DenseMatrix</a>&lt; Field &gt; &amp;A, <a class="el" href="class_lin_box_1_1_blas_matrix.html">DenseMatrix</a>&lt; Field &gt; &amp;T, const <a class="el" href="struct_lin_box_1_1_ring_categories_1_1_modular_tag.html">RingCategories::ModularTag</a> &amp;tag, const <a class="el" href="namespace_lin_box.html#a10235377a5d8fe76c611f71b195cb97ea06b9281e396db002010bde1de57262eb">Method::Auto</a> &amp;m)</td></tr>
<tr class="memdesc:a46f04b484095408609cf0501b63ccb06"><td class="mdescLeft">&#160;</td><td class="mdescRight">reducedRowEchelonize specialisation for Auto with DenseMatrix and ModularTag. <br /></td></tr>
<tr class="separator:a46f04b484095408609cf0501b63ccb06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdf61d9785d059ad010045e6b5651e95"><td class="memTemplParams" colspan="2"><a id="afdf61d9785d059ad010045e6b5651e95"></a>
template&lt;class Matrix , class CategoryTag &gt; </td></tr>
<tr class="memitem:afdf61d9785d059ad010045e6b5651e95"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_lin_box.html#afdf61d9785d059ad010045e6b5651e95">colEchelon</a> (<a class="el" href="class_lin_box_1_1_blas_matrix.html">Matrix</a> &amp;E, const <a class="el" href="class_lin_box_1_1_blas_matrix.html">Matrix</a> &amp;A, const CategoryTag &amp;tag, const <a class="el" href="namespace_lin_box.html#a10235377a5d8fe76c611f71b195cb97ea06b9281e396db002010bde1de57262eb">Method::Auto</a> &amp;m)</td></tr>
<tr class="memdesc:afdf61d9785d059ad010045e6b5651e95"><td class="mdescLeft">&#160;</td><td class="mdescRight">colEchelon specialisation for Auto. <br /></td></tr>
<tr class="separator:afdf61d9785d059ad010045e6b5651e95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1e0a2929125d66808eb51ee252aeb5d"><td class="memTemplParams" colspan="2"><a id="ad1e0a2929125d66808eb51ee252aeb5d"></a>
template&lt;class Field &gt; </td></tr>
<tr class="memitem:ad1e0a2929125d66808eb51ee252aeb5d"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_lin_box.html#ad1e0a2929125d66808eb51ee252aeb5d">colEchelon</a> (<a class="el" href="class_lin_box_1_1_blas_matrix.html">DenseMatrix</a>&lt; Field &gt; &amp;E, const <a class="el" href="class_lin_box_1_1_blas_matrix.html">DenseMatrix</a>&lt; Field &gt; &amp;A, const <a class="el" href="struct_lin_box_1_1_ring_categories_1_1_modular_tag.html">RingCategories::ModularTag</a> &amp;tag, const <a class="el" href="namespace_lin_box.html#a10235377a5d8fe76c611f71b195cb97ea06b9281e396db002010bde1de57262eb">Method::Auto</a> &amp;m)</td></tr>
<tr class="memdesc:ad1e0a2929125d66808eb51ee252aeb5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">colEchelon specialisation for Auto with DenseMatrix and ModularTag. <br /></td></tr>
<tr class="separator:ad1e0a2929125d66808eb51ee252aeb5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40de4d070f1bd84d70b7a291b1540877"><td class="memTemplParams" colspan="2"><a id="a40de4d070f1bd84d70b7a291b1540877"></a>
template&lt;class Matrix , class CategoryTag &gt; </td></tr>
<tr class="memitem:a40de4d070f1bd84d70b7a291b1540877"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_lin_box.html#a40de4d070f1bd84d70b7a291b1540877">colEchelon</a> (<a class="el" href="class_lin_box_1_1_blas_matrix.html">Matrix</a> &amp;E, <a class="el" href="class_lin_box_1_1_blas_matrix.html">Matrix</a> &amp;T, const <a class="el" href="class_lin_box_1_1_blas_matrix.html">Matrix</a> &amp;A, const CategoryTag &amp;tag, const <a class="el" href="namespace_lin_box.html#a10235377a5d8fe76c611f71b195cb97ea06b9281e396db002010bde1de57262eb">Method::Auto</a> &amp;m)</td></tr>
<tr class="memdesc:a40de4d070f1bd84d70b7a291b1540877"><td class="mdescLeft">&#160;</td><td class="mdescRight">colEchelon specialisation for Auto. <br /></td></tr>
<tr class="separator:a40de4d070f1bd84d70b7a291b1540877"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a170307bff8e274d18a36e30b96fef007"><td class="memTemplParams" colspan="2"><a id="a170307bff8e274d18a36e30b96fef007"></a>
template&lt;class Field &gt; </td></tr>
<tr class="memitem:a170307bff8e274d18a36e30b96fef007"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_lin_box.html#a170307bff8e274d18a36e30b96fef007">colEchelon</a> (<a class="el" href="class_lin_box_1_1_blas_matrix.html">DenseMatrix</a>&lt; Field &gt; &amp;E, <a class="el" href="class_lin_box_1_1_blas_matrix.html">DenseMatrix</a>&lt; Field &gt; &amp;T, const <a class="el" href="class_lin_box_1_1_blas_matrix.html">DenseMatrix</a>&lt; Field &gt; &amp;A, const <a class="el" href="struct_lin_box_1_1_ring_categories_1_1_modular_tag.html">RingCategories::ModularTag</a> &amp;tag, const <a class="el" href="namespace_lin_box.html#a10235377a5d8fe76c611f71b195cb97ea06b9281e396db002010bde1de57262eb">Method::Auto</a> &amp;m)</td></tr>
<tr class="memdesc:a170307bff8e274d18a36e30b96fef007"><td class="mdescLeft">&#160;</td><td class="mdescRight">colEchelon specialisation for Auto with DenseMatrix and ModularTag. <br /></td></tr>
<tr class="separator:a170307bff8e274d18a36e30b96fef007"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f4bb169a3a0656db724cbaeddec4998"><td class="memTemplParams" colspan="2"><a id="a0f4bb169a3a0656db724cbaeddec4998"></a>
template&lt;class Matrix , class CategoryTag &gt; </td></tr>
<tr class="memitem:a0f4bb169a3a0656db724cbaeddec4998"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_lin_box.html#a0f4bb169a3a0656db724cbaeddec4998">colEchelonize</a> (<a class="el" href="class_lin_box_1_1_blas_matrix.html">Matrix</a> &amp;A, const CategoryTag &amp;tag, const <a class="el" href="namespace_lin_box.html#a10235377a5d8fe76c611f71b195cb97ea06b9281e396db002010bde1de57262eb">Method::Auto</a> &amp;m)</td></tr>
<tr class="memdesc:a0f4bb169a3a0656db724cbaeddec4998"><td class="mdescLeft">&#160;</td><td class="mdescRight">colEchelonize specialisation for Auto. <br /></td></tr>
<tr class="separator:a0f4bb169a3a0656db724cbaeddec4998"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08ad62cc5acd52126dc858e550b68976"><td class="memTemplParams" colspan="2"><a id="a08ad62cc5acd52126dc858e550b68976"></a>
template&lt;class Field &gt; </td></tr>
<tr class="memitem:a08ad62cc5acd52126dc858e550b68976"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_lin_box.html#a08ad62cc5acd52126dc858e550b68976">colEchelonize</a> (<a class="el" href="class_lin_box_1_1_blas_matrix.html">DenseMatrix</a>&lt; Field &gt; &amp;A, const <a class="el" href="struct_lin_box_1_1_ring_categories_1_1_modular_tag.html">RingCategories::ModularTag</a> &amp;tag, const <a class="el" href="namespace_lin_box.html#a10235377a5d8fe76c611f71b195cb97ea06b9281e396db002010bde1de57262eb">Method::Auto</a> &amp;m)</td></tr>
<tr class="memdesc:a08ad62cc5acd52126dc858e550b68976"><td class="mdescLeft">&#160;</td><td class="mdescRight">colEchelonize specialisation for Auto with DenseMatrix and ModularTag. <br /></td></tr>
<tr class="separator:a08ad62cc5acd52126dc858e550b68976"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4dcbb5cf6eeda6145d383851b5836724"><td class="memTemplParams" colspan="2"><a id="a4dcbb5cf6eeda6145d383851b5836724"></a>
template&lt;class Matrix , class CategoryTag &gt; </td></tr>
<tr class="memitem:a4dcbb5cf6eeda6145d383851b5836724"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_lin_box.html#a4dcbb5cf6eeda6145d383851b5836724">colEchelonize</a> (<a class="el" href="class_lin_box_1_1_blas_matrix.html">Matrix</a> &amp;A, <a class="el" href="class_lin_box_1_1_blas_matrix.html">Matrix</a> &amp;T, const CategoryTag &amp;tag, const <a class="el" href="namespace_lin_box.html#a10235377a5d8fe76c611f71b195cb97ea06b9281e396db002010bde1de57262eb">Method::Auto</a> &amp;m)</td></tr>
<tr class="memdesc:a4dcbb5cf6eeda6145d383851b5836724"><td class="mdescLeft">&#160;</td><td class="mdescRight">colEchelonize specialisation for Auto. <br /></td></tr>
<tr class="separator:a4dcbb5cf6eeda6145d383851b5836724"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d02263d8638fa5a304b2168e23a2224"><td class="memTemplParams" colspan="2"><a id="a1d02263d8638fa5a304b2168e23a2224"></a>
template&lt;class Field &gt; </td></tr>
<tr class="memitem:a1d02263d8638fa5a304b2168e23a2224"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_lin_box.html#a1d02263d8638fa5a304b2168e23a2224">colEchelonize</a> (<a class="el" href="class_lin_box_1_1_blas_matrix.html">DenseMatrix</a>&lt; Field &gt; &amp;A, <a class="el" href="class_lin_box_1_1_blas_matrix.html">DenseMatrix</a>&lt; Field &gt; &amp;T, const <a class="el" href="struct_lin_box_1_1_ring_categories_1_1_modular_tag.html">RingCategories::ModularTag</a> &amp;tag, const <a class="el" href="namespace_lin_box.html#a10235377a5d8fe76c611f71b195cb97ea06b9281e396db002010bde1de57262eb">Method::Auto</a> &amp;m)</td></tr>
<tr class="memdesc:a1d02263d8638fa5a304b2168e23a2224"><td class="mdescLeft">&#160;</td><td class="mdescRight">colEchelonize specialisation for Auto with DenseMatrix and ModularTag. <br /></td></tr>
<tr class="separator:a1d02263d8638fa5a304b2168e23a2224"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6aeac78ec0685a161927594de151c085"><td class="memTemplParams" colspan="2"><a id="a6aeac78ec0685a161927594de151c085"></a>
template&lt;class Matrix , class CategoryTag &gt; </td></tr>
<tr class="memitem:a6aeac78ec0685a161927594de151c085"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_lin_box.html#a6aeac78ec0685a161927594de151c085">reducedColEchelon</a> (<a class="el" href="class_lin_box_1_1_blas_matrix.html">Matrix</a> &amp;E, const <a class="el" href="class_lin_box_1_1_blas_matrix.html">Matrix</a> &amp;A, const CategoryTag &amp;tag, const <a class="el" href="namespace_lin_box.html#a10235377a5d8fe76c611f71b195cb97ea06b9281e396db002010bde1de57262eb">Method::Auto</a> &amp;m)</td></tr>
<tr class="memdesc:a6aeac78ec0685a161927594de151c085"><td class="mdescLeft">&#160;</td><td class="mdescRight">reducedColEchelon specialisation for Auto. <br /></td></tr>
<tr class="separator:a6aeac78ec0685a161927594de151c085"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2eee90ad7fab9d7347d2f2eb43d0954"><td class="memTemplParams" colspan="2"><a id="af2eee90ad7fab9d7347d2f2eb43d0954"></a>
template&lt;class Field &gt; </td></tr>
<tr class="memitem:af2eee90ad7fab9d7347d2f2eb43d0954"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_lin_box.html#af2eee90ad7fab9d7347d2f2eb43d0954">reducedColEchelon</a> (<a class="el" href="class_lin_box_1_1_blas_matrix.html">DenseMatrix</a>&lt; Field &gt; &amp;E, const <a class="el" href="class_lin_box_1_1_blas_matrix.html">DenseMatrix</a>&lt; Field &gt; &amp;A, const <a class="el" href="struct_lin_box_1_1_ring_categories_1_1_modular_tag.html">RingCategories::ModularTag</a> &amp;tag, const <a class="el" href="namespace_lin_box.html#a10235377a5d8fe76c611f71b195cb97ea06b9281e396db002010bde1de57262eb">Method::Auto</a> &amp;m)</td></tr>
<tr class="memdesc:af2eee90ad7fab9d7347d2f2eb43d0954"><td class="mdescLeft">&#160;</td><td class="mdescRight">reducedColEchelon specialisation for Auto with DenseMatrix and ModularTag. <br /></td></tr>
<tr class="separator:af2eee90ad7fab9d7347d2f2eb43d0954"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5c37bf9023779f00dc85d344efcacb6"><td class="memTemplParams" colspan="2"><a id="ad5c37bf9023779f00dc85d344efcacb6"></a>
template&lt;class Matrix , class CategoryTag &gt; </td></tr>
<tr class="memitem:ad5c37bf9023779f00dc85d344efcacb6"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_lin_box.html#ad5c37bf9023779f00dc85d344efcacb6">reducedColEchelon</a> (<a class="el" href="class_lin_box_1_1_blas_matrix.html">Matrix</a> &amp;E, <a class="el" href="class_lin_box_1_1_blas_matrix.html">Matrix</a> &amp;T, const <a class="el" href="class_lin_box_1_1_blas_matrix.html">Matrix</a> &amp;A, const CategoryTag &amp;tag, const <a class="el" href="namespace_lin_box.html#a10235377a5d8fe76c611f71b195cb97ea06b9281e396db002010bde1de57262eb">Method::Auto</a> &amp;m)</td></tr>
<tr class="memdesc:ad5c37bf9023779f00dc85d344efcacb6"><td class="mdescLeft">&#160;</td><td class="mdescRight">reducedColEchelon specialisation for Auto. <br /></td></tr>
<tr class="separator:ad5c37bf9023779f00dc85d344efcacb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa05c39a9963f28111edd4ed5ebf70bac"><td class="memTemplParams" colspan="2"><a id="aa05c39a9963f28111edd4ed5ebf70bac"></a>
template&lt;class Field &gt; </td></tr>
<tr class="memitem:aa05c39a9963f28111edd4ed5ebf70bac"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_lin_box.html#aa05c39a9963f28111edd4ed5ebf70bac">reducedColEchelon</a> (<a class="el" href="class_lin_box_1_1_blas_matrix.html">DenseMatrix</a>&lt; Field &gt; &amp;E, <a class="el" href="class_lin_box_1_1_blas_matrix.html">DenseMatrix</a>&lt; Field &gt; &amp;T, const <a class="el" href="class_lin_box_1_1_blas_matrix.html">DenseMatrix</a>&lt; Field &gt; &amp;A, const <a class="el" href="struct_lin_box_1_1_ring_categories_1_1_modular_tag.html">RingCategories::ModularTag</a> &amp;tag, const <a class="el" href="namespace_lin_box.html#a10235377a5d8fe76c611f71b195cb97ea06b9281e396db002010bde1de57262eb">Method::Auto</a> &amp;m)</td></tr>
<tr class="memdesc:aa05c39a9963f28111edd4ed5ebf70bac"><td class="mdescLeft">&#160;</td><td class="mdescRight">reducedColEchelon specialisation for Auto with DenseMatrix and ModularTag. <br /></td></tr>
<tr class="separator:aa05c39a9963f28111edd4ed5ebf70bac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3e885a88f21f7089eefba0f1ac9a697"><td class="memTemplParams" colspan="2"><a id="af3e885a88f21f7089eefba0f1ac9a697"></a>
template&lt;class Matrix , class CategoryTag &gt; </td></tr>
<tr class="memitem:af3e885a88f21f7089eefba0f1ac9a697"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_lin_box.html#af3e885a88f21f7089eefba0f1ac9a697">reducedColEchelonize</a> (<a class="el" href="class_lin_box_1_1_blas_matrix.html">Matrix</a> &amp;A, const CategoryTag &amp;tag, const <a class="el" href="namespace_lin_box.html#a10235377a5d8fe76c611f71b195cb97ea06b9281e396db002010bde1de57262eb">Method::Auto</a> &amp;m)</td></tr>
<tr class="memdesc:af3e885a88f21f7089eefba0f1ac9a697"><td class="mdescLeft">&#160;</td><td class="mdescRight">reducedColEchelonize specialisation for Auto. <br /></td></tr>
<tr class="separator:af3e885a88f21f7089eefba0f1ac9a697"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afea50ee1cc672e9c85c86cf40708958a"><td class="memTemplParams" colspan="2"><a id="afea50ee1cc672e9c85c86cf40708958a"></a>
template&lt;class Field &gt; </td></tr>
<tr class="memitem:afea50ee1cc672e9c85c86cf40708958a"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_lin_box.html#afea50ee1cc672e9c85c86cf40708958a">reducedColEchelonize</a> (<a class="el" href="class_lin_box_1_1_blas_matrix.html">DenseMatrix</a>&lt; Field &gt; &amp;A, const <a class="el" href="struct_lin_box_1_1_ring_categories_1_1_modular_tag.html">RingCategories::ModularTag</a> &amp;tag, const <a class="el" href="namespace_lin_box.html#a10235377a5d8fe76c611f71b195cb97ea06b9281e396db002010bde1de57262eb">Method::Auto</a> &amp;m)</td></tr>
<tr class="memdesc:afea50ee1cc672e9c85c86cf40708958a"><td class="mdescLeft">&#160;</td><td class="mdescRight">reducedColEchelonize specialisation for Auto with DenseMatrix and ModularTag. <br /></td></tr>
<tr class="separator:afea50ee1cc672e9c85c86cf40708958a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e48e2247b4588868a63ee8caae3308e"><td class="memTemplParams" colspan="2"><a id="a7e48e2247b4588868a63ee8caae3308e"></a>
template&lt;class Matrix , class CategoryTag &gt; </td></tr>
<tr class="memitem:a7e48e2247b4588868a63ee8caae3308e"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_lin_box.html#a7e48e2247b4588868a63ee8caae3308e">reducedColEchelonize</a> (<a class="el" href="class_lin_box_1_1_blas_matrix.html">Matrix</a> &amp;A, <a class="el" href="class_lin_box_1_1_blas_matrix.html">Matrix</a> &amp;T, const CategoryTag &amp;tag, const <a class="el" href="namespace_lin_box.html#a10235377a5d8fe76c611f71b195cb97ea06b9281e396db002010bde1de57262eb">Method::Auto</a> &amp;m)</td></tr>
<tr class="memdesc:a7e48e2247b4588868a63ee8caae3308e"><td class="mdescLeft">&#160;</td><td class="mdescRight">reducedColEchelonize specialisation for Auto. <br /></td></tr>
<tr class="separator:a7e48e2247b4588868a63ee8caae3308e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a8388ea1db91b2b75b82d6c87961305"><td class="memTemplParams" colspan="2"><a id="a5a8388ea1db91b2b75b82d6c87961305"></a>
template&lt;class Field &gt; </td></tr>
<tr class="memitem:a5a8388ea1db91b2b75b82d6c87961305"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_lin_box.html#a5a8388ea1db91b2b75b82d6c87961305">reducedColEchelonize</a> (<a class="el" href="class_lin_box_1_1_blas_matrix.html">DenseMatrix</a>&lt; Field &gt; &amp;A, <a class="el" href="class_lin_box_1_1_blas_matrix.html">DenseMatrix</a>&lt; Field &gt; &amp;T, const <a class="el" href="struct_lin_box_1_1_ring_categories_1_1_modular_tag.html">RingCategories::ModularTag</a> &amp;tag, const <a class="el" href="namespace_lin_box.html#a10235377a5d8fe76c611f71b195cb97ea06b9281e396db002010bde1de57262eb">Method::Auto</a> &amp;m)</td></tr>
<tr class="memdesc:a5a8388ea1db91b2b75b82d6c87961305"><td class="mdescLeft">&#160;</td><td class="mdescRight">reducedColEchelonize specialisation for Auto with DenseMatrix and ModularTag. <br /></td></tr>
<tr class="separator:a5a8388ea1db91b2b75b82d6c87961305"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7def5b32cea1fc616c4f6a0e09e4a3d5"><td class="memTemplParams" colspan="2"><a id="a7def5b32cea1fc616c4f6a0e09e4a3d5"></a>
template&lt;class Field &gt; </td></tr>
<tr class="memitem:a7def5b32cea1fc616c4f6a0e09e4a3d5"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_lin_box.html#a7def5b32cea1fc616c4f6a0e09e4a3d5">rowEchelon</a> (<a class="el" href="class_lin_box_1_1_blas_matrix.html">DenseMatrix</a>&lt; Field &gt; &amp;E, const <a class="el" href="class_lin_box_1_1_blas_matrix.html">DenseMatrix</a>&lt; Field &gt; &amp;A, const <a class="el" href="struct_lin_box_1_1_ring_categories_1_1_modular_tag.html">RingCategories::ModularTag</a> &amp;tag, const Method::DenseElimination &amp;M)</td></tr>
<tr class="memdesc:a7def5b32cea1fc616c4f6a0e09e4a3d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">rowEchelon specialisation for DenseElimination with DenseMatrix and ModularTag. <br /></td></tr>
<tr class="separator:a7def5b32cea1fc616c4f6a0e09e4a3d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48f5cfc6f4d656f7a3800a1793bb32ff"><td class="memTemplParams" colspan="2"><a id="a48f5cfc6f4d656f7a3800a1793bb32ff"></a>
template&lt;class Field &gt; </td></tr>
<tr class="memitem:a48f5cfc6f4d656f7a3800a1793bb32ff"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_lin_box.html#a48f5cfc6f4d656f7a3800a1793bb32ff">rowEchelon</a> (<a class="el" href="class_lin_box_1_1_blas_matrix.html">DenseMatrix</a>&lt; Field &gt; &amp;E, <a class="el" href="class_lin_box_1_1_blas_matrix.html">DenseMatrix</a>&lt; Field &gt; &amp;T, const <a class="el" href="class_lin_box_1_1_blas_matrix.html">DenseMatrix</a>&lt; Field &gt; &amp;A, const <a class="el" href="struct_lin_box_1_1_ring_categories_1_1_modular_tag.html">RingCategories::ModularTag</a> &amp;tag, const Method::DenseElimination &amp;M)</td></tr>
<tr class="memdesc:a48f5cfc6f4d656f7a3800a1793bb32ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">rowEchelon with transformation specialisation for DenseElimination with DenseMatrix and ModularTag. <br /></td></tr>
<tr class="separator:a48f5cfc6f4d656f7a3800a1793bb32ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00290250606dc7ef74f23155ba4a81a3"><td class="memTemplParams" colspan="2"><a id="a00290250606dc7ef74f23155ba4a81a3"></a>
template&lt;class Field &gt; </td></tr>
<tr class="memitem:a00290250606dc7ef74f23155ba4a81a3"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_lin_box.html#a00290250606dc7ef74f23155ba4a81a3">rowEchelonize</a> (<a class="el" href="class_lin_box_1_1_blas_matrix.html">DenseMatrix</a>&lt; Field &gt; &amp;A, const <a class="el" href="struct_lin_box_1_1_ring_categories_1_1_modular_tag.html">RingCategories::ModularTag</a> &amp;tag, const Method::DenseElimination &amp;M)</td></tr>
<tr class="memdesc:a00290250606dc7ef74f23155ba4a81a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">rowEchelonize specialisation for DenseElimination with DenseMatrix and ModularTag. <br /></td></tr>
<tr class="separator:a00290250606dc7ef74f23155ba4a81a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2d09a58c86d029d8b282774c1d06bbc"><td class="memTemplParams" colspan="2"><a id="ae2d09a58c86d029d8b282774c1d06bbc"></a>
template&lt;class Field &gt; </td></tr>
<tr class="memitem:ae2d09a58c86d029d8b282774c1d06bbc"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_lin_box.html#ae2d09a58c86d029d8b282774c1d06bbc">rowEchelonize</a> (<a class="el" href="class_lin_box_1_1_blas_matrix.html">DenseMatrix</a>&lt; Field &gt; &amp;A, <a class="el" href="class_lin_box_1_1_blas_matrix.html">DenseMatrix</a>&lt; Field &gt; &amp;T, const <a class="el" href="struct_lin_box_1_1_ring_categories_1_1_modular_tag.html">RingCategories::ModularTag</a> &amp;tag, const Method::DenseElimination &amp;M)</td></tr>
<tr class="memdesc:ae2d09a58c86d029d8b282774c1d06bbc"><td class="mdescLeft">&#160;</td><td class="mdescRight">rowEchelonize with transformation specialisation for DenseElimination with DenseMatrix and ModularTag. <br /></td></tr>
<tr class="separator:ae2d09a58c86d029d8b282774c1d06bbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abde0cf96c106aae5c27f9d6c9a1deaca"><td class="memTemplParams" colspan="2"><a id="abde0cf96c106aae5c27f9d6c9a1deaca"></a>
template&lt;class Field &gt; </td></tr>
<tr class="memitem:abde0cf96c106aae5c27f9d6c9a1deaca"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_lin_box.html#abde0cf96c106aae5c27f9d6c9a1deaca">reducedRowEchelon</a> (<a class="el" href="class_lin_box_1_1_blas_matrix.html">DenseMatrix</a>&lt; Field &gt; &amp;E, const <a class="el" href="class_lin_box_1_1_blas_matrix.html">DenseMatrix</a>&lt; Field &gt; &amp;A, const <a class="el" href="struct_lin_box_1_1_ring_categories_1_1_modular_tag.html">RingCategories::ModularTag</a> &amp;tag, const Method::DenseElimination &amp;M)</td></tr>
<tr class="memdesc:abde0cf96c106aae5c27f9d6c9a1deaca"><td class="mdescLeft">&#160;</td><td class="mdescRight">reducedRowEchelon specialisation for DenseElimination with DenseMatrix and ModularTag. <br /></td></tr>
<tr class="separator:abde0cf96c106aae5c27f9d6c9a1deaca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aada7b6d69b3da7ec568364f806ce5e3f"><td class="memTemplParams" colspan="2"><a id="aada7b6d69b3da7ec568364f806ce5e3f"></a>
template&lt;class Field &gt; </td></tr>
<tr class="memitem:aada7b6d69b3da7ec568364f806ce5e3f"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_lin_box.html#aada7b6d69b3da7ec568364f806ce5e3f">reducedRowEchelon</a> (<a class="el" href="class_lin_box_1_1_blas_matrix.html">DenseMatrix</a>&lt; Field &gt; &amp;E, <a class="el" href="class_lin_box_1_1_blas_matrix.html">DenseMatrix</a>&lt; Field &gt; &amp;T, const <a class="el" href="class_lin_box_1_1_blas_matrix.html">DenseMatrix</a>&lt; Field &gt; &amp;A, const <a class="el" href="struct_lin_box_1_1_ring_categories_1_1_modular_tag.html">RingCategories::ModularTag</a> &amp;tag, const Method::DenseElimination &amp;M)</td></tr>
<tr class="memdesc:aada7b6d69b3da7ec568364f806ce5e3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">reducedRowEchelon with transformation specialisation for DenseElimination with DenseMatrix and ModularTag. <br /></td></tr>
<tr class="separator:aada7b6d69b3da7ec568364f806ce5e3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a332ed1585d4add14bfe98a58a5326267"><td class="memTemplParams" colspan="2"><a id="a332ed1585d4add14bfe98a58a5326267"></a>
template&lt;class Field &gt; </td></tr>
<tr class="memitem:a332ed1585d4add14bfe98a58a5326267"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_lin_box.html#a332ed1585d4add14bfe98a58a5326267">reducedRowEchelonize</a> (<a class="el" href="class_lin_box_1_1_blas_matrix.html">DenseMatrix</a>&lt; Field &gt; &amp;A, const <a class="el" href="struct_lin_box_1_1_ring_categories_1_1_modular_tag.html">RingCategories::ModularTag</a> &amp;tag, const Method::DenseElimination &amp;M)</td></tr>
<tr class="memdesc:a332ed1585d4add14bfe98a58a5326267"><td class="mdescLeft">&#160;</td><td class="mdescRight">reducedRowEchelonize specialisation for DenseElimination with DenseMatrix and ModularTag. <br /></td></tr>
<tr class="separator:a332ed1585d4add14bfe98a58a5326267"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad98f4618a5cb0c9efa43828f641c71cd"><td class="memTemplParams" colspan="2"><a id="ad98f4618a5cb0c9efa43828f641c71cd"></a>
template&lt;class Field &gt; </td></tr>
<tr class="memitem:ad98f4618a5cb0c9efa43828f641c71cd"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_lin_box.html#ad98f4618a5cb0c9efa43828f641c71cd">reducedRowEchelonize</a> (<a class="el" href="class_lin_box_1_1_blas_matrix.html">DenseMatrix</a>&lt; Field &gt; &amp;A, <a class="el" href="class_lin_box_1_1_blas_matrix.html">DenseMatrix</a>&lt; Field &gt; &amp;T, const <a class="el" href="struct_lin_box_1_1_ring_categories_1_1_modular_tag.html">RingCategories::ModularTag</a> &amp;tag, const Method::DenseElimination &amp;M)</td></tr>
<tr class="memdesc:ad98f4618a5cb0c9efa43828f641c71cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">reducedRowEchelonize with transformation specialisation for DenseElimination with DenseMatrix and ModularTag. <br /></td></tr>
<tr class="separator:ad98f4618a5cb0c9efa43828f641c71cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2364e9cdfb78c2910c0dacf55f9dbc1"><td class="memTemplParams" colspan="2"><a id="ad2364e9cdfb78c2910c0dacf55f9dbc1"></a>
template&lt;class Field &gt; </td></tr>
<tr class="memitem:ad2364e9cdfb78c2910c0dacf55f9dbc1"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_lin_box.html#ad2364e9cdfb78c2910c0dacf55f9dbc1">colEchelon</a> (<a class="el" href="class_lin_box_1_1_blas_matrix.html">DenseMatrix</a>&lt; Field &gt; &amp;E, const <a class="el" href="class_lin_box_1_1_blas_matrix.html">DenseMatrix</a>&lt; Field &gt; &amp;A, const <a class="el" href="struct_lin_box_1_1_ring_categories_1_1_modular_tag.html">RingCategories::ModularTag</a> &amp;tag, const Method::DenseElimination &amp;M)</td></tr>
<tr class="memdesc:ad2364e9cdfb78c2910c0dacf55f9dbc1"><td class="mdescLeft">&#160;</td><td class="mdescRight">colEchelon specialisation for DenseElimination with DenseMatrix and ModularTag. <br /></td></tr>
<tr class="separator:ad2364e9cdfb78c2910c0dacf55f9dbc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98c0308c8de9f54ae8d1f5aa7b8018b6"><td class="memTemplParams" colspan="2"><a id="a98c0308c8de9f54ae8d1f5aa7b8018b6"></a>
template&lt;class Field &gt; </td></tr>
<tr class="memitem:a98c0308c8de9f54ae8d1f5aa7b8018b6"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_lin_box.html#a98c0308c8de9f54ae8d1f5aa7b8018b6">colEchelon</a> (<a class="el" href="class_lin_box_1_1_blas_matrix.html">DenseMatrix</a>&lt; Field &gt; &amp;E, <a class="el" href="class_lin_box_1_1_blas_matrix.html">DenseMatrix</a>&lt; Field &gt; &amp;T, const <a class="el" href="class_lin_box_1_1_blas_matrix.html">DenseMatrix</a>&lt; Field &gt; &amp;A, const <a class="el" href="struct_lin_box_1_1_ring_categories_1_1_modular_tag.html">RingCategories::ModularTag</a> &amp;tag, const Method::DenseElimination &amp;M)</td></tr>
<tr class="memdesc:a98c0308c8de9f54ae8d1f5aa7b8018b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">colEchelon with transformation specialisation for DenseElimination with DenseMatrix and ModularTag. <br /></td></tr>
<tr class="separator:a98c0308c8de9f54ae8d1f5aa7b8018b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7451b830bfa3717dd06f02d3fbd3774"><td class="memTemplParams" colspan="2"><a id="aa7451b830bfa3717dd06f02d3fbd3774"></a>
template&lt;class Field &gt; </td></tr>
<tr class="memitem:aa7451b830bfa3717dd06f02d3fbd3774"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_lin_box.html#aa7451b830bfa3717dd06f02d3fbd3774">colEchelonize</a> (<a class="el" href="class_lin_box_1_1_blas_matrix.html">DenseMatrix</a>&lt; Field &gt; &amp;A, const <a class="el" href="struct_lin_box_1_1_ring_categories_1_1_modular_tag.html">RingCategories::ModularTag</a> &amp;tag, const Method::DenseElimination &amp;M)</td></tr>
<tr class="memdesc:aa7451b830bfa3717dd06f02d3fbd3774"><td class="mdescLeft">&#160;</td><td class="mdescRight">colEchelonize specialisation for DenseElimination with DenseMatrix and ModularTag. <br /></td></tr>
<tr class="separator:aa7451b830bfa3717dd06f02d3fbd3774"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5d2ca5c74c511b90081e5008d9a1a96"><td class="memTemplParams" colspan="2"><a id="aa5d2ca5c74c511b90081e5008d9a1a96"></a>
template&lt;class Field &gt; </td></tr>
<tr class="memitem:aa5d2ca5c74c511b90081e5008d9a1a96"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_lin_box.html#aa5d2ca5c74c511b90081e5008d9a1a96">colEchelonize</a> (<a class="el" href="class_lin_box_1_1_blas_matrix.html">DenseMatrix</a>&lt; Field &gt; &amp;A, <a class="el" href="class_lin_box_1_1_blas_matrix.html">DenseMatrix</a>&lt; Field &gt; &amp;T, const <a class="el" href="struct_lin_box_1_1_ring_categories_1_1_modular_tag.html">RingCategories::ModularTag</a> &amp;tag, const Method::DenseElimination &amp;M)</td></tr>
<tr class="memdesc:aa5d2ca5c74c511b90081e5008d9a1a96"><td class="mdescLeft">&#160;</td><td class="mdescRight">colEchelonize with transformation specialisation for DenseElimination with DenseMatrix and ModularTag. <br /></td></tr>
<tr class="separator:aa5d2ca5c74c511b90081e5008d9a1a96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37acbc75630fb8eaae74dff66a358d38"><td class="memTemplParams" colspan="2"><a id="a37acbc75630fb8eaae74dff66a358d38"></a>
template&lt;class Field &gt; </td></tr>
<tr class="memitem:a37acbc75630fb8eaae74dff66a358d38"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_lin_box.html#a37acbc75630fb8eaae74dff66a358d38">reducedColEchelon</a> (<a class="el" href="class_lin_box_1_1_blas_matrix.html">DenseMatrix</a>&lt; Field &gt; &amp;E, const <a class="el" href="class_lin_box_1_1_blas_matrix.html">DenseMatrix</a>&lt; Field &gt; &amp;A, const <a class="el" href="struct_lin_box_1_1_ring_categories_1_1_modular_tag.html">RingCategories::ModularTag</a> &amp;tag, const Method::DenseElimination &amp;M)</td></tr>
<tr class="memdesc:a37acbc75630fb8eaae74dff66a358d38"><td class="mdescLeft">&#160;</td><td class="mdescRight">reducedColEchelon specialisation for DenseElimination with DenseMatrix and ModularTag. <br /></td></tr>
<tr class="separator:a37acbc75630fb8eaae74dff66a358d38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad717916a79c096ae552643322b5d00f9"><td class="memTemplParams" colspan="2"><a id="ad717916a79c096ae552643322b5d00f9"></a>
template&lt;class Field &gt; </td></tr>
<tr class="memitem:ad717916a79c096ae552643322b5d00f9"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_lin_box.html#ad717916a79c096ae552643322b5d00f9">reducedColEchelon</a> (<a class="el" href="class_lin_box_1_1_blas_matrix.html">DenseMatrix</a>&lt; Field &gt; &amp;E, <a class="el" href="class_lin_box_1_1_blas_matrix.html">DenseMatrix</a>&lt; Field &gt; &amp;T, const <a class="el" href="class_lin_box_1_1_blas_matrix.html">DenseMatrix</a>&lt; Field &gt; &amp;A, const <a class="el" href="struct_lin_box_1_1_ring_categories_1_1_modular_tag.html">RingCategories::ModularTag</a> &amp;tag, const Method::DenseElimination &amp;M)</td></tr>
<tr class="memdesc:ad717916a79c096ae552643322b5d00f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">reducedColEchelon with transformation specialisation for DenseElimination with DenseMatrix and ModularTag. <br /></td></tr>
<tr class="separator:ad717916a79c096ae552643322b5d00f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a363775474aba97547408089df8cad595"><td class="memTemplParams" colspan="2"><a id="a363775474aba97547408089df8cad595"></a>
template&lt;class Field &gt; </td></tr>
<tr class="memitem:a363775474aba97547408089df8cad595"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_lin_box.html#a363775474aba97547408089df8cad595">reducedColEchelonize</a> (<a class="el" href="class_lin_box_1_1_blas_matrix.html">DenseMatrix</a>&lt; Field &gt; &amp;A, const <a class="el" href="struct_lin_box_1_1_ring_categories_1_1_modular_tag.html">RingCategories::ModularTag</a> &amp;tag, const Method::DenseElimination &amp;M)</td></tr>
<tr class="memdesc:a363775474aba97547408089df8cad595"><td class="mdescLeft">&#160;</td><td class="mdescRight">reducedColEchelonize specialisation for DenseElimination with DenseMatrix and ModularTag. <br /></td></tr>
<tr class="separator:a363775474aba97547408089df8cad595"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07b9d9be78d32fc6cbd989cddbba584a"><td class="memTemplParams" colspan="2"><a id="a07b9d9be78d32fc6cbd989cddbba584a"></a>
template&lt;class Field &gt; </td></tr>
<tr class="memitem:a07b9d9be78d32fc6cbd989cddbba584a"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_lin_box.html#a07b9d9be78d32fc6cbd989cddbba584a">reducedColEchelonize</a> (<a class="el" href="class_lin_box_1_1_blas_matrix.html">DenseMatrix</a>&lt; Field &gt; &amp;A, <a class="el" href="class_lin_box_1_1_blas_matrix.html">DenseMatrix</a>&lt; Field &gt; &amp;T, const <a class="el" href="struct_lin_box_1_1_ring_categories_1_1_modular_tag.html">RingCategories::ModularTag</a> &amp;tag, const Method::DenseElimination &amp;M)</td></tr>
<tr class="memdesc:a07b9d9be78d32fc6cbd989cddbba584a"><td class="mdescLeft">&#160;</td><td class="mdescRight">reducedColEchelonize with transformation specialisation for DenseElimination with DenseMatrix and ModularTag. <br /></td></tr>
<tr class="separator:a07b9d9be78d32fc6cbd989cddbba584a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdad6b9b36b03567629621cf8ab8df14"><td class="memTemplParams" colspan="2">template&lt;class Matrix , class CategoryTag , class EchelonMethod &gt; </td></tr>
<tr class="memitem:acdad6b9b36b03567629621cf8ab8df14"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_lin_box.html#acdad6b9b36b03567629621cf8ab8df14">rowEchelon</a> (<a class="el" href="class_lin_box_1_1_blas_matrix.html">Matrix</a> &amp;E, const <a class="el" href="class_lin_box_1_1_blas_matrix.html">Matrix</a> &amp;A, const CategoryTag &amp;tag, const EchelonMethod &amp;m)</td></tr>
<tr class="memdesc:acdad6b9b36b03567629621cf8ab8df14"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the row echelon form of a matrix, not reduced.  <a href="#acdad6b9b36b03567629621cf8ab8df14">More...</a><br /></td></tr>
<tr class="separator:acdad6b9b36b03567629621cf8ab8df14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a315583c8889c22f5604942feff5d1733"><td class="memTemplParams" colspan="2"><a id="a315583c8889c22f5604942feff5d1733"></a>
template&lt;class Matrix , class EchelonMethod &gt; </td></tr>
<tr class="memitem:a315583c8889c22f5604942feff5d1733"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_lin_box.html#a315583c8889c22f5604942feff5d1733">rowEchelon</a> (<a class="el" href="class_lin_box_1_1_blas_matrix.html">Matrix</a> &amp;E, const <a class="el" href="class_lin_box_1_1_blas_matrix.html">Matrix</a> &amp;A, const EchelonMethod &amp;m)</td></tr>
<tr class="memdesc:a315583c8889c22f5604942feff5d1733"><td class="mdescLeft">&#160;</td><td class="mdescRight">rowEchelon dispatcher for automated category tag. <br /></td></tr>
<tr class="separator:a315583c8889c22f5604942feff5d1733"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdfed4234a0cce6cea9b82b030a3a93c"><td class="memTemplParams" colspan="2"><a id="abdfed4234a0cce6cea9b82b030a3a93c"></a>
template&lt;class Matrix &gt; </td></tr>
<tr class="memitem:abdfed4234a0cce6cea9b82b030a3a93c"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_lin_box.html#abdfed4234a0cce6cea9b82b030a3a93c">rowEchelon</a> (<a class="el" href="class_lin_box_1_1_blas_matrix.html">Matrix</a> &amp;E, const <a class="el" href="class_lin_box_1_1_blas_matrix.html">Matrix</a> &amp;A)</td></tr>
<tr class="memdesc:abdfed4234a0cce6cea9b82b030a3a93c"><td class="mdescLeft">&#160;</td><td class="mdescRight">rowEchelon dispatcher for automated method. <br /></td></tr>
<tr class="separator:abdfed4234a0cce6cea9b82b030a3a93c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8505c023af741d49d22daea8642987a3"><td class="memTemplParams" colspan="2">template&lt;class Matrix , class CategoryTag , class EchelonMethod &gt; </td></tr>
<tr class="memitem:a8505c023af741d49d22daea8642987a3"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_lin_box.html#a8505c023af741d49d22daea8642987a3">rowEchelon</a> (<a class="el" href="class_lin_box_1_1_blas_matrix.html">Matrix</a> &amp;E, <a class="el" href="class_lin_box_1_1_blas_matrix.html">Matrix</a> &amp;T, const <a class="el" href="class_lin_box_1_1_blas_matrix.html">Matrix</a> &amp;A, const CategoryTag &amp;tag, const EchelonMethod &amp;m)</td></tr>
<tr class="memdesc:a8505c023af741d49d22daea8642987a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the row echelon form of a matrix, not reduced, and the related transformation matrix.  <a href="#a8505c023af741d49d22daea8642987a3">More...</a><br /></td></tr>
<tr class="separator:a8505c023af741d49d22daea8642987a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafc874bb0a9025f3b961f2a8abfb34be"><td class="memTemplParams" colspan="2"><a id="aafc874bb0a9025f3b961f2a8abfb34be"></a>
template&lt;class Matrix , class EchelonMethod &gt; </td></tr>
<tr class="memitem:aafc874bb0a9025f3b961f2a8abfb34be"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_lin_box.html#aafc874bb0a9025f3b961f2a8abfb34be">rowEchelon</a> (<a class="el" href="class_lin_box_1_1_blas_matrix.html">Matrix</a> &amp;E, <a class="el" href="class_lin_box_1_1_blas_matrix.html">Matrix</a> &amp;T, const <a class="el" href="class_lin_box_1_1_blas_matrix.html">Matrix</a> &amp;A, const EchelonMethod &amp;m)</td></tr>
<tr class="memdesc:aafc874bb0a9025f3b961f2a8abfb34be"><td class="mdescLeft">&#160;</td><td class="mdescRight">rowEchelon dispatcher for automated category tag. <br /></td></tr>
<tr class="separator:aafc874bb0a9025f3b961f2a8abfb34be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa42e6b5eb07e55be1e88b7ee60fb7162"><td class="memTemplParams" colspan="2"><a id="aa42e6b5eb07e55be1e88b7ee60fb7162"></a>
template&lt;class Matrix &gt; </td></tr>
<tr class="memitem:aa42e6b5eb07e55be1e88b7ee60fb7162"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_lin_box.html#aa42e6b5eb07e55be1e88b7ee60fb7162">rowEchelon</a> (<a class="el" href="class_lin_box_1_1_blas_matrix.html">Matrix</a> &amp;E, <a class="el" href="class_lin_box_1_1_blas_matrix.html">Matrix</a> &amp;T, const <a class="el" href="class_lin_box_1_1_blas_matrix.html">Matrix</a> &amp;A)</td></tr>
<tr class="memdesc:aa42e6b5eb07e55be1e88b7ee60fb7162"><td class="mdescLeft">&#160;</td><td class="mdescRight">rowEchelon dispatcher for automated method. <br /></td></tr>
<tr class="separator:aa42e6b5eb07e55be1e88b7ee60fb7162"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7dae23c53eb662bed52e2560e1568e7c"><td class="memTemplParams" colspan="2">template&lt;class Matrix , class CategoryTag , class EchelonMethod &gt; </td></tr>
<tr class="memitem:a7dae23c53eb662bed52e2560e1568e7c"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_lin_box.html#a7dae23c53eb662bed52e2560e1568e7c">rowEchelonize</a> (<a class="el" href="class_lin_box_1_1_blas_matrix.html">Matrix</a> &amp;A, const CategoryTag &amp;tag, const EchelonMethod &amp;m)</td></tr>
<tr class="memdesc:a7dae23c53eb662bed52e2560e1568e7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace the input matrix by its row echelon form, not reduced.  <a href="#a7dae23c53eb662bed52e2560e1568e7c">More...</a><br /></td></tr>
<tr class="separator:a7dae23c53eb662bed52e2560e1568e7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf103d531248d973f448929715666c24"><td class="memTemplParams" colspan="2"><a id="acf103d531248d973f448929715666c24"></a>
template&lt;class Matrix , class EchelonMethod &gt; </td></tr>
<tr class="memitem:acf103d531248d973f448929715666c24"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_lin_box.html#acf103d531248d973f448929715666c24">rowEchelonize</a> (<a class="el" href="class_lin_box_1_1_blas_matrix.html">Matrix</a> &amp;A, const EchelonMethod &amp;m)</td></tr>
<tr class="memdesc:acf103d531248d973f448929715666c24"><td class="mdescLeft">&#160;</td><td class="mdescRight">rowEchelonize dispatcher for automated category tag. <br /></td></tr>
<tr class="separator:acf103d531248d973f448929715666c24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ab6a6227250c1f20b8245b4b31fc6c7"><td class="memTemplParams" colspan="2"><a id="a7ab6a6227250c1f20b8245b4b31fc6c7"></a>
template&lt;class Matrix &gt; </td></tr>
<tr class="memitem:a7ab6a6227250c1f20b8245b4b31fc6c7"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_lin_box.html#a7ab6a6227250c1f20b8245b4b31fc6c7">rowEchelonize</a> (<a class="el" href="class_lin_box_1_1_blas_matrix.html">Matrix</a> &amp;A)</td></tr>
<tr class="memdesc:a7ab6a6227250c1f20b8245b4b31fc6c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">rowEchelonize dispatcher for automated method. <br /></td></tr>
<tr class="separator:a7ab6a6227250c1f20b8245b4b31fc6c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16eb70498b2f34f8bb4ded0e1172bfa5"><td class="memTemplParams" colspan="2">template&lt;class Matrix , class CategoryTag , class EchelonMethod &gt; </td></tr>
<tr class="memitem:a16eb70498b2f34f8bb4ded0e1172bfa5"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_lin_box.html#a16eb70498b2f34f8bb4ded0e1172bfa5">rowEchelonize</a> (<a class="el" href="class_lin_box_1_1_blas_matrix.html">Matrix</a> &amp;A, <a class="el" href="class_lin_box_1_1_blas_matrix.html">Matrix</a> &amp;T, const CategoryTag &amp;tag, const EchelonMethod &amp;m)</td></tr>
<tr class="memdesc:a16eb70498b2f34f8bb4ded0e1172bfa5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the row echelon form of a matrix, not reduced, and the related transformation matrix.  <a href="#a16eb70498b2f34f8bb4ded0e1172bfa5">More...</a><br /></td></tr>
<tr class="separator:a16eb70498b2f34f8bb4ded0e1172bfa5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa95c73458f7f53b13e4c1d37e9628017"><td class="memTemplParams" colspan="2"><a id="aa95c73458f7f53b13e4c1d37e9628017"></a>
template&lt;class Matrix , class EchelonMethod &gt; </td></tr>
<tr class="memitem:aa95c73458f7f53b13e4c1d37e9628017"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_lin_box.html#aa95c73458f7f53b13e4c1d37e9628017">rowEchelonize</a> (<a class="el" href="class_lin_box_1_1_blas_matrix.html">Matrix</a> &amp;A, <a class="el" href="class_lin_box_1_1_blas_matrix.html">Matrix</a> &amp;T, const EchelonMethod &amp;m)</td></tr>
<tr class="memdesc:aa95c73458f7f53b13e4c1d37e9628017"><td class="mdescLeft">&#160;</td><td class="mdescRight">rowEchelonize dispatcher for automated category tag. <br /></td></tr>
<tr class="separator:aa95c73458f7f53b13e4c1d37e9628017"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7882d3e4124f0312b1b51fecb3280442"><td class="memTemplParams" colspan="2"><a id="a7882d3e4124f0312b1b51fecb3280442"></a>
template&lt;class Matrix &gt; </td></tr>
<tr class="memitem:a7882d3e4124f0312b1b51fecb3280442"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_lin_box.html#a7882d3e4124f0312b1b51fecb3280442">rowEchelonize</a> (<a class="el" href="class_lin_box_1_1_blas_matrix.html">Matrix</a> &amp;A, <a class="el" href="class_lin_box_1_1_blas_matrix.html">Matrix</a> &amp;T)</td></tr>
<tr class="memdesc:a7882d3e4124f0312b1b51fecb3280442"><td class="mdescLeft">&#160;</td><td class="mdescRight">rowEchelonize dispatcher for automated method. <br /></td></tr>
<tr class="separator:a7882d3e4124f0312b1b51fecb3280442"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaaf14c38b5a2a11b9c7bbe43e4f7f9f5"><td class="memTemplParams" colspan="2">template&lt;class Matrix , class CategoryTag , class EchelonMethod &gt; </td></tr>
<tr class="memitem:aaaf14c38b5a2a11b9c7bbe43e4f7f9f5"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_lin_box.html#aaaf14c38b5a2a11b9c7bbe43e4f7f9f5">reducedRowEchelon</a> (<a class="el" href="class_lin_box_1_1_blas_matrix.html">Matrix</a> &amp;E, const <a class="el" href="class_lin_box_1_1_blas_matrix.html">Matrix</a> &amp;A, const CategoryTag &amp;tag, const EchelonMethod &amp;m)</td></tr>
<tr class="memdesc:aaaf14c38b5a2a11b9c7bbe43e4f7f9f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the reduced row echelon form of a matrix.  <a href="#aaaf14c38b5a2a11b9c7bbe43e4f7f9f5">More...</a><br /></td></tr>
<tr class="separator:aaaf14c38b5a2a11b9c7bbe43e4f7f9f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0df8d189f83f8df6d144c5d97c63d114"><td class="memTemplParams" colspan="2"><a id="a0df8d189f83f8df6d144c5d97c63d114"></a>
template&lt;class Matrix , class EchelonMethod &gt; </td></tr>
<tr class="memitem:a0df8d189f83f8df6d144c5d97c63d114"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_lin_box.html#a0df8d189f83f8df6d144c5d97c63d114">reducedRowEchelon</a> (<a class="el" href="class_lin_box_1_1_blas_matrix.html">Matrix</a> &amp;E, const <a class="el" href="class_lin_box_1_1_blas_matrix.html">Matrix</a> &amp;A, const EchelonMethod &amp;m)</td></tr>
<tr class="memdesc:a0df8d189f83f8df6d144c5d97c63d114"><td class="mdescLeft">&#160;</td><td class="mdescRight">reducedRowEchelon dispatcher for automated category tag. <br /></td></tr>
<tr class="separator:a0df8d189f83f8df6d144c5d97c63d114"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fd4fe58c7d1862ddabddf4303c116d3"><td class="memTemplParams" colspan="2"><a id="a3fd4fe58c7d1862ddabddf4303c116d3"></a>
template&lt;class Matrix &gt; </td></tr>
<tr class="memitem:a3fd4fe58c7d1862ddabddf4303c116d3"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_lin_box.html#a3fd4fe58c7d1862ddabddf4303c116d3">reducedRowEchelon</a> (<a class="el" href="class_lin_box_1_1_blas_matrix.html">Matrix</a> &amp;E, const <a class="el" href="class_lin_box_1_1_blas_matrix.html">Matrix</a> &amp;A)</td></tr>
<tr class="memdesc:a3fd4fe58c7d1862ddabddf4303c116d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">reducedRowEchelon dispatcher for automated method. <br /></td></tr>
<tr class="separator:a3fd4fe58c7d1862ddabddf4303c116d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4e489547464dae2375dda0b2d321235"><td class="memTemplParams" colspan="2">template&lt;class Matrix , class CategoryTag , class EchelonMethod &gt; </td></tr>
<tr class="memitem:ae4e489547464dae2375dda0b2d321235"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_lin_box.html#ae4e489547464dae2375dda0b2d321235">reducedRowEchelon</a> (<a class="el" href="class_lin_box_1_1_blas_matrix.html">Matrix</a> &amp;E, <a class="el" href="class_lin_box_1_1_blas_matrix.html">Matrix</a> &amp;T, const <a class="el" href="class_lin_box_1_1_blas_matrix.html">Matrix</a> &amp;A, const CategoryTag &amp;tag, const EchelonMethod &amp;m)</td></tr>
<tr class="memdesc:ae4e489547464dae2375dda0b2d321235"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the reduced row echelon form of a matrix, and the related transformation matrix.  <a href="#ae4e489547464dae2375dda0b2d321235">More...</a><br /></td></tr>
<tr class="separator:ae4e489547464dae2375dda0b2d321235"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7636263d7d185cb57b043b1b81283e76"><td class="memTemplParams" colspan="2"><a id="a7636263d7d185cb57b043b1b81283e76"></a>
template&lt;class Matrix , class EchelonMethod &gt; </td></tr>
<tr class="memitem:a7636263d7d185cb57b043b1b81283e76"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_lin_box.html#a7636263d7d185cb57b043b1b81283e76">reducedRowEchelon</a> (<a class="el" href="class_lin_box_1_1_blas_matrix.html">Matrix</a> &amp;E, <a class="el" href="class_lin_box_1_1_blas_matrix.html">Matrix</a> &amp;T, const <a class="el" href="class_lin_box_1_1_blas_matrix.html">Matrix</a> &amp;A, const EchelonMethod &amp;m)</td></tr>
<tr class="memdesc:a7636263d7d185cb57b043b1b81283e76"><td class="mdescLeft">&#160;</td><td class="mdescRight">reducedRowEchelon dispatcher for automated category tag. <br /></td></tr>
<tr class="separator:a7636263d7d185cb57b043b1b81283e76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4e6fb1c9db117e4233ad90a1b5ecfb7"><td class="memTemplParams" colspan="2"><a id="ad4e6fb1c9db117e4233ad90a1b5ecfb7"></a>
template&lt;class Matrix &gt; </td></tr>
<tr class="memitem:ad4e6fb1c9db117e4233ad90a1b5ecfb7"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_lin_box.html#ad4e6fb1c9db117e4233ad90a1b5ecfb7">reducedRowEchelon</a> (<a class="el" href="class_lin_box_1_1_blas_matrix.html">Matrix</a> &amp;E, <a class="el" href="class_lin_box_1_1_blas_matrix.html">Matrix</a> &amp;T, const <a class="el" href="class_lin_box_1_1_blas_matrix.html">Matrix</a> &amp;A)</td></tr>
<tr class="memdesc:ad4e6fb1c9db117e4233ad90a1b5ecfb7"><td class="mdescLeft">&#160;</td><td class="mdescRight">reducedRowEchelon dispatcher for automated method. <br /></td></tr>
<tr class="separator:ad4e6fb1c9db117e4233ad90a1b5ecfb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a882e925d852b7445ca03a78ee8af3db2"><td class="memTemplParams" colspan="2">template&lt;class Matrix , class CategoryTag , class EchelonMethod &gt; </td></tr>
<tr class="memitem:a882e925d852b7445ca03a78ee8af3db2"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_lin_box.html#a882e925d852b7445ca03a78ee8af3db2">reducedRowEchelonize</a> (<a class="el" href="class_lin_box_1_1_blas_matrix.html">Matrix</a> &amp;A, const CategoryTag &amp;tag, const EchelonMethod &amp;m)</td></tr>
<tr class="memdesc:a882e925d852b7445ca03a78ee8af3db2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace the input matrix by its reduced row echelon form.  <a href="#a882e925d852b7445ca03a78ee8af3db2">More...</a><br /></td></tr>
<tr class="separator:a882e925d852b7445ca03a78ee8af3db2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29e19e5163ad72ef93ccd1f75857872d"><td class="memTemplParams" colspan="2"><a id="a29e19e5163ad72ef93ccd1f75857872d"></a>
template&lt;class Matrix , class EchelonMethod &gt; </td></tr>
<tr class="memitem:a29e19e5163ad72ef93ccd1f75857872d"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_lin_box.html#a29e19e5163ad72ef93ccd1f75857872d">reducedRowEchelonize</a> (<a class="el" href="class_lin_box_1_1_blas_matrix.html">Matrix</a> &amp;A, const EchelonMethod &amp;m)</td></tr>
<tr class="memdesc:a29e19e5163ad72ef93ccd1f75857872d"><td class="mdescLeft">&#160;</td><td class="mdescRight">reducedRowEchelonize dispatcher for automated category tag. <br /></td></tr>
<tr class="separator:a29e19e5163ad72ef93ccd1f75857872d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5628b78ab53fc40235f4a13f2c949167"><td class="memTemplParams" colspan="2"><a id="a5628b78ab53fc40235f4a13f2c949167"></a>
template&lt;class Matrix &gt; </td></tr>
<tr class="memitem:a5628b78ab53fc40235f4a13f2c949167"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_lin_box.html#a5628b78ab53fc40235f4a13f2c949167">reducedRowEchelonize</a> (<a class="el" href="class_lin_box_1_1_blas_matrix.html">Matrix</a> &amp;A)</td></tr>
<tr class="memdesc:a5628b78ab53fc40235f4a13f2c949167"><td class="mdescLeft">&#160;</td><td class="mdescRight">reducedRowEchelonize dispatcher for automated method. <br /></td></tr>
<tr class="separator:a5628b78ab53fc40235f4a13f2c949167"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fbb7ba4faaaf59a90cd10a86dc56c56"><td class="memTemplParams" colspan="2">template&lt;class Matrix , class CategoryTag , class EchelonMethod &gt; </td></tr>
<tr class="memitem:a5fbb7ba4faaaf59a90cd10a86dc56c56"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_lin_box.html#a5fbb7ba4faaaf59a90cd10a86dc56c56">reducedRowEchelonize</a> (<a class="el" href="class_lin_box_1_1_blas_matrix.html">Matrix</a> &amp;A, <a class="el" href="class_lin_box_1_1_blas_matrix.html">Matrix</a> &amp;T, const CategoryTag &amp;tag, const EchelonMethod &amp;m)</td></tr>
<tr class="memdesc:a5fbb7ba4faaaf59a90cd10a86dc56c56"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the reduced row echelon form of a matrix, and the related transformation matrix.  <a href="#a5fbb7ba4faaaf59a90cd10a86dc56c56">More...</a><br /></td></tr>
<tr class="separator:a5fbb7ba4faaaf59a90cd10a86dc56c56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade6dd822c8b9b67b9156547a104f6b06"><td class="memTemplParams" colspan="2"><a id="ade6dd822c8b9b67b9156547a104f6b06"></a>
template&lt;class Matrix , class EchelonMethod &gt; </td></tr>
<tr class="memitem:ade6dd822c8b9b67b9156547a104f6b06"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_lin_box.html#ade6dd822c8b9b67b9156547a104f6b06">reducedRowEchelonize</a> (<a class="el" href="class_lin_box_1_1_blas_matrix.html">Matrix</a> &amp;A, <a class="el" href="class_lin_box_1_1_blas_matrix.html">Matrix</a> &amp;T, const EchelonMethod &amp;m)</td></tr>
<tr class="memdesc:ade6dd822c8b9b67b9156547a104f6b06"><td class="mdescLeft">&#160;</td><td class="mdescRight">reducedRowEchelonize dispatcher for automated category tag. <br /></td></tr>
<tr class="separator:ade6dd822c8b9b67b9156547a104f6b06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a4d683755ca0a471aeedb311a421f61"><td class="memTemplParams" colspan="2"><a id="a6a4d683755ca0a471aeedb311a421f61"></a>
template&lt;class Matrix &gt; </td></tr>
<tr class="memitem:a6a4d683755ca0a471aeedb311a421f61"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_lin_box.html#a6a4d683755ca0a471aeedb311a421f61">reducedRowEchelonize</a> (<a class="el" href="class_lin_box_1_1_blas_matrix.html">Matrix</a> &amp;A, <a class="el" href="class_lin_box_1_1_blas_matrix.html">Matrix</a> &amp;T)</td></tr>
<tr class="memdesc:a6a4d683755ca0a471aeedb311a421f61"><td class="mdescLeft">&#160;</td><td class="mdescRight">reducedRowEchelonize dispatcher for automated method. <br /></td></tr>
<tr class="separator:a6a4d683755ca0a471aeedb311a421f61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4628133347c77a535394011e3f7d507b"><td class="memTemplParams" colspan="2">template&lt;class Matrix , class CategoryTag , class EchelonMethod &gt; </td></tr>
<tr class="memitem:a4628133347c77a535394011e3f7d507b"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_lin_box.html#a4628133347c77a535394011e3f7d507b">colEchelon</a> (<a class="el" href="class_lin_box_1_1_blas_matrix.html">Matrix</a> &amp;E, const <a class="el" href="class_lin_box_1_1_blas_matrix.html">Matrix</a> &amp;A, const CategoryTag &amp;tag, const EchelonMethod &amp;m)</td></tr>
<tr class="memdesc:a4628133347c77a535394011e3f7d507b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the column echelon form of a matrix, not reduced.  <a href="#a4628133347c77a535394011e3f7d507b">More...</a><br /></td></tr>
<tr class="separator:a4628133347c77a535394011e3f7d507b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28f8982335a3e990f6f18796e32bad8f"><td class="memTemplParams" colspan="2"><a id="a28f8982335a3e990f6f18796e32bad8f"></a>
template&lt;class Matrix , class EchelonMethod &gt; </td></tr>
<tr class="memitem:a28f8982335a3e990f6f18796e32bad8f"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_lin_box.html#a28f8982335a3e990f6f18796e32bad8f">colEchelon</a> (<a class="el" href="class_lin_box_1_1_blas_matrix.html">Matrix</a> &amp;E, const <a class="el" href="class_lin_box_1_1_blas_matrix.html">Matrix</a> &amp;A, const EchelonMethod &amp;m)</td></tr>
<tr class="memdesc:a28f8982335a3e990f6f18796e32bad8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">colEchelon dispatcher for automated category tag. <br /></td></tr>
<tr class="separator:a28f8982335a3e990f6f18796e32bad8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ec809f0503907ca93c8add590eabdef"><td class="memTemplParams" colspan="2"><a id="a0ec809f0503907ca93c8add590eabdef"></a>
template&lt;class Matrix &gt; </td></tr>
<tr class="memitem:a0ec809f0503907ca93c8add590eabdef"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_lin_box.html#a0ec809f0503907ca93c8add590eabdef">colEchelon</a> (<a class="el" href="class_lin_box_1_1_blas_matrix.html">Matrix</a> &amp;E, const <a class="el" href="class_lin_box_1_1_blas_matrix.html">Matrix</a> &amp;A)</td></tr>
<tr class="memdesc:a0ec809f0503907ca93c8add590eabdef"><td class="mdescLeft">&#160;</td><td class="mdescRight">colEchelon dispatcher for automated method. <br /></td></tr>
<tr class="separator:a0ec809f0503907ca93c8add590eabdef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30e0afbbab786da986b3a1819525e1c3"><td class="memTemplParams" colspan="2">template&lt;class Matrix , class CategoryTag , class EchelonMethod &gt; </td></tr>
<tr class="memitem:a30e0afbbab786da986b3a1819525e1c3"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_lin_box.html#a30e0afbbab786da986b3a1819525e1c3">colEchelon</a> (<a class="el" href="class_lin_box_1_1_blas_matrix.html">Matrix</a> &amp;E, <a class="el" href="class_lin_box_1_1_blas_matrix.html">Matrix</a> &amp;T, const <a class="el" href="class_lin_box_1_1_blas_matrix.html">Matrix</a> &amp;A, const CategoryTag &amp;tag, const EchelonMethod &amp;m)</td></tr>
<tr class="memdesc:a30e0afbbab786da986b3a1819525e1c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the column echelon form of a matrix, not reduced, and the related transformation matrix.  <a href="#a30e0afbbab786da986b3a1819525e1c3">More...</a><br /></td></tr>
<tr class="separator:a30e0afbbab786da986b3a1819525e1c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea721a0eb8b6ab87fba87d8e6c24cf3b"><td class="memTemplParams" colspan="2"><a id="aea721a0eb8b6ab87fba87d8e6c24cf3b"></a>
template&lt;class Matrix , class EchelonMethod &gt; </td></tr>
<tr class="memitem:aea721a0eb8b6ab87fba87d8e6c24cf3b"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_lin_box.html#aea721a0eb8b6ab87fba87d8e6c24cf3b">colEchelon</a> (<a class="el" href="class_lin_box_1_1_blas_matrix.html">Matrix</a> &amp;E, <a class="el" href="class_lin_box_1_1_blas_matrix.html">Matrix</a> &amp;T, const <a class="el" href="class_lin_box_1_1_blas_matrix.html">Matrix</a> &amp;A, const EchelonMethod &amp;m)</td></tr>
<tr class="memdesc:aea721a0eb8b6ab87fba87d8e6c24cf3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">colEchelon dispatcher for automated category tag. <br /></td></tr>
<tr class="separator:aea721a0eb8b6ab87fba87d8e6c24cf3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2ebd1409fee43c58d9862a3f1a73c4a"><td class="memTemplParams" colspan="2"><a id="ad2ebd1409fee43c58d9862a3f1a73c4a"></a>
template&lt;class Matrix &gt; </td></tr>
<tr class="memitem:ad2ebd1409fee43c58d9862a3f1a73c4a"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_lin_box.html#ad2ebd1409fee43c58d9862a3f1a73c4a">colEchelon</a> (<a class="el" href="class_lin_box_1_1_blas_matrix.html">Matrix</a> &amp;E, <a class="el" href="class_lin_box_1_1_blas_matrix.html">Matrix</a> &amp;T, const <a class="el" href="class_lin_box_1_1_blas_matrix.html">Matrix</a> &amp;A)</td></tr>
<tr class="memdesc:ad2ebd1409fee43c58d9862a3f1a73c4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">colEchelon dispatcher for automated method. <br /></td></tr>
<tr class="separator:ad2ebd1409fee43c58d9862a3f1a73c4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0966fcfc89a7ad664e21376f2e1e8598"><td class="memTemplParams" colspan="2">template&lt;class Matrix , class CategoryTag , class EchelonMethod &gt; </td></tr>
<tr class="memitem:a0966fcfc89a7ad664e21376f2e1e8598"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_lin_box.html#a0966fcfc89a7ad664e21376f2e1e8598">colEchelonize</a> (<a class="el" href="class_lin_box_1_1_blas_matrix.html">Matrix</a> &amp;A, const CategoryTag &amp;tag, const EchelonMethod &amp;m)</td></tr>
<tr class="memdesc:a0966fcfc89a7ad664e21376f2e1e8598"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace the input matrix by its column echelon form, not reduced.  <a href="#a0966fcfc89a7ad664e21376f2e1e8598">More...</a><br /></td></tr>
<tr class="separator:a0966fcfc89a7ad664e21376f2e1e8598"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a733c7c42d810e6a1c2aaaa29ad80d2d9"><td class="memTemplParams" colspan="2"><a id="a733c7c42d810e6a1c2aaaa29ad80d2d9"></a>
template&lt;class Matrix , class EchelonMethod &gt; </td></tr>
<tr class="memitem:a733c7c42d810e6a1c2aaaa29ad80d2d9"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_lin_box.html#a733c7c42d810e6a1c2aaaa29ad80d2d9">colEchelonize</a> (<a class="el" href="class_lin_box_1_1_blas_matrix.html">Matrix</a> &amp;A, const EchelonMethod &amp;m)</td></tr>
<tr class="memdesc:a733c7c42d810e6a1c2aaaa29ad80d2d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">colEchelonize dispatcher for automated category tag. <br /></td></tr>
<tr class="separator:a733c7c42d810e6a1c2aaaa29ad80d2d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee253cd381b5190d9e30adb075fa927d"><td class="memTemplParams" colspan="2"><a id="aee253cd381b5190d9e30adb075fa927d"></a>
template&lt;class Matrix &gt; </td></tr>
<tr class="memitem:aee253cd381b5190d9e30adb075fa927d"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_lin_box.html#aee253cd381b5190d9e30adb075fa927d">colEchelonize</a> (<a class="el" href="class_lin_box_1_1_blas_matrix.html">Matrix</a> &amp;A)</td></tr>
<tr class="memdesc:aee253cd381b5190d9e30adb075fa927d"><td class="mdescLeft">&#160;</td><td class="mdescRight">colEchelonize dispatcher for automated method. <br /></td></tr>
<tr class="separator:aee253cd381b5190d9e30adb075fa927d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae47c1a6f0fdd080f96cd2cf76f3648fe"><td class="memTemplParams" colspan="2">template&lt;class Matrix , class CategoryTag , class EchelonMethod &gt; </td></tr>
<tr class="memitem:ae47c1a6f0fdd080f96cd2cf76f3648fe"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_lin_box.html#ae47c1a6f0fdd080f96cd2cf76f3648fe">colEchelonize</a> (<a class="el" href="class_lin_box_1_1_blas_matrix.html">Matrix</a> &amp;A, <a class="el" href="class_lin_box_1_1_blas_matrix.html">Matrix</a> &amp;T, const CategoryTag &amp;tag, const EchelonMethod &amp;m)</td></tr>
<tr class="memdesc:ae47c1a6f0fdd080f96cd2cf76f3648fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the column echelon form of a matrix, not reduced, and the related transformation matrix.  <a href="#ae47c1a6f0fdd080f96cd2cf76f3648fe">More...</a><br /></td></tr>
<tr class="separator:ae47c1a6f0fdd080f96cd2cf76f3648fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ed56c6ff7a43549fbe93326df9a46a7"><td class="memTemplParams" colspan="2"><a id="a6ed56c6ff7a43549fbe93326df9a46a7"></a>
template&lt;class Matrix , class EchelonMethod &gt; </td></tr>
<tr class="memitem:a6ed56c6ff7a43549fbe93326df9a46a7"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_lin_box.html#a6ed56c6ff7a43549fbe93326df9a46a7">colEchelonize</a> (<a class="el" href="class_lin_box_1_1_blas_matrix.html">Matrix</a> &amp;A, <a class="el" href="class_lin_box_1_1_blas_matrix.html">Matrix</a> &amp;T, const EchelonMethod &amp;m)</td></tr>
<tr class="memdesc:a6ed56c6ff7a43549fbe93326df9a46a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">colEchelonize dispatcher for automated category tag. <br /></td></tr>
<tr class="separator:a6ed56c6ff7a43549fbe93326df9a46a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0a1fa56bc034a13d93c0967a14a7328"><td class="memTemplParams" colspan="2"><a id="ae0a1fa56bc034a13d93c0967a14a7328"></a>
template&lt;class Matrix &gt; </td></tr>
<tr class="memitem:ae0a1fa56bc034a13d93c0967a14a7328"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_lin_box.html#ae0a1fa56bc034a13d93c0967a14a7328">colEchelonize</a> (<a class="el" href="class_lin_box_1_1_blas_matrix.html">Matrix</a> &amp;A, <a class="el" href="class_lin_box_1_1_blas_matrix.html">Matrix</a> &amp;T)</td></tr>
<tr class="memdesc:ae0a1fa56bc034a13d93c0967a14a7328"><td class="mdescLeft">&#160;</td><td class="mdescRight">colEchelonize dispatcher for automated method. <br /></td></tr>
<tr class="separator:ae0a1fa56bc034a13d93c0967a14a7328"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bfbbd1a27e15894415a5d3ab67d7e56"><td class="memTemplParams" colspan="2">template&lt;class Matrix , class CategoryTag , class EchelonMethod &gt; </td></tr>
<tr class="memitem:a4bfbbd1a27e15894415a5d3ab67d7e56"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_lin_box.html#a4bfbbd1a27e15894415a5d3ab67d7e56">reducedColEchelon</a> (<a class="el" href="class_lin_box_1_1_blas_matrix.html">Matrix</a> &amp;E, const <a class="el" href="class_lin_box_1_1_blas_matrix.html">Matrix</a> &amp;A, const CategoryTag &amp;tag, const EchelonMethod &amp;m)</td></tr>
<tr class="memdesc:a4bfbbd1a27e15894415a5d3ab67d7e56"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the reduced column echelon form of a matrix.  <a href="#a4bfbbd1a27e15894415a5d3ab67d7e56">More...</a><br /></td></tr>
<tr class="separator:a4bfbbd1a27e15894415a5d3ab67d7e56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1187ab014f720ac0b0ba989ee2e28644"><td class="memTemplParams" colspan="2"><a id="a1187ab014f720ac0b0ba989ee2e28644"></a>
template&lt;class Matrix , class EchelonMethod &gt; </td></tr>
<tr class="memitem:a1187ab014f720ac0b0ba989ee2e28644"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_lin_box.html#a1187ab014f720ac0b0ba989ee2e28644">reducedColEchelon</a> (<a class="el" href="class_lin_box_1_1_blas_matrix.html">Matrix</a> &amp;E, const <a class="el" href="class_lin_box_1_1_blas_matrix.html">Matrix</a> &amp;A, const EchelonMethod &amp;m)</td></tr>
<tr class="memdesc:a1187ab014f720ac0b0ba989ee2e28644"><td class="mdescLeft">&#160;</td><td class="mdescRight">reducedColEchelon dispatcher for automated category tag. <br /></td></tr>
<tr class="separator:a1187ab014f720ac0b0ba989ee2e28644"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6c653ae4d497cff215d32f524dd73a7"><td class="memTemplParams" colspan="2"><a id="ad6c653ae4d497cff215d32f524dd73a7"></a>
template&lt;class Matrix &gt; </td></tr>
<tr class="memitem:ad6c653ae4d497cff215d32f524dd73a7"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_lin_box.html#ad6c653ae4d497cff215d32f524dd73a7">reducedColEchelon</a> (<a class="el" href="class_lin_box_1_1_blas_matrix.html">Matrix</a> &amp;E, const <a class="el" href="class_lin_box_1_1_blas_matrix.html">Matrix</a> &amp;A)</td></tr>
<tr class="memdesc:ad6c653ae4d497cff215d32f524dd73a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">reducedColEchelon dispatcher for automated method. <br /></td></tr>
<tr class="separator:ad6c653ae4d497cff215d32f524dd73a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a220bb4e68cd747e8a9e82233e47f14e3"><td class="memTemplParams" colspan="2">template&lt;class Matrix , class CategoryTag , class EchelonMethod &gt; </td></tr>
<tr class="memitem:a220bb4e68cd747e8a9e82233e47f14e3"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_lin_box.html#a220bb4e68cd747e8a9e82233e47f14e3">reducedColEchelon</a> (<a class="el" href="class_lin_box_1_1_blas_matrix.html">Matrix</a> &amp;E, <a class="el" href="class_lin_box_1_1_blas_matrix.html">Matrix</a> &amp;T, const <a class="el" href="class_lin_box_1_1_blas_matrix.html">Matrix</a> &amp;A, const CategoryTag &amp;tag, const EchelonMethod &amp;m)</td></tr>
<tr class="memdesc:a220bb4e68cd747e8a9e82233e47f14e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the reduced column echelon form of a matrix, and the related transformation matrix.  <a href="#a220bb4e68cd747e8a9e82233e47f14e3">More...</a><br /></td></tr>
<tr class="separator:a220bb4e68cd747e8a9e82233e47f14e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51ff0193b77e99acdda3f6b1d8eb7420"><td class="memTemplParams" colspan="2"><a id="a51ff0193b77e99acdda3f6b1d8eb7420"></a>
template&lt;class Matrix , class EchelonMethod &gt; </td></tr>
<tr class="memitem:a51ff0193b77e99acdda3f6b1d8eb7420"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_lin_box.html#a51ff0193b77e99acdda3f6b1d8eb7420">reducedColEchelon</a> (<a class="el" href="class_lin_box_1_1_blas_matrix.html">Matrix</a> &amp;E, <a class="el" href="class_lin_box_1_1_blas_matrix.html">Matrix</a> &amp;T, const <a class="el" href="class_lin_box_1_1_blas_matrix.html">Matrix</a> &amp;A, const EchelonMethod &amp;m)</td></tr>
<tr class="memdesc:a51ff0193b77e99acdda3f6b1d8eb7420"><td class="mdescLeft">&#160;</td><td class="mdescRight">reducedColEchelon dispatcher for automated category tag. <br /></td></tr>
<tr class="separator:a51ff0193b77e99acdda3f6b1d8eb7420"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a375bcb68b05e7b4662bef6c5aab9defb"><td class="memTemplParams" colspan="2"><a id="a375bcb68b05e7b4662bef6c5aab9defb"></a>
template&lt;class Matrix &gt; </td></tr>
<tr class="memitem:a375bcb68b05e7b4662bef6c5aab9defb"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_lin_box.html#a375bcb68b05e7b4662bef6c5aab9defb">reducedColEchelon</a> (<a class="el" href="class_lin_box_1_1_blas_matrix.html">Matrix</a> &amp;E, <a class="el" href="class_lin_box_1_1_blas_matrix.html">Matrix</a> &amp;T, const <a class="el" href="class_lin_box_1_1_blas_matrix.html">Matrix</a> &amp;A)</td></tr>
<tr class="memdesc:a375bcb68b05e7b4662bef6c5aab9defb"><td class="mdescLeft">&#160;</td><td class="mdescRight">reducedColEchelon dispatcher for automated method. <br /></td></tr>
<tr class="separator:a375bcb68b05e7b4662bef6c5aab9defb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76525c64e06d1e064f57d44bdd6af957"><td class="memTemplParams" colspan="2">template&lt;class Matrix , class CategoryTag , class EchelonMethod &gt; </td></tr>
<tr class="memitem:a76525c64e06d1e064f57d44bdd6af957"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_lin_box.html#a76525c64e06d1e064f57d44bdd6af957">reducedColEchelonize</a> (<a class="el" href="class_lin_box_1_1_blas_matrix.html">Matrix</a> &amp;A, const CategoryTag &amp;tag, const EchelonMethod &amp;m)</td></tr>
<tr class="memdesc:a76525c64e06d1e064f57d44bdd6af957"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace the input matrix by its reduced column echelon form.  <a href="#a76525c64e06d1e064f57d44bdd6af957">More...</a><br /></td></tr>
<tr class="separator:a76525c64e06d1e064f57d44bdd6af957"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97fdd74031f781bdaaf530923befb6e7"><td class="memTemplParams" colspan="2"><a id="a97fdd74031f781bdaaf530923befb6e7"></a>
template&lt;class Matrix , class EchelonMethod &gt; </td></tr>
<tr class="memitem:a97fdd74031f781bdaaf530923befb6e7"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_lin_box.html#a97fdd74031f781bdaaf530923befb6e7">reducedColEchelonize</a> (<a class="el" href="class_lin_box_1_1_blas_matrix.html">Matrix</a> &amp;A, const EchelonMethod &amp;m)</td></tr>
<tr class="memdesc:a97fdd74031f781bdaaf530923befb6e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">reducedColEchelonize dispatcher for automated category tag. <br /></td></tr>
<tr class="separator:a97fdd74031f781bdaaf530923befb6e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6e4b3d1adf8d9af021a9c315bc3e3a0"><td class="memTemplParams" colspan="2"><a id="ac6e4b3d1adf8d9af021a9c315bc3e3a0"></a>
template&lt;class Matrix &gt; </td></tr>
<tr class="memitem:ac6e4b3d1adf8d9af021a9c315bc3e3a0"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_lin_box.html#ac6e4b3d1adf8d9af021a9c315bc3e3a0">reducedColEchelonize</a> (<a class="el" href="class_lin_box_1_1_blas_matrix.html">Matrix</a> &amp;A)</td></tr>
<tr class="memdesc:ac6e4b3d1adf8d9af021a9c315bc3e3a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">reducedColEchelonize dispatcher for automated method. <br /></td></tr>
<tr class="separator:ac6e4b3d1adf8d9af021a9c315bc3e3a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefbd85604ed49895b0e83b0885d467e9"><td class="memTemplParams" colspan="2">template&lt;class Matrix , class CategoryTag , class EchelonMethod &gt; </td></tr>
<tr class="memitem:aefbd85604ed49895b0e83b0885d467e9"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_lin_box.html#aefbd85604ed49895b0e83b0885d467e9">reducedColEchelonize</a> (<a class="el" href="class_lin_box_1_1_blas_matrix.html">Matrix</a> &amp;A, <a class="el" href="class_lin_box_1_1_blas_matrix.html">Matrix</a> &amp;T, const CategoryTag &amp;tag, const EchelonMethod &amp;m)</td></tr>
<tr class="memdesc:aefbd85604ed49895b0e83b0885d467e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the reduced column echelon form of a matrix, and the related transformation matrix.  <a href="#aefbd85604ed49895b0e83b0885d467e9">More...</a><br /></td></tr>
<tr class="separator:aefbd85604ed49895b0e83b0885d467e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e00c2ee771acf38c8f6f8ba6052e46c"><td class="memTemplParams" colspan="2"><a id="a1e00c2ee771acf38c8f6f8ba6052e46c"></a>
template&lt;class Matrix , class EchelonMethod &gt; </td></tr>
<tr class="memitem:a1e00c2ee771acf38c8f6f8ba6052e46c"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_lin_box.html#a1e00c2ee771acf38c8f6f8ba6052e46c">reducedColEchelonize</a> (<a class="el" href="class_lin_box_1_1_blas_matrix.html">Matrix</a> &amp;A, <a class="el" href="class_lin_box_1_1_blas_matrix.html">Matrix</a> &amp;T, const EchelonMethod &amp;m)</td></tr>
<tr class="memdesc:a1e00c2ee771acf38c8f6f8ba6052e46c"><td class="mdescLeft">&#160;</td><td class="mdescRight">reducedColEchelonize dispatcher for automated category tag. <br /></td></tr>
<tr class="separator:a1e00c2ee771acf38c8f6f8ba6052e46c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3f3d9df08cddcfe113977b28d9d2844"><td class="memTemplParams" colspan="2"><a id="aa3f3d9df08cddcfe113977b28d9d2844"></a>
template&lt;class Matrix &gt; </td></tr>
<tr class="memitem:aa3f3d9df08cddcfe113977b28d9d2844"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_lin_box.html#aa3f3d9df08cddcfe113977b28d9d2844">reducedColEchelonize</a> (<a class="el" href="class_lin_box_1_1_blas_matrix.html">Matrix</a> &amp;A, <a class="el" href="class_lin_box_1_1_blas_matrix.html">Matrix</a> &amp;T)</td></tr>
<tr class="memdesc:aa3f3d9df08cddcfe113977b28d9d2844"><td class="mdescLeft">&#160;</td><td class="mdescRight">reducedColEchelonize dispatcher for automated method. <br /></td></tr>
<tr class="separator:aa3f3d9df08cddcfe113977b28d9d2844"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab391e49b8420d85600bb3b961add5489"><td class="memTemplParams" colspan="2"><a id="ab391e49b8420d85600bb3b961add5489"></a>
template&lt;class BB &gt; </td></tr>
<tr class="memitem:ab391e49b8420d85600bb3b961add5489"><td class="memTemplItemLeft" align="right" valign="top">BB::Field::Element &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_lin_box.html#ab391e49b8420d85600bb3b961add5489">getEntry</a> (typename BB::Field::Element &amp;x, const BB &amp;A, const size_t i, const size_t j)</td></tr>
<tr class="memdesc:ab391e49b8420d85600bb3b961add5489"><td class="mdescLeft">&#160;</td><td class="mdescRight">Getting the i,j entry of the blackbox. <br /></td></tr>
<tr class="separator:ab391e49b8420d85600bb3b961add5489"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3bb51d3873cf04a21391c3c9f76b867"><td class="memTemplParams" colspan="2"><a id="aa3bb51d3873cf04a21391c3c9f76b867"></a>
template&lt;class BB , class Method &gt; </td></tr>
<tr class="memitem:aa3bb51d3873cf04a21391c3c9f76b867"><td class="memTemplItemLeft" align="right" valign="top">BB::Field::Element &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_lin_box.html#aa3bb51d3873cf04a21391c3c9f76b867">getEntry</a> (typename BB::Field::Element &amp;x, const BB &amp;A, const size_t i, const size_t j, <a class="el" href="struct_lin_box_1_1_method.html">Method</a> &amp;m)</td></tr>
<tr class="memdesc:aa3bb51d3873cf04a21391c3c9f76b867"><td class="mdescLeft">&#160;</td><td class="mdescRight">To ignore methods. <br /></td></tr>
<tr class="separator:aa3bb51d3873cf04a21391c3c9f76b867"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3972c11d794b51a6a78a370cef2d56a6"><td class="memTemplParams" colspan="2">template&lt;class IMatrix &gt; </td></tr>
<tr class="memitem:a3972c11d794b51a6a78a370cef2d56a6"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_lin_box.html#a3972c11d794b51a6a78a370cef2d56a6">HadamardRowLogBound</a> (double &amp;logBound, double &amp;minLogNorm, const IMatrix &amp;A)</td></tr>
<tr class="memdesc:a3972c11d794b51a6a78a370cef2d56a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Precise Hadamard bound (bound on determinant) by taking the row-wise euclidean norm.  <a href="#a3972c11d794b51a6a78a370cef2d56a6">More...</a><br /></td></tr>
<tr class="separator:a3972c11d794b51a6a78a370cef2d56a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb5010cb1f820989dab458fc7bed0c56"><td class="memTemplParams" colspan="2">template&lt;class IMatrix &gt; </td></tr>
<tr class="memitem:adb5010cb1f820989dab458fc7bed0c56"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_lin_box.html#adb5010cb1f820989dab458fc7bed0c56">HadamardColLogBound</a> (double &amp;logBound, double &amp;minLogNorm, const IMatrix &amp;A)</td></tr>
<tr class="memdesc:adb5010cb1f820989dab458fc7bed0c56"><td class="mdescLeft">&#160;</td><td class="mdescRight">Precise Hadamard bound (bound on determinant) by taking the column-wise euclidean norm.  <a href="#adb5010cb1f820989dab458fc7bed0c56">More...</a><br /></td></tr>
<tr class="separator:adb5010cb1f820989dab458fc7bed0c56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c0c0bbd8cce2bd2c8ba7033bc24eaf9"><td class="memTemplParams" colspan="2">template&lt;class IMatrix &gt; </td></tr>
<tr class="memitem:a9c0c0bbd8cce2bd2c8ba7033bc24eaf9"><td class="memTemplItemLeft" align="right" valign="top">HadamardLogBoundDetails&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_lin_box.html#a9c0c0bbd8cce2bd2c8ba7033bc24eaf9">DetailedHadamardBound</a> (const IMatrix &amp;A)</td></tr>
<tr class="memdesc:a9c0c0bbd8cce2bd2c8ba7033bc24eaf9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Precise Hadamard bound (bound on determinant) by taking the minimum of the column-wise and the row-wise euclidean norm.  <a href="#a9c0c0bbd8cce2bd2c8ba7033bc24eaf9">More...</a><br /></td></tr>
<tr class="separator:a9c0c0bbd8cce2bd2c8ba7033bc24eaf9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ac0421dd3df3e55d96b86118112e2fd"><td class="memTemplParams" colspan="2">template&lt;class IMatrix &gt; </td></tr>
<tr class="memitem:a9ac0421dd3df3e55d96b86118112e2fd"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_lin_box.html#a9ac0421dd3df3e55d96b86118112e2fd">HadamardBound</a> (const IMatrix &amp;A)</td></tr>
<tr class="memdesc:a9ac0421dd3df3e55d96b86118112e2fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Precise Hadamard bound (bound on determinant) by taking the minimum of the column-wise and the row-wise euclidean norm.  <a href="#a9ac0421dd3df3e55d96b86118112e2fd">More...</a><br /></td></tr>
<tr class="separator:a9ac0421dd3df3e55d96b86118112e2fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb9002510c82416c37c8380f416ecbbd"><td class="memTemplParams" colspan="2">template&lt;class IMatrix &gt; </td></tr>
<tr class="memitem:abb9002510c82416c37c8380f416ecbbd"><td class="memTemplItemLeft" align="right" valign="top">Integer &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_lin_box.html#abb9002510c82416c37c8380f416ecbbd">InfinityNorm</a> (Integer &amp;max, const IMatrix &amp;A, const MatrixCategories::RowColMatrixTag &amp;tag)</td></tr>
<tr class="memdesc:abb9002510c82416c37c8380f416ecbbd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the bit size of the Hadamard bound.  <a href="#abb9002510c82416c37c8380f416ecbbd">More...</a><br /></td></tr>
<tr class="separator:abb9002510c82416c37c8380f416ecbbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbb0991103d6fd7fdbb8c3ed878d9830"><td class="memTemplParams" colspan="2">template&lt;class IMatrix &gt; </td></tr>
<tr class="memitem:acbb0991103d6fd7fdbb8c3ed878d9830"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_lin_box.html#acbb0991103d6fd7fdbb8c3ed878d9830">FastCharPolyDumasPernetWanBound</a> (const IMatrix &amp;A, const Integer &amp;infnorm)</td></tr>
<tr class="memdesc:acbb0991103d6fd7fdbb8c3ed878d9830"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bound on the coefficients of the characteristic polynomial.  <a href="#acbb0991103d6fd7fdbb8c3ed878d9830">More...</a><br /></td></tr>
<tr class="separator:acbb0991103d6fd7fdbb8c3ed878d9830"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45b441a86d2cc4fa12e11254c0e715fc"><td class="memTemplParams" colspan="2">template&lt;class IMatrix &gt; </td></tr>
<tr class="memitem:a45b441a86d2cc4fa12e11254c0e715fc"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_lin_box.html#a45b441a86d2cc4fa12e11254c0e715fc">FastCharPolyGoldsteinGrahamBound</a> (const IMatrix &amp;A, const Integer &amp;infnorm)</td></tr>
<tr class="memdesc:a45b441a86d2cc4fa12e11254c0e715fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">A.J.  <a href="#a45b441a86d2cc4fa12e11254c0e715fc">More...</a><br /></td></tr>
<tr class="separator:a45b441a86d2cc4fa12e11254c0e715fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99564f23a7353cb8cc8ade629b556a50"><td class="memTemplParams" colspan="2">template&lt;class Matrix , class Vector &gt; </td></tr>
<tr class="memitem:a99564f23a7353cb8cc8ade629b556a50"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; std::is_same&lt; typename <a class="el" href="struct_lin_box_1_1_field_traits.html">FieldTraits</a>&lt; typename Matrix::Field &gt;::categoryTag, <a class="el" href="struct_lin_box_1_1_ring_categories_1_1_integer_tag.html">RingCategories::IntegerTag</a> &gt;::value, RationalSolveHadamardBoundData &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_lin_box.html#a99564f23a7353cb8cc8ade629b556a50">RationalSolveHadamardBound</a> (const Matrix &amp;A, const <a class="el" href="struct_lin_box_1_1_vector.html">Vector</a> &amp;b)</td></tr>
<tr class="memdesc:a99564f23a7353cb8cc8ade629b556a50"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bound on the rational solution of a linear system Ax = b.  <a href="#a99564f23a7353cb8cc8ade629b556a50">More...</a><br /></td></tr>
<tr class="separator:a99564f23a7353cb8cc8ade629b556a50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af548ad661155916675234d5f50c3bf0f"><td class="memTemplParams" colspan="2"><a id="af548ad661155916675234d5f50c3bf0f"></a>
template&lt;class Matrix , class Vector &gt; </td></tr>
<tr class="memitem:af548ad661155916675234d5f50c3bf0f"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; std::is_same&lt; typename <a class="el" href="struct_lin_box_1_1_field_traits.html">FieldTraits</a>&lt; typename Matrix::Field &gt;::categoryTag, <a class="el" href="struct_lin_box_1_1_ring_categories_1_1_rational_tag.html">RingCategories::RationalTag</a> &gt;::value, RationalSolveHadamardBoundData &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_lin_box.html#af548ad661155916675234d5f50c3bf0f">RationalSolveHadamardBound</a> (const Matrix &amp;A, const <a class="el" href="struct_lin_box_1_1_vector.html">Vector</a> &amp;b)</td></tr>
<tr class="memdesc:af548ad661155916675234d5f50c3bf0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Needed to solve-cra.h, but can't be used yet. <br /></td></tr>
<tr class="separator:af548ad661155916675234d5f50c3bf0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d4a4ed851831af5753651f8e851a00b"><td class="memTemplParams" colspan="2"><a id="a4d4a4ed851831af5753651f8e851a00b"></a>
template&lt;class IMatrix , class MTag &gt; </td></tr>
<tr class="memitem:a4d4a4ed851831af5753651f8e851a00b"><td class="memTemplItemLeft" align="right" valign="top">Integer &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_lin_box.html#a4d4a4ed851831af5753651f8e851a00b">InfinityNorm</a> (Integer &amp;max, const IMatrix &amp;A, const MTag &amp;tag)</td></tr>
<tr class="memdesc:a4d4a4ed851831af5753651f8e851a00b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the maximal absolute value. <br /></td></tr>
<tr class="separator:a4d4a4ed851831af5753651f8e851a00b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0af7fd65b1b4bf21836bee9f98a80255"><td class="memTemplParams" colspan="2">template&lt;class IMatrix &gt; </td></tr>
<tr class="memitem:a0af7fd65b1b4bf21836bee9f98a80255"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_lin_box.html#a0af7fd65b1b4bf21836bee9f98a80255">FastHadamardBound</a> (const IMatrix &amp;A, const Integer &amp;infnorm)</td></tr>
<tr class="memdesc:a0af7fd65b1b4bf21836bee9f98a80255"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the bit size of the Hadamard bound.  <a href="#a0af7fd65b1b4bf21836bee9f98a80255">More...</a><br /></td></tr>
<tr class="separator:a0af7fd65b1b4bf21836bee9f98a80255"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22e887fb47b29e918a1a4305335bbabb"><td class="memTemplParams" colspan="2">template&lt;class Blackbox , class MyMethod &gt; </td></tr>
<tr class="memitem:a22e887fb47b29e918a1a4305335bbabb"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_lin_box.html#a22e887fb47b29e918a1a4305335bbabb">isPositiveDefinite</a> (const Blackbox &amp;A, const MyMethod &amp;M)</td></tr>
<tr class="memdesc:a22e887fb47b29e918a1a4305335bbabb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the isPositiveDefinite of A.  <a href="#a22e887fb47b29e918a1a4305335bbabb">More...</a><br /></td></tr>
<tr class="separator:a22e887fb47b29e918a1a4305335bbabb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addbc23ec04522da6dfdfe4c1f8ae6afc"><td class="memTemplParams" colspan="2">template&lt;class Blackbox &gt; </td></tr>
<tr class="memitem:addbc23ec04522da6dfdfe4c1f8ae6afc"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_lin_box.html#addbc23ec04522da6dfdfe4c1f8ae6afc">isPositiveDefinite</a> (const Blackbox &amp;A, const <a class="el" href="struct_lin_box_1_1_ring_categories_1_1_integer_tag.html">RingCategories::IntegerTag</a> &amp;tag, const <a class="el" href="namespace_lin_box.html#a10235377a5d8fe76c611f71b195cb97ea06b9281e396db002010bde1de57262eb">Method::Auto</a> &amp;M)</td></tr>
<tr class="separator:addbc23ec04522da6dfdfe4c1f8ae6afc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8e9dc4359118f1b4f93cb01bc8abbe2"><td class="memTemplParams" colspan="2">template&lt;class Blackbox &gt; </td></tr>
<tr class="memitem:aa8e9dc4359118f1b4f93cb01bc8abbe2"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_lin_box.html#aa8e9dc4359118f1b4f93cb01bc8abbe2">isPositiveDefinite</a> (const Blackbox &amp;A, const <a class="el" href="struct_lin_box_1_1_ring_categories_1_1_integer_tag.html">RingCategories::IntegerTag</a> &amp;tag, const Method::DenseElimination &amp;M)</td></tr>
<tr class="separator:aa8e9dc4359118f1b4f93cb01bc8abbe2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07fab2363dd6f649b8ba96d90f1830ac"><td class="memTemplParams" colspan="2">template&lt;class Blackbox , class MyMethod &gt; </td></tr>
<tr class="memitem:a07fab2363dd6f649b8ba96d90f1830ac"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_lin_box.html#a07fab2363dd6f649b8ba96d90f1830ac">isPositiveSemiDefinite</a> (const Blackbox &amp;A, const MyMethod &amp;M)</td></tr>
<tr class="memdesc:a07fab2363dd6f649b8ba96d90f1830ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if A is positive semidefinite.  <a href="#a07fab2363dd6f649b8ba96d90f1830ac">More...</a><br /></td></tr>
<tr class="separator:a07fab2363dd6f649b8ba96d90f1830ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ffb6619f43ef4b97e50bb0810787225"><td class="memTemplParams" colspan="2">template&lt;class Blackbox &gt; </td></tr>
<tr class="memitem:a7ffb6619f43ef4b97e50bb0810787225"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_lin_box.html#a7ffb6619f43ef4b97e50bb0810787225">isPositiveSemiDefinite</a> (const Blackbox &amp;A, const <a class="el" href="struct_lin_box_1_1_ring_categories_1_1_integer_tag.html">RingCategories::IntegerTag</a> &amp;tag, const Method::DenseElimination &amp;M)</td></tr>
<tr class="separator:a7ffb6619f43ef4b97e50bb0810787225"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24e27498e1becf897c3054a804556de4"><td class="memTemplParams" colspan="2"><a id="a24e27498e1becf897c3054a804556de4"></a>
template&lt;class Polynomial , class Blackbox &gt; </td></tr>
<tr class="memitem:a24e27498e1becf897c3054a804556de4"><td class="memTemplItemLeft" align="right" valign="top">Polynomial &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_lin_box.html#a24e27498e1becf897c3054a804556de4">minpoly</a> (Polynomial &amp;P, const Blackbox &amp;A)</td></tr>
<tr class="memdesc:a24e27498e1becf897c3054a804556de4"><td class="mdescLeft">&#160;</td><td class="mdescRight">...using default <a class="el" href="struct_lin_box_1_1_method.html" title="Define which method to use when working on a system. ">Method</a> <br /></td></tr>
<tr class="separator:a24e27498e1becf897c3054a804556de4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf81b9dc67cedf2044133b59399dd2334"><td class="memTemplParams" colspan="2">template&lt;class Blackbox , class Method , class DomainCategory &gt; </td></tr>
<tr class="memitem:gaf81b9dc67cedf2044133b59399dd2334"><td class="memTemplItemLeft" align="right" valign="top">size_t &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__solutions.html#gaf81b9dc67cedf2044133b59399dd2334">rank</a> (size_t &amp;r, const Blackbox &amp;A, const DomainCategory &amp;tag, const <a class="el" href="struct_lin_box_1_1_method.html">Method</a> &amp;M)</td></tr>
<tr class="memdesc:gaf81b9dc67cedf2044133b59399dd2334"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the rank of a linear transform A over a field by selected method.  <a href="group__solutions.html#gaf81b9dc67cedf2044133b59399dd2334">More...</a><br /></td></tr>
<tr class="separator:gaf81b9dc67cedf2044133b59399dd2334"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab21084c47a378b924fb1bdb4e9a7db1b"><td class="memTemplParams" colspan="2">template&lt;class Blackbox &gt; </td></tr>
<tr class="memitem:gab21084c47a378b924fb1bdb4e9a7db1b"><td class="memTemplItemLeft" align="right" valign="top">size_t &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__solutions.html#gab21084c47a378b924fb1bdb4e9a7db1b">rank</a> (size_t &amp;r, const Blackbox &amp;A)</td></tr>
<tr class="memdesc:gab21084c47a378b924fb1bdb4e9a7db1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the rank of a linear transform A over a field.  <a href="group__solutions.html#gab21084c47a378b924fb1bdb4e9a7db1b">More...</a><br /></td></tr>
<tr class="separator:gab21084c47a378b924fb1bdb4e9a7db1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab0a01a9fc169d04294eab924e2655026"><td class="memTemplParams" colspan="2">template&lt;class Blackbox , class Method &gt; </td></tr>
<tr class="memitem:gab0a01a9fc169d04294eab924e2655026"><td class="memTemplItemLeft" align="right" valign="top">size_t &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__solutions.html#gab0a01a9fc169d04294eab924e2655026">rank</a> (size_t &amp;r, const Blackbox &amp;A, const <a class="el" href="struct_lin_box_1_1_method.html">Method</a> &amp;M)</td></tr>
<tr class="memdesc:gab0a01a9fc169d04294eab924e2655026"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the rank of a linear transform A over a field.  <a href="group__solutions.html#gab0a01a9fc169d04294eab924e2655026">More...</a><br /></td></tr>
<tr class="separator:gab0a01a9fc169d04294eab924e2655026"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc868c07af266200afa8592d083ea5ed"><td class="memTemplParams" colspan="2">template&lt;class Blackbox &gt; </td></tr>
<tr class="memitem:afc868c07af266200afa8592d083ea5ed"><td class="memTemplItemLeft" align="right" valign="top">size_t &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_lin_box.html#afc868c07af266200afa8592d083ea5ed">rankInPlace</a> (size_t &amp;r, Blackbox &amp;A)</td></tr>
<tr class="memdesc:afc868c07af266200afa8592d083ea5ed"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="namespace_lin_box_1_1_rank.html" title="Rank of the system, if known. ">Rank</a> of <code>A</code>.  <a href="#afc868c07af266200afa8592d083ea5ed">More...</a><br /></td></tr>
<tr class="separator:afc868c07af266200afa8592d083ea5ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfde1de28c0b3f498bcec29850c9c0d5"><td class="memTemplParams" colspan="2">template&lt;class Blackbox &gt; </td></tr>
<tr class="memitem:adfde1de28c0b3f498bcec29850c9c0d5"><td class="memTemplItemLeft" align="right" valign="top">size_t &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_lin_box.html#adfde1de28c0b3f498bcec29850c9c0d5">rank</a> (size_t &amp;r, const Blackbox &amp;A, const <a class="el" href="struct_lin_box_1_1_ring_categories_1_1_modular_tag.html">RingCategories::ModularTag</a> &amp;tag, const <a class="el" href="namespace_lin_box.html#a10235377a5d8fe76c611f71b195cb97ea06b9281e396db002010bde1de57262eb">Method::Auto</a> &amp;m)</td></tr>
<tr class="separator:adfde1de28c0b3f498bcec29850c9c0d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadd94634e20c65da01ddc12e8fdf135a"><td class="memTemplParams" colspan="2">template&lt;class Blackbox &gt; </td></tr>
<tr class="memitem:aadd94634e20c65da01ddc12e8fdf135a"><td class="memTemplItemLeft" align="right" valign="top">size_t &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_lin_box.html#aadd94634e20c65da01ddc12e8fdf135a">rank</a> (size_t &amp;res, const Blackbox &amp;A, const <a class="el" href="struct_lin_box_1_1_ring_categories_1_1_modular_tag.html">RingCategories::ModularTag</a> &amp;tag, const Method::Wiedemann &amp;M)</td></tr>
<tr class="memdesc:aadd94634e20c65da01ddc12e8fdf135a"><td class="mdescLeft">&#160;</td><td class="mdescRight">M may be <code>Method::Wiedemann()</code>.  <a href="#aadd94634e20c65da01ddc12e8fdf135a">More...</a><br /></td></tr>
<tr class="separator:aadd94634e20c65da01ddc12e8fdf135a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84b5170728c9309a196d27449384e6f5"><td class="memTemplParams" colspan="2"><a id="a84b5170728c9309a196d27449384e6f5"></a>
template&lt;class Field &gt; </td></tr>
<tr class="memitem:a84b5170728c9309a196d27449384e6f5"><td class="memTemplItemLeft" align="right" valign="top">size_t &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_lin_box.html#a84b5170728c9309a196d27449384e6f5">rank</a> (size_t &amp;r, const SparseMatrix&lt; Field, <a class="el" href="class_lin_box_1_1_sparse_matrix_format_1_1_sparse_seq.html">SparseMatrixFormat::SparseSeq</a> &gt; &amp;A, const <a class="el" href="struct_lin_box_1_1_ring_categories_1_1_modular_tag.html">RingCategories::ModularTag</a> &amp;tag, const Method::SparseElimination &amp;M)</td></tr>
<tr class="memdesc:a84b5170728c9309a196d27449384e6f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">M may be <code>Method::SparseElimination()</code>. <br /></td></tr>
<tr class="separator:a84b5170728c9309a196d27449384e6f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf81905151b38be621bbb34c8ab8ba23"><td class="memItemLeft" align="right" valign="top"><a id="abf81905151b38be621bbb34c8ab8ba23"></a>
size_t &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_lin_box.html#abf81905151b38be621bbb34c8ab8ba23">rankInPlace</a> (size_t &amp;r, <a class="el" href="class_lin_box_1_1_gauss_domain.html">GaussDomain</a>&lt; GF2 &gt;::<a class="el" href="class_lin_box_1_1_blas_matrix.html">Matrix</a> &amp;A, const Method::SparseElimination &amp;)</td></tr>
<tr class="memdesc:abf81905151b38be621bbb34c8ab8ba23"><td class="mdescLeft">&#160;</td><td class="mdescRight">specialization to <img class="formulaInl" alt="$ \mathbf{F}_2 $" src="form_62.png"/> <br /></td></tr>
<tr class="separator:abf81905151b38be621bbb34c8ab8ba23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05466023d8a91c4586179a0da8e72737"><td class="memItemLeft" align="right" valign="top"><a id="a05466023d8a91c4586179a0da8e72737"></a>
size_t &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_lin_box.html#a05466023d8a91c4586179a0da8e72737">rankInPlace</a> (size_t &amp;r, <a class="el" href="class_lin_box_1_1_gauss_domain.html">GaussDomain</a>&lt; GF2 &gt;::<a class="el" href="class_lin_box_1_1_blas_matrix.html">Matrix</a> &amp;A, const <a class="el" href="struct_lin_box_1_1_ring_categories_1_1_modular_tag.html">RingCategories::ModularTag</a> &amp;, const Method::SparseElimination &amp;M)</td></tr>
<tr class="memdesc:a05466023d8a91c4586179a0da8e72737"><td class="mdescLeft">&#160;</td><td class="mdescRight">specialization to <img class="formulaInl" alt="$ \mathbf{F}_2 $" src="form_62.png"/> <br /></td></tr>
<tr class="separator:a05466023d8a91c4586179a0da8e72737"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75701045b2b5852da782fcdcfe4f2a6d"><td class="memTemplParams" colspan="2"><a id="a75701045b2b5852da782fcdcfe4f2a6d"></a>
template&lt;class Field &gt; </td></tr>
<tr class="memitem:a75701045b2b5852da782fcdcfe4f2a6d"><td class="memTemplItemLeft" align="right" valign="top">size_t &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_lin_box.html#a75701045b2b5852da782fcdcfe4f2a6d">rankInPlace</a> (size_t &amp;r, <a class="el" href="class_lin_box_1_1_blas_matrix.html">BlasMatrix</a>&lt; Field &gt; &amp;A, const <a class="el" href="struct_lin_box_1_1_ring_categories_1_1_modular_tag.html">RingCategories::ModularTag</a> &amp;tag, const Method::DenseElimination &amp;M)</td></tr>
<tr class="memdesc:a75701045b2b5852da782fcdcfe4f2a6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">A is modified. <br /></td></tr>
<tr class="separator:a75701045b2b5852da782fcdcfe4f2a6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8b19d94e7ebf1e2fbe716f9e344acf2d"><td class="memTemplParams" colspan="2">template&lt;class Blackbox , class Method &gt; </td></tr>
<tr class="memitem:ga8b19d94e7ebf1e2fbe716f9e344acf2d"><td class="memTemplItemLeft" align="right" valign="top">SmithList&lt; typename Blackbox::Field &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__solutions.html#ga8b19d94e7ebf1e2fbe716f9e344acf2d">smithForm</a> (SmithList&lt; typename Blackbox::Field &gt; &amp;S, const Blackbox &amp;A, const <a class="el" href="struct_lin_box_1_1_method.html">Method</a> &amp;M)</td></tr>
<tr class="memdesc:ga8b19d94e7ebf1e2fbe716f9e344acf2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the Smith form of A.  <a href="group__solutions.html#ga8b19d94e7ebf1e2fbe716f9e344acf2d">More...</a><br /></td></tr>
<tr class="separator:ga8b19d94e7ebf1e2fbe716f9e344acf2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48d5cca9522517193bdb7d2feaa28aa5"><td class="memTemplParams" colspan="2"><a id="a48d5cca9522517193bdb7d2feaa28aa5"></a>
template&lt;class ResultVector , class Matrix , class Vector , class CategoryTag &gt; </td></tr>
<tr class="memitem:a48d5cca9522517193bdb7d2feaa28aa5"><td class="memTemplItemLeft" align="right" valign="top">ResultVector &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_lin_box.html#a48d5cca9522517193bdb7d2feaa28aa5">solve</a> (ResultVector &amp;x, const <a class="el" href="class_lin_box_1_1_blas_matrix.html">Matrix</a> &amp;A, const <a class="el" href="struct_lin_box_1_1_vector.html">Vector</a> &amp;b, const CategoryTag &amp;tag, const <a class="el" href="namespace_lin_box.html#a10235377a5d8fe76c611f71b195cb97ea06b9281e396db002010bde1de57262eb">Method::Auto</a> &amp;m)</td></tr>
<tr class="memdesc:a48d5cca9522517193bdb7d2feaa28aa5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solve specialisation for Auto. <br /></td></tr>
<tr class="separator:a48d5cca9522517193bdb7d2feaa28aa5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88369bb64b05f8bd446597e0e2d8f1cc"><td class="memTemplParams" colspan="2"><a id="a88369bb64b05f8bd446597e0e2d8f1cc"></a>
template&lt;class ResultVector , class Field , class Vector &gt; </td></tr>
<tr class="memitem:a88369bb64b05f8bd446597e0e2d8f1cc"><td class="memTemplItemLeft" align="right" valign="top">ResultVector &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_lin_box.html#a88369bb64b05f8bd446597e0e2d8f1cc">solve</a> (ResultVector &amp;x, const <a class="el" href="class_lin_box_1_1_blas_matrix.html">DenseMatrix</a>&lt; Field &gt; &amp;A, const <a class="el" href="struct_lin_box_1_1_vector.html">Vector</a> &amp;b, const <a class="el" href="struct_lin_box_1_1_ring_categories_1_1_modular_tag.html">RingCategories::ModularTag</a> &amp;tag, const <a class="el" href="namespace_lin_box.html#a10235377a5d8fe76c611f71b195cb97ea06b9281e396db002010bde1de57262eb">Method::Auto</a> &amp;m)</td></tr>
<tr class="memdesc:a88369bb64b05f8bd446597e0e2d8f1cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solve specialisation for Auto with DenseMatrix and ModularTag. <br /></td></tr>
<tr class="separator:a88369bb64b05f8bd446597e0e2d8f1cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0779cf44e222ae37aa1987380878168"><td class="memTemplParams" colspan="2"><a id="ac0779cf44e222ae37aa1987380878168"></a>
template&lt;class ResultVector , class... MatrixArgs, class Vector &gt; </td></tr>
<tr class="memitem:ac0779cf44e222ae37aa1987380878168"><td class="memTemplItemLeft" align="right" valign="top">ResultVector &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_lin_box.html#ac0779cf44e222ae37aa1987380878168">solve</a> (ResultVector &amp;x, const SparseMatrix&lt; MatrixArgs... &gt; &amp;A, const <a class="el" href="struct_lin_box_1_1_vector.html">Vector</a> &amp;b, const <a class="el" href="struct_lin_box_1_1_ring_categories_1_1_modular_tag.html">RingCategories::ModularTag</a> &amp;tag, const <a class="el" href="namespace_lin_box.html#a10235377a5d8fe76c611f71b195cb97ea06b9281e396db002010bde1de57262eb">Method::Auto</a> &amp;m)</td></tr>
<tr class="memdesc:ac0779cf44e222ae37aa1987380878168"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solve specialisation for Auto with SparseMatrix and ModularTag. <br /></td></tr>
<tr class="separator:ac0779cf44e222ae37aa1987380878168"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d026f9b6997af88d0cd67f26f8593d7"><td class="memTemplParams" colspan="2"><a id="a2d026f9b6997af88d0cd67f26f8593d7"></a>
template&lt;class ResultVector , class Matrix , class Vector &gt; </td></tr>
<tr class="memitem:a2d026f9b6997af88d0cd67f26f8593d7"><td class="memTemplItemLeft" align="right" valign="top">ResultVector &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_lin_box.html#a2d026f9b6997af88d0cd67f26f8593d7">solve</a> (ResultVector &amp;x, const <a class="el" href="class_lin_box_1_1_blas_matrix.html">Matrix</a> &amp;A, const <a class="el" href="struct_lin_box_1_1_vector.html">Vector</a> &amp;b, const <a class="el" href="struct_lin_box_1_1_ring_categories_1_1_integer_tag.html">RingCategories::IntegerTag</a> &amp;tag, const <a class="el" href="namespace_lin_box.html#a10235377a5d8fe76c611f71b195cb97ea06b9281e396db002010bde1de57262eb">Method::Auto</a> &amp;m)</td></tr>
<tr class="memdesc:a2d026f9b6997af88d0cd67f26f8593d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solve specialisation for Auto and IntegerTag. <br /></td></tr>
<tr class="separator:a2d026f9b6997af88d0cd67f26f8593d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a717140160eca020e322ac4397a01c9"><td class="memTemplParams" colspan="2"><a id="a6a717140160eca020e322ac4397a01c9"></a>
template&lt;class ResultVector , class Matrix , class Vector &gt; </td></tr>
<tr class="memitem:a6a717140160eca020e322ac4397a01c9"><td class="memTemplItemLeft" align="right" valign="top">ResultVector &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_lin_box.html#a6a717140160eca020e322ac4397a01c9">solve</a> (ResultVector &amp;x, const <a class="el" href="class_lin_box_1_1_blas_matrix.html">Matrix</a> &amp;A, const <a class="el" href="struct_lin_box_1_1_vector.html">Vector</a> &amp;b, const <a class="el" href="struct_lin_box_1_1_ring_categories_1_1_rational_tag.html">RingCategories::RationalTag</a> &amp;tag, const <a class="el" href="namespace_lin_box.html#a10235377a5d8fe76c611f71b195cb97ea06b9281e396db002010bde1de57262eb">Method::Auto</a> &amp;m)</td></tr>
<tr class="memdesc:a6a717140160eca020e322ac4397a01c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solve specialisation for Auto and RationalTag. <br /></td></tr>
<tr class="separator:a6a717140160eca020e322ac4397a01c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0427cbec13456d2187f0e2e97c8283e"><td class="memTemplParams" colspan="2"><a id="af0427cbec13456d2187f0e2e97c8283e"></a>
template&lt;class IntVector , class Matrix , class Vector &gt; </td></tr>
<tr class="memitem:af0427cbec13456d2187f0e2e97c8283e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_lin_box.html#af0427cbec13456d2187f0e2e97c8283e">solve</a> (IntVector &amp;xNum, typename IntVector::Element &amp;xDen, const <a class="el" href="class_lin_box_1_1_blas_matrix.html">Matrix</a> &amp;A, const <a class="el" href="struct_lin_box_1_1_vector.html">Vector</a> &amp;b, const <a class="el" href="struct_lin_box_1_1_ring_categories_1_1_integer_tag.html">RingCategories::IntegerTag</a> &amp;tag, const <a class="el" href="namespace_lin_box.html#a10235377a5d8fe76c611f71b195cb97ea06b9281e396db002010bde1de57262eb">Method::Auto</a> &amp;m)</td></tr>
<tr class="memdesc:af0427cbec13456d2187f0e2e97c8283e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solve specialization for Auto and IntegerTag. <br /></td></tr>
<tr class="separator:af0427cbec13456d2187f0e2e97c8283e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b6ec687d48d29617575bb1eb48765dd"><td class="memTemplParams" colspan="2"><a id="a0b6ec687d48d29617575bb1eb48765dd"></a>
template&lt;class ResultVector , class Matrix , class Vector , class CategoryTag &gt; </td></tr>
<tr class="memitem:a0b6ec687d48d29617575bb1eb48765dd"><td class="memTemplItemLeft" align="right" valign="top">ResultVector &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_lin_box.html#a0b6ec687d48d29617575bb1eb48765dd">solveInPlace</a> (ResultVector &amp;x, <a class="el" href="class_lin_box_1_1_blas_matrix.html">Matrix</a> &amp;A, const <a class="el" href="struct_lin_box_1_1_vector.html">Vector</a> &amp;b, const CategoryTag &amp;tag, const <a class="el" href="namespace_lin_box.html#a10235377a5d8fe76c611f71b195cb97ea06b9281e396db002010bde1de57262eb">Method::Auto</a> &amp;m)</td></tr>
<tr class="memdesc:a0b6ec687d48d29617575bb1eb48765dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solve in place specialisation for Auto. <br /></td></tr>
<tr class="separator:a0b6ec687d48d29617575bb1eb48765dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1be25e9aba8cb6979162969fc99f56a"><td class="memTemplParams" colspan="2"><a id="ab1be25e9aba8cb6979162969fc99f56a"></a>
template&lt;class ResultVector , class Matrix , class Vector &gt; </td></tr>
<tr class="memitem:ab1be25e9aba8cb6979162969fc99f56a"><td class="memTemplItemLeft" align="right" valign="top">ResultVector &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_lin_box.html#ab1be25e9aba8cb6979162969fc99f56a">solveInPlace</a> (ResultVector &amp;x, <a class="el" href="class_lin_box_1_1_blas_matrix.html">Matrix</a> &amp;A, const <a class="el" href="struct_lin_box_1_1_vector.html">Vector</a> &amp;b, const <a class="el" href="struct_lin_box_1_1_ring_categories_1_1_integer_tag.html">RingCategories::IntegerTag</a> &amp;tag, const <a class="el" href="namespace_lin_box.html#a10235377a5d8fe76c611f71b195cb97ea06b9281e396db002010bde1de57262eb">Method::Auto</a> &amp;m)</td></tr>
<tr class="memdesc:ab1be25e9aba8cb6979162969fc99f56a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solve in place specialisation for Auto and IntegerTag. <br /></td></tr>
<tr class="separator:ab1be25e9aba8cb6979162969fc99f56a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee5005a76eb1fcb71aac1da79fe327a1"><td class="memTemplParams" colspan="2"><a id="aee5005a76eb1fcb71aac1da79fe327a1"></a>
template&lt;class ResultVector , class Field , class Vector , class CategoryTag &gt; </td></tr>
<tr class="memitem:aee5005a76eb1fcb71aac1da79fe327a1"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt;!std::is_same&lt; CategoryTag, <a class="el" href="struct_lin_box_1_1_ring_categories_1_1_integer_tag.html">RingCategories::IntegerTag</a> &gt;::value, ResultVector &amp; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_lin_box.html#aee5005a76eb1fcb71aac1da79fe327a1">solveInPlace</a> (ResultVector &amp;x, <a class="el" href="class_lin_box_1_1_blas_matrix.html">DenseMatrix</a>&lt; Field &gt; &amp;A, const <a class="el" href="struct_lin_box_1_1_vector.html">Vector</a> &amp;b, const CategoryTag &amp;tag, const <a class="el" href="namespace_lin_box.html#a10235377a5d8fe76c611f71b195cb97ea06b9281e396db002010bde1de57262eb">Method::Auto</a> &amp;m)</td></tr>
<tr class="memdesc:aee5005a76eb1fcb71aac1da79fe327a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solve in place specialisation for Auto with DenseMatrix and non-IntegerTag. <br /></td></tr>
<tr class="separator:aee5005a76eb1fcb71aac1da79fe327a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b4ad41ee597372823fdbca0fc0c3cf0"><td class="memTemplParams" colspan="2"><a id="a0b4ad41ee597372823fdbca0fc0c3cf0"></a>
template&lt;class ResultVector , class... MatrixArgs, class Vector , class CategoryTag &gt; </td></tr>
<tr class="memitem:a0b4ad41ee597372823fdbca0fc0c3cf0"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt;!std::is_same&lt; CategoryTag, <a class="el" href="struct_lin_box_1_1_ring_categories_1_1_integer_tag.html">RingCategories::IntegerTag</a> &gt;::value, ResultVector &amp; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_lin_box.html#a0b4ad41ee597372823fdbca0fc0c3cf0">solveInPlace</a> (ResultVector &amp;x, SparseMatrix&lt; MatrixArgs... &gt; &amp;A, const <a class="el" href="struct_lin_box_1_1_vector.html">Vector</a> &amp;b, const CategoryTag &amp;tag, const <a class="el" href="namespace_lin_box.html#a10235377a5d8fe76c611f71b195cb97ea06b9281e396db002010bde1de57262eb">Method::Auto</a> &amp;m)</td></tr>
<tr class="memdesc:a0b4ad41ee597372823fdbca0fc0c3cf0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solve in place specialisation for Auto with SparseMatrix and non-IntegerTag. <br /></td></tr>
<tr class="separator:a0b4ad41ee597372823fdbca0fc0c3cf0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cf6254756b650f93ae67959ac09041b"><td class="memTemplParams" colspan="2"><a id="a6cf6254756b650f93ae67959ac09041b"></a>
template&lt;class Matrix , class Vector &gt; </td></tr>
<tr class="memitem:a6cf6254756b650f93ae67959ac09041b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_lin_box.html#a6cf6254756b650f93ae67959ac09041b">solveInPlace</a> (<a class="el" href="struct_lin_box_1_1_vector.html">Vector</a> &amp;xNum, typename Vector::Element &amp;xDen, <a class="el" href="class_lin_box_1_1_blas_matrix.html">Matrix</a> &amp;A, const <a class="el" href="struct_lin_box_1_1_vector.html">Vector</a> &amp;b, const <a class="el" href="struct_lin_box_1_1_ring_categories_1_1_integer_tag.html">RingCategories::IntegerTag</a> &amp;tag, const <a class="el" href="namespace_lin_box.html#a10235377a5d8fe76c611f71b195cb97ea06b9281e396db002010bde1de57262eb">Method::Auto</a> &amp;m)</td></tr>
<tr class="memdesc:a6cf6254756b650f93ae67959ac09041b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solve in place specialization for Auto and IntegerTag. <br /></td></tr>
<tr class="separator:a6cf6254756b650f93ae67959ac09041b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a589490d4b2ada95c5717208b132b32d3"><td class="memTemplParams" colspan="2"><a id="a589490d4b2ada95c5717208b132b32d3"></a>
template&lt;class ResultVector , class Matrix , class Vector , class CategoryTag &gt; </td></tr>
<tr class="memitem:a589490d4b2ada95c5717208b132b32d3"><td class="memTemplItemLeft" align="right" valign="top">ResultVector &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_lin_box.html#a589490d4b2ada95c5717208b132b32d3">solve</a> (ResultVector &amp;x, const <a class="el" href="class_lin_box_1_1_blas_matrix.html">Matrix</a> &amp;A, const <a class="el" href="struct_lin_box_1_1_vector.html">Vector</a> &amp;b, const CategoryTag &amp;tag, const Method::Blackbox &amp;m)</td></tr>
<tr class="memdesc:a589490d4b2ada95c5717208b132b32d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solve specialisation for Blackbox. <br /></td></tr>
<tr class="separator:a589490d4b2ada95c5717208b132b32d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a842429ba6fb4eda49f0279f57518d823"><td class="memTemplParams" colspan="2"><a id="a842429ba6fb4eda49f0279f57518d823"></a>
template&lt;class ResultVector , class Matrix , class Vector , class CategoryTag &gt; </td></tr>
<tr class="memitem:a842429ba6fb4eda49f0279f57518d823"><td class="memTemplItemLeft" align="right" valign="top">ResultVector &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_lin_box.html#a842429ba6fb4eda49f0279f57518d823">solveInPlace</a> (ResultVector &amp;x, <a class="el" href="class_lin_box_1_1_blas_matrix.html">Matrix</a> &amp;A, const <a class="el" href="struct_lin_box_1_1_vector.html">Vector</a> &amp;b, const CategoryTag &amp;tag, const Method::Blackbox &amp;m)</td></tr>
<tr class="memdesc:a842429ba6fb4eda49f0279f57518d823"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solve in place specialisation for Blackbox. <br /></td></tr>
<tr class="separator:a842429ba6fb4eda49f0279f57518d823"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f10e874b0ff76927361596ffde1b670"><td class="memTemplParams" colspan="2">template&lt;class IntVector , class Matrix , class Vector , class IterationMethod &gt; </td></tr>
<tr class="memitem:a7f10e874b0ff76927361596ffde1b670"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_lin_box.html#a7f10e874b0ff76927361596ffde1b670">solve</a> (IntVector &amp;xNum, typename IntVector::Element &amp;xDen, const <a class="el" href="class_lin_box_1_1_blas_matrix.html">Matrix</a> &amp;A, const <a class="el" href="struct_lin_box_1_1_vector.html">Vector</a> &amp;b, const <a class="el" href="struct_lin_box_1_1_ring_categories_1_1_integer_tag.html">RingCategories::IntegerTag</a> &amp;tag, const Method::CRA&lt; IterationMethod &gt; &amp;m)</td></tr>
<tr class="memdesc:a7f10e874b0ff76927361596ffde1b670"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solve specialization with Chinese Remainder Algorithm method for an Integer or Rational tags.  <a href="#a7f10e874b0ff76927361596ffde1b670">More...</a><br /></td></tr>
<tr class="separator:a7f10e874b0ff76927361596ffde1b670"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a933835b5c2586a4bd69d0929f7c6006b"><td class="memTemplParams" colspan="2"><a id="a933835b5c2586a4bd69d0929f7c6006b"></a>
template&lt;class RatVector , class RatMatrix , class IterationMethod &gt; </td></tr>
<tr class="memitem:a933835b5c2586a4bd69d0929f7c6006b"><td class="memTemplItemLeft" align="right" valign="top">RatVector &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_lin_box.html#a933835b5c2586a4bd69d0929f7c6006b">solve</a> (RatVector &amp;x, const RatMatrix &amp;A, const RatVector &amp;b, const <a class="el" href="struct_lin_box_1_1_ring_categories_1_1_rational_tag.html">RingCategories::RationalTag</a> &amp;tag, const Method::CRA&lt; IterationMethod &gt; &amp;m)</td></tr>
<tr class="memdesc:a933835b5c2586a4bd69d0929f7c6006b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solve specialization with Chinese Remainder Algorithm method for a Rational matrix. <br /></td></tr>
<tr class="separator:a933835b5c2586a4bd69d0929f7c6006b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e1223f2c22771df1fbe94ebec4b0141"><td class="memTemplParams" colspan="2"><a id="a2e1223f2c22771df1fbe94ebec4b0141"></a>
template&lt;class Matrix , class Vector &gt; </td></tr>
<tr class="memitem:a2e1223f2c22771df1fbe94ebec4b0141"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="struct_lin_box_1_1_vector.html">Vector</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_lin_box.html#a2e1223f2c22771df1fbe94ebec4b0141">solve</a> (<a class="el" href="struct_lin_box_1_1_vector.html">Vector</a> &amp;x, const <a class="el" href="class_lin_box_1_1_blas_matrix.html">Matrix</a> &amp;A, const <a class="el" href="struct_lin_box_1_1_vector.html">Vector</a> &amp;b, const <a class="el" href="struct_lin_box_1_1_ring_categories_1_1_modular_tag.html">RingCategories::ModularTag</a> &amp;tag, const Method::DenseElimination &amp;m)</td></tr>
<tr class="memdesc:a2e1223f2c22771df1fbe94ebec4b0141"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solve specialisation for DenseElimination. <br /></td></tr>
<tr class="separator:a2e1223f2c22771df1fbe94ebec4b0141"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a556a3d68c7580bcc039c99ad5296545e"><td class="memTemplParams" colspan="2"><a id="a556a3d68c7580bcc039c99ad5296545e"></a>
template&lt;class Field , class Vector &gt; </td></tr>
<tr class="memitem:a556a3d68c7580bcc039c99ad5296545e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="struct_lin_box_1_1_vector.html">Vector</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_lin_box.html#a556a3d68c7580bcc039c99ad5296545e">solve</a> (<a class="el" href="struct_lin_box_1_1_vector.html">Vector</a> &amp;x, const <a class="el" href="class_lin_box_1_1_blas_matrix.html">DenseMatrix</a>&lt; Field &gt; &amp;A, const <a class="el" href="struct_lin_box_1_1_vector.html">Vector</a> &amp;b, const <a class="el" href="struct_lin_box_1_1_ring_categories_1_1_modular_tag.html">RingCategories::ModularTag</a> &amp;tag, const Method::DenseElimination &amp;m)</td></tr>
<tr class="memdesc:a556a3d68c7580bcc039c99ad5296545e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solve specialisation for DenseElimination on dense matrices with ModularTag. <br /></td></tr>
<tr class="separator:a556a3d68c7580bcc039c99ad5296545e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1434cca471d79069b41b9504671e1e7"><td class="memTemplParams" colspan="2"><a id="ad1434cca471d79069b41b9504671e1e7"></a>
template&lt;class IntVector , class Blackbox , class Vector &gt; </td></tr>
<tr class="memitem:ad1434cca471d79069b41b9504671e1e7"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_lin_box.html#ad1434cca471d79069b41b9504671e1e7">solve</a> (IntVector &amp;xNum, typename IntVector::Element &amp;xDen, const Blackbox &amp;A, const <a class="el" href="struct_lin_box_1_1_vector.html">Vector</a> &amp;b, const <a class="el" href="struct_lin_box_1_1_ring_categories_1_1_integer_tag.html">RingCategories::IntegerTag</a> &amp;tag, const Method::Dixon &amp;m)</td></tr>
<tr class="memdesc:ad1434cca471d79069b41b9504671e1e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solve specialisation for Dixon on blackboxes matrices. <br /></td></tr>
<tr class="separator:ad1434cca471d79069b41b9504671e1e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a701adb5ced583c36fbb0c1199182beff"><td class="memTemplParams" colspan="2"><a id="a701adb5ced583c36fbb0c1199182beff"></a>
template&lt;class IntVector , class Ring , class Vector &gt; </td></tr>
<tr class="memitem:a701adb5ced583c36fbb0c1199182beff"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_lin_box.html#a701adb5ced583c36fbb0c1199182beff">solve</a> (IntVector &amp;xNum, typename IntVector::Element &amp;xDen, const <a class="el" href="class_lin_box_1_1_blas_matrix.html">DenseMatrix</a>&lt; Ring &gt; &amp;A, const <a class="el" href="struct_lin_box_1_1_vector.html">Vector</a> &amp;b, const <a class="el" href="struct_lin_box_1_1_ring_categories_1_1_integer_tag.html">RingCategories::IntegerTag</a> &amp;tag, const Method::Dixon &amp;m)</td></tr>
<tr class="memdesc:a701adb5ced583c36fbb0c1199182beff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solve specialisation for Dixon on dense matrices. <br /></td></tr>
<tr class="separator:a701adb5ced583c36fbb0c1199182beff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fbd7dd6a6dd86d98fe5dc88b9566bcc"><td class="memTemplParams" colspan="2"><a id="a3fbd7dd6a6dd86d98fe5dc88b9566bcc"></a>
template&lt;class IntVector , class... MatrixArgs, class Vector &gt; </td></tr>
<tr class="memitem:a3fbd7dd6a6dd86d98fe5dc88b9566bcc"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_lin_box.html#a3fbd7dd6a6dd86d98fe5dc88b9566bcc">solve</a> (IntVector &amp;xNum, typename IntVector::Element &amp;xDen, const SparseMatrix&lt; MatrixArgs... &gt; &amp;A, const <a class="el" href="struct_lin_box_1_1_vector.html">Vector</a> &amp;b, const <a class="el" href="struct_lin_box_1_1_ring_categories_1_1_integer_tag.html">RingCategories::IntegerTag</a> &amp;tag, const Method::Dixon &amp;m)</td></tr>
<tr class="memdesc:a3fbd7dd6a6dd86d98fe5dc88b9566bcc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solve specialisation for Dixon on sparse matrices. <br /></td></tr>
<tr class="separator:a3fbd7dd6a6dd86d98fe5dc88b9566bcc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70201f71b66d40fde99f9bb1905d8987"><td class="memTemplParams" colspan="2"><a id="a70201f71b66d40fde99f9bb1905d8987"></a>
template&lt;class Matrix , class Vector , class CategoryTag &gt; </td></tr>
<tr class="memitem:a70201f71b66d40fde99f9bb1905d8987"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="struct_lin_box_1_1_vector.html">Vector</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_lin_box.html#a70201f71b66d40fde99f9bb1905d8987">solve</a> (<a class="el" href="struct_lin_box_1_1_vector.html">Vector</a> &amp;x, const <a class="el" href="class_lin_box_1_1_blas_matrix.html">Matrix</a> &amp;A, const <a class="el" href="struct_lin_box_1_1_vector.html">Vector</a> &amp;b, const CategoryTag &amp;tag, const Method::Elimination &amp;m)</td></tr>
<tr class="memdesc:a70201f71b66d40fde99f9bb1905d8987"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solve specialisation for Elimination. <br /></td></tr>
<tr class="separator:a70201f71b66d40fde99f9bb1905d8987"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8e8ceca9a7a6157219c802085a0a86e"><td class="memTemplParams" colspan="2"><a id="ad8e8ceca9a7a6157219c802085a0a86e"></a>
template&lt;class MatrixField , class Vector , class CategoryTag &gt; </td></tr>
<tr class="memitem:ad8e8ceca9a7a6157219c802085a0a86e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="struct_lin_box_1_1_vector.html">Vector</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_lin_box.html#ad8e8ceca9a7a6157219c802085a0a86e">solve</a> (<a class="el" href="struct_lin_box_1_1_vector.html">Vector</a> &amp;x, const <a class="el" href="class_lin_box_1_1_blas_matrix.html">DenseMatrix</a>&lt; MatrixField &gt; &amp;A, const <a class="el" href="struct_lin_box_1_1_vector.html">Vector</a> &amp;b, const CategoryTag &amp;tag, const Method::Elimination &amp;m)</td></tr>
<tr class="memdesc:ad8e8ceca9a7a6157219c802085a0a86e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solve specialisation for Elimination with DenseMatrix. <br /></td></tr>
<tr class="separator:ad8e8ceca9a7a6157219c802085a0a86e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bc8980a349703fafb272c15978f97e2"><td class="memTemplParams" colspan="2"><a id="a3bc8980a349703fafb272c15978f97e2"></a>
template&lt;class MatrixField , class Vector , class CategoryTag &gt; </td></tr>
<tr class="memitem:a3bc8980a349703fafb272c15978f97e2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="struct_lin_box_1_1_vector.html">Vector</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_lin_box.html#a3bc8980a349703fafb272c15978f97e2">solve</a> (<a class="el" href="struct_lin_box_1_1_vector.html">Vector</a> &amp;x, const SparseMatrix&lt; MatrixField &gt; &amp;A, const <a class="el" href="struct_lin_box_1_1_vector.html">Vector</a> &amp;b, const CategoryTag &amp;tag, const Method::Elimination &amp;m)</td></tr>
<tr class="memdesc:a3bc8980a349703fafb272c15978f97e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solve specialisation for Elimination with SparseMatrix. <br /></td></tr>
<tr class="separator:a3bc8980a349703fafb272c15978f97e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd5c06373b5b636d1f29fbce975c74ff"><td class="memTemplParams" colspan="2"><a id="afd5c06373b5b636d1f29fbce975c74ff"></a>
template&lt;class Matrix , class Vector , class CategoryTag &gt; </td></tr>
<tr class="memitem:afd5c06373b5b636d1f29fbce975c74ff"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="struct_lin_box_1_1_vector.html">Vector</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_lin_box.html#afd5c06373b5b636d1f29fbce975c74ff">solveInPlace</a> (<a class="el" href="struct_lin_box_1_1_vector.html">Vector</a> &amp;x, <a class="el" href="class_lin_box_1_1_blas_matrix.html">Matrix</a> &amp;A, const <a class="el" href="struct_lin_box_1_1_vector.html">Vector</a> &amp;b, const CategoryTag &amp;tag, const Method::Elimination &amp;m)</td></tr>
<tr class="memdesc:afd5c06373b5b636d1f29fbce975c74ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solve in place specialisation for Elimination. <br /></td></tr>
<tr class="separator:afd5c06373b5b636d1f29fbce975c74ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e499b6473902fbd55ffefe1d595d6f7"><td class="memTemplParams" colspan="2"><a id="a0e499b6473902fbd55ffefe1d595d6f7"></a>
template&lt;class MatrixField , class Vector , class CategoryTag &gt; </td></tr>
<tr class="memitem:a0e499b6473902fbd55ffefe1d595d6f7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="struct_lin_box_1_1_vector.html">Vector</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_lin_box.html#a0e499b6473902fbd55ffefe1d595d6f7">solveInPlace</a> (<a class="el" href="struct_lin_box_1_1_vector.html">Vector</a> &amp;x, <a class="el" href="class_lin_box_1_1_blas_matrix.html">DenseMatrix</a>&lt; MatrixField &gt; &amp;A, const <a class="el" href="struct_lin_box_1_1_vector.html">Vector</a> &amp;b, const CategoryTag &amp;tag, const Method::Elimination &amp;m)</td></tr>
<tr class="memdesc:a0e499b6473902fbd55ffefe1d595d6f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solve in place specialisation for Elimination with DenseMatrix. <br /></td></tr>
<tr class="separator:a0e499b6473902fbd55ffefe1d595d6f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb90bd801832fcf21fdd3dbce291da3e"><td class="memTemplParams" colspan="2"><a id="abb90bd801832fcf21fdd3dbce291da3e"></a>
template&lt;class MatrixField , class Vector , class CategoryTag &gt; </td></tr>
<tr class="memitem:abb90bd801832fcf21fdd3dbce291da3e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="struct_lin_box_1_1_vector.html">Vector</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_lin_box.html#abb90bd801832fcf21fdd3dbce291da3e">solveInPlace</a> (<a class="el" href="struct_lin_box_1_1_vector.html">Vector</a> &amp;x, SparseMatrix&lt; MatrixField &gt; &amp;A, const <a class="el" href="struct_lin_box_1_1_vector.html">Vector</a> &amp;b, const CategoryTag &amp;tag, const Method::Elimination &amp;m)</td></tr>
<tr class="memdesc:abb90bd801832fcf21fdd3dbce291da3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solve in place specialisation for Elimination with SparseMatrix. <br /></td></tr>
<tr class="separator:abb90bd801832fcf21fdd3dbce291da3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a675aee1ed7201b25b223c48f6217e2ac"><td class="memTemplParams" colspan="2"><a id="a675aee1ed7201b25b223c48f6217e2ac"></a>
template&lt;class Matrix , class Vector , class CategoryTag &gt; </td></tr>
<tr class="memitem:a675aee1ed7201b25b223c48f6217e2ac"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="struct_lin_box_1_1_vector.html">Vector</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_lin_box.html#a675aee1ed7201b25b223c48f6217e2ac">solve</a> (<a class="el" href="struct_lin_box_1_1_vector.html">Vector</a> &amp;x, const <a class="el" href="class_lin_box_1_1_blas_matrix.html">Matrix</a> &amp;A, const <a class="el" href="struct_lin_box_1_1_vector.html">Vector</a> &amp;b, const CategoryTag &amp;tag, const Method::Lanczos &amp;m)</td></tr>
<tr class="memdesc:a675aee1ed7201b25b223c48f6217e2ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solve specialisation for Lanczos. <br /></td></tr>
<tr class="separator:a675aee1ed7201b25b223c48f6217e2ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5972ec86fe6ab497fb2af6b8434fe630"><td class="memTemplParams" colspan="2"><a id="a5972ec86fe6ab497fb2af6b8434fe630"></a>
template&lt;class Matrix , class Vector &gt; </td></tr>
<tr class="memitem:a5972ec86fe6ab497fb2af6b8434fe630"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="struct_lin_box_1_1_vector.html">Vector</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_lin_box.html#a5972ec86fe6ab497fb2af6b8434fe630">solve</a> (<a class="el" href="struct_lin_box_1_1_vector.html">Vector</a> &amp;x, const <a class="el" href="class_lin_box_1_1_blas_matrix.html">Matrix</a> &amp;A, const <a class="el" href="struct_lin_box_1_1_vector.html">Vector</a> &amp;b, const <a class="el" href="struct_lin_box_1_1_ring_categories_1_1_modular_tag.html">RingCategories::ModularTag</a> &amp;tag, const Method::Lanczos &amp;m)</td></tr>
<tr class="memdesc:a5972ec86fe6ab497fb2af6b8434fe630"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solve specialisation for Lanczos with ModularTag. <br /></td></tr>
<tr class="separator:a5972ec86fe6ab497fb2af6b8434fe630"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a171507966153a380857ae74e8ab11171"><td class="memTemplParams" colspan="2"><a id="a171507966153a380857ae74e8ab11171"></a>
template&lt;class Matrix , class Vector , class CategoryTag &gt; </td></tr>
<tr class="memitem:a171507966153a380857ae74e8ab11171"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="struct_lin_box_1_1_vector.html">Vector</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_lin_box.html#a171507966153a380857ae74e8ab11171">solve</a> (<a class="el" href="struct_lin_box_1_1_vector.html">Vector</a> &amp;x, const <a class="el" href="class_lin_box_1_1_blas_matrix.html">Matrix</a> &amp;A, const <a class="el" href="struct_lin_box_1_1_vector.html">Vector</a> &amp;b, const CategoryTag &amp;tag, const Method::BlockLanczos &amp;m)</td></tr>
<tr class="memdesc:a171507966153a380857ae74e8ab11171"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solve specialisation for BlockLanczos. <br /></td></tr>
<tr class="separator:a171507966153a380857ae74e8ab11171"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab74a2e159f5f3af68da011970f0f6ffb"><td class="memTemplParams" colspan="2"><a id="ab74a2e159f5f3af68da011970f0f6ffb"></a>
template&lt;class Matrix , class Vector &gt; </td></tr>
<tr class="memitem:ab74a2e159f5f3af68da011970f0f6ffb"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="struct_lin_box_1_1_vector.html">Vector</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_lin_box.html#ab74a2e159f5f3af68da011970f0f6ffb">solve</a> (<a class="el" href="struct_lin_box_1_1_vector.html">Vector</a> &amp;x, const <a class="el" href="class_lin_box_1_1_blas_matrix.html">Matrix</a> &amp;A, const <a class="el" href="struct_lin_box_1_1_vector.html">Vector</a> &amp;b, const <a class="el" href="struct_lin_box_1_1_ring_categories_1_1_modular_tag.html">RingCategories::ModularTag</a> &amp;tag, const Method::BlockLanczos &amp;m)</td></tr>
<tr class="memdesc:ab74a2e159f5f3af68da011970f0f6ffb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solve specialisation for BlockLanczos with ModularTag. <br /></td></tr>
<tr class="separator:ab74a2e159f5f3af68da011970f0f6ffb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7f17836fbf06dc3fa8e54f2add0ea70"><td class="memTemplParams" colspan="2"><a id="ae7f17836fbf06dc3fa8e54f2add0ea70"></a>
template&lt;class IntVector , class Ring , class Vector &gt; </td></tr>
<tr class="memitem:ae7f17836fbf06dc3fa8e54f2add0ea70"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_lin_box.html#ae7f17836fbf06dc3fa8e54f2add0ea70">solve</a> (IntVector &amp;xNum, typename IntVector::Element &amp;xDen, const <a class="el" href="class_lin_box_1_1_blas_matrix.html">DenseMatrix</a>&lt; Ring &gt; &amp;A, const <a class="el" href="struct_lin_box_1_1_vector.html">Vector</a> &amp;b, const <a class="el" href="struct_lin_box_1_1_ring_categories_1_1_integer_tag.html">RingCategories::IntegerTag</a> &amp;tag, const Method::SymbolicNumericNorm &amp;m)</td></tr>
<tr class="memdesc:ae7f17836fbf06dc3fa8e54f2add0ea70"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solve specialisation for SymbolicNumericNorm with IntegerTag on DenseMatrix. <br /></td></tr>
<tr class="separator:ae7f17836fbf06dc3fa8e54f2add0ea70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a211372c814fe872b26aca9a6901fb04a"><td class="memTemplParams" colspan="2"><a id="a211372c814fe872b26aca9a6901fb04a"></a>
template&lt;class Matrix , class Vector &gt; </td></tr>
<tr class="memitem:a211372c814fe872b26aca9a6901fb04a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="struct_lin_box_1_1_vector.html">Vector</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_lin_box.html#a211372c814fe872b26aca9a6901fb04a">solve</a> (<a class="el" href="struct_lin_box_1_1_vector.html">Vector</a> &amp;x, const <a class="el" href="class_lin_box_1_1_blas_matrix.html">Matrix</a> &amp;A, const <a class="el" href="struct_lin_box_1_1_vector.html">Vector</a> &amp;b, const <a class="el" href="struct_lin_box_1_1_ring_categories_1_1_modular_tag.html">RingCategories::ModularTag</a> &amp;tag, const Method::SparseElimination &amp;m)</td></tr>
<tr class="memdesc:a211372c814fe872b26aca9a6901fb04a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solve specialisation for SparseElimination. <br /></td></tr>
<tr class="separator:a211372c814fe872b26aca9a6901fb04a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90d0fc144ba59e430468877491c09f07"><td class="memTemplParams" colspan="2"><a id="a90d0fc144ba59e430468877491c09f07"></a>
template&lt;class... MatrixArgs, class Vector &gt; </td></tr>
<tr class="memitem:a90d0fc144ba59e430468877491c09f07"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="struct_lin_box_1_1_vector.html">Vector</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_lin_box.html#a90d0fc144ba59e430468877491c09f07">solve</a> (<a class="el" href="struct_lin_box_1_1_vector.html">Vector</a> &amp;x, const SparseMatrix&lt; MatrixArgs... &gt; &amp;A, const <a class="el" href="struct_lin_box_1_1_vector.html">Vector</a> &amp;b, const <a class="el" href="struct_lin_box_1_1_ring_categories_1_1_modular_tag.html">RingCategories::ModularTag</a> &amp;tag, const Method::SparseElimination &amp;m)</td></tr>
<tr class="memdesc:a90d0fc144ba59e430468877491c09f07"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solve specialisation for SparseElimination with SparseMatrix. <br /></td></tr>
<tr class="separator:a90d0fc144ba59e430468877491c09f07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c1bf1fce52eecfd1b9c0f1b19227fc9"><td class="memTemplParams" colspan="2"><a id="a6c1bf1fce52eecfd1b9c0f1b19227fc9"></a>
template&lt;class... MatrixArgs, class Vector &gt; </td></tr>
<tr class="memitem:a6c1bf1fce52eecfd1b9c0f1b19227fc9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="struct_lin_box_1_1_vector.html">Vector</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_lin_box.html#a6c1bf1fce52eecfd1b9c0f1b19227fc9">solveInPlace</a> (<a class="el" href="struct_lin_box_1_1_vector.html">Vector</a> &amp;x, SparseMatrix&lt; MatrixArgs... &gt; &amp;A, const <a class="el" href="struct_lin_box_1_1_vector.html">Vector</a> &amp;b, const <a class="el" href="struct_lin_box_1_1_ring_categories_1_1_modular_tag.html">RingCategories::ModularTag</a> &amp;tag, const Method::SparseElimination &amp;m)</td></tr>
<tr class="memdesc:a6c1bf1fce52eecfd1b9c0f1b19227fc9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solve in place specialisation for SparseElimination with SparseMatrix. <br /></td></tr>
<tr class="separator:a6c1bf1fce52eecfd1b9c0f1b19227fc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6bdba3b1fe1b7a1b423ebab05d14a3f"><td class="memTemplParams" colspan="2"><a id="ad6bdba3b1fe1b7a1b423ebab05d14a3f"></a>
template&lt;class ResultVector , class Matrix , class Vector , class CategoryTag &gt; </td></tr>
<tr class="memitem:ad6bdba3b1fe1b7a1b423ebab05d14a3f"><td class="memTemplItemLeft" align="right" valign="top">ResultVector &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_lin_box.html#ad6bdba3b1fe1b7a1b423ebab05d14a3f">solve</a> (ResultVector &amp;x, const <a class="el" href="class_lin_box_1_1_blas_matrix.html">Matrix</a> &amp;A, const <a class="el" href="struct_lin_box_1_1_vector.html">Vector</a> &amp;b, const CategoryTag &amp;tag, const Method::Wiedemann &amp;m)</td></tr>
<tr class="memdesc:ad6bdba3b1fe1b7a1b423ebab05d14a3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solve specialisation for Wiedemann. <br /></td></tr>
<tr class="separator:ad6bdba3b1fe1b7a1b423ebab05d14a3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74b3fea0fba83efced5eaa7d9c60bff4"><td class="memTemplParams" colspan="2"><a id="a74b3fea0fba83efced5eaa7d9c60bff4"></a>
template&lt;class ResultVector , class Matrix , class Vector &gt; </td></tr>
<tr class="memitem:a74b3fea0fba83efced5eaa7d9c60bff4"><td class="memTemplItemLeft" align="right" valign="top">ResultVector &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_lin_box.html#a74b3fea0fba83efced5eaa7d9c60bff4">solve</a> (ResultVector &amp;x, const <a class="el" href="class_lin_box_1_1_blas_matrix.html">Matrix</a> &amp;A, const <a class="el" href="struct_lin_box_1_1_vector.html">Vector</a> &amp;b, const <a class="el" href="struct_lin_box_1_1_ring_categories_1_1_integer_tag.html">RingCategories::IntegerTag</a> &amp;tag, const Method::Wiedemann &amp;m)</td></tr>
<tr class="memdesc:a74b3fea0fba83efced5eaa7d9c60bff4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solve specialisation for Wiedemann with IntegerTag. <br /></td></tr>
<tr class="separator:a74b3fea0fba83efced5eaa7d9c60bff4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef7f9b92acf9f593f248e57e03314078"><td class="memTemplParams" colspan="2"><a id="aef7f9b92acf9f593f248e57e03314078"></a>
template&lt;class ResultVector , class Matrix , class Vector &gt; </td></tr>
<tr class="memitem:aef7f9b92acf9f593f248e57e03314078"><td class="memTemplItemLeft" align="right" valign="top">ResultVector &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_lin_box.html#aef7f9b92acf9f593f248e57e03314078">solve</a> (ResultVector &amp;x, const <a class="el" href="class_lin_box_1_1_blas_matrix.html">Matrix</a> &amp;A, const <a class="el" href="struct_lin_box_1_1_vector.html">Vector</a> &amp;b, const <a class="el" href="struct_lin_box_1_1_ring_categories_1_1_modular_tag.html">RingCategories::ModularTag</a> &amp;tag, const Method::Wiedemann &amp;m)</td></tr>
<tr class="memdesc:aef7f9b92acf9f593f248e57e03314078"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solve specialisation for Wiedemann with ModularTag. <br /></td></tr>
<tr class="separator:aef7f9b92acf9f593f248e57e03314078"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad493bac211b46d84928b49239f5439fb"><td class="memTemplParams" colspan="2"><a id="ad493bac211b46d84928b49239f5439fb"></a>
template&lt;class ResultVector , class Matrix , class Vector , class CategoryTag &gt; </td></tr>
<tr class="memitem:ad493bac211b46d84928b49239f5439fb"><td class="memTemplItemLeft" align="right" valign="top">ResultVector &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_lin_box.html#ad493bac211b46d84928b49239f5439fb">solve</a> (ResultVector &amp;x, const <a class="el" href="class_lin_box_1_1_blas_matrix.html">Matrix</a> &amp;A, const <a class="el" href="struct_lin_box_1_1_vector.html">Vector</a> &amp;b, const CategoryTag &amp;tag, const Method::BlockWiedemann &amp;m)</td></tr>
<tr class="memdesc:ad493bac211b46d84928b49239f5439fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solve specialisation for BlockWiedemann. <br /></td></tr>
<tr class="separator:ad493bac211b46d84928b49239f5439fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa37b5fc27bf2735c7f43e4cea7f3139a"><td class="memTemplParams" colspan="2"><a id="aa37b5fc27bf2735c7f43e4cea7f3139a"></a>
template&lt;class ResultVector , class Matrix , class Vector &gt; </td></tr>
<tr class="memitem:aa37b5fc27bf2735c7f43e4cea7f3139a"><td class="memTemplItemLeft" align="right" valign="top">ResultVector &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_lin_box.html#aa37b5fc27bf2735c7f43e4cea7f3139a">solve</a> (ResultVector &amp;x, const <a class="el" href="class_lin_box_1_1_blas_matrix.html">Matrix</a> &amp;A, const <a class="el" href="struct_lin_box_1_1_vector.html">Vector</a> &amp;b, const <a class="el" href="struct_lin_box_1_1_ring_categories_1_1_modular_tag.html">RingCategories::ModularTag</a> &amp;tag, const Method::BlockWiedemann &amp;m)</td></tr>
<tr class="memdesc:aa37b5fc27bf2735c7f43e4cea7f3139a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solve specialisation for BlockWiedemann with ModularTag. <br /></td></tr>
<tr class="separator:aa37b5fc27bf2735c7f43e4cea7f3139a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfcf4ec345fd00f9d7a954ee9b315be1"><td class="memTemplParams" colspan="2"><a id="acfcf4ec345fd00f9d7a954ee9b315be1"></a>
template&lt;class ResultVector , class Matrix , class Vector , class CategoryTag &gt; </td></tr>
<tr class="memitem:acfcf4ec345fd00f9d7a954ee9b315be1"><td class="memTemplItemLeft" align="right" valign="top">ResultVector &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_lin_box.html#acfcf4ec345fd00f9d7a954ee9b315be1">solve</a> (ResultVector &amp;x, const <a class="el" href="class_lin_box_1_1_blas_matrix.html">Matrix</a> &amp;A, const <a class="el" href="struct_lin_box_1_1_vector.html">Vector</a> &amp;b, const CategoryTag &amp;tag, const Method::Coppersmith &amp;m)</td></tr>
<tr class="memdesc:acfcf4ec345fd00f9d7a954ee9b315be1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solve specialisation for Coppersmith. <br /></td></tr>
<tr class="separator:acfcf4ec345fd00f9d7a954ee9b315be1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ac16f53afba17ebb6445d64380b26aa"><td class="memTemplParams" colspan="2"><a id="a1ac16f53afba17ebb6445d64380b26aa"></a>
template&lt;class ResultVector , class Matrix , class Vector &gt; </td></tr>
<tr class="memitem:a1ac16f53afba17ebb6445d64380b26aa"><td class="memTemplItemLeft" align="right" valign="top">ResultVector &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_lin_box.html#a1ac16f53afba17ebb6445d64380b26aa">solve</a> (ResultVector &amp;x, const <a class="el" href="class_lin_box_1_1_blas_matrix.html">Matrix</a> &amp;A, const <a class="el" href="struct_lin_box_1_1_vector.html">Vector</a> &amp;b, const <a class="el" href="struct_lin_box_1_1_ring_categories_1_1_modular_tag.html">RingCategories::ModularTag</a> &amp;tag, const Method::Coppersmith &amp;m)</td></tr>
<tr class="memdesc:a1ac16f53afba17ebb6445d64380b26aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solve specialisation for Coppersmith on ModularTag. <br /></td></tr>
<tr class="separator:a1ac16f53afba17ebb6445d64380b26aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb4c3ef55845dd94844fb9ebbf1176f6"><td class="memTemplParams" colspan="2">template&lt;class ResultVector , class Matrix , class Vector , class CategoryTag , class SolveMethod &gt; </td></tr>
<tr class="memitem:acb4c3ef55845dd94844fb9ebbf1176f6"><td class="memTemplItemLeft" align="right" valign="top">ResultVector &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_lin_box.html#acb4c3ef55845dd94844fb9ebbf1176f6">solve</a> (ResultVector &amp;x, const <a class="el" href="class_lin_box_1_1_blas_matrix.html">Matrix</a> &amp;A, const <a class="el" href="struct_lin_box_1_1_vector.html">Vector</a> &amp;b, const CategoryTag &amp;tag, const SolveMethod &amp;m)</td></tr>
<tr class="memdesc:acb4c3ef55845dd94844fb9ebbf1176f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solve Ax = b, for x.  <a href="#acb4c3ef55845dd94844fb9ebbf1176f6">More...</a><br /></td></tr>
<tr class="separator:acb4c3ef55845dd94844fb9ebbf1176f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae140ae227da6759f38f0e004f9d9088"><td class="memTemplParams" colspan="2"><a id="aae140ae227da6759f38f0e004f9d9088"></a>
template&lt;class ResultVector , class Matrix , class Vector , class SolveMethod &gt; </td></tr>
<tr class="memitem:aae140ae227da6759f38f0e004f9d9088"><td class="memTemplItemLeft" align="right" valign="top">ResultVector &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_lin_box.html#aae140ae227da6759f38f0e004f9d9088">solve</a> (ResultVector &amp;x, const <a class="el" href="class_lin_box_1_1_blas_matrix.html">Matrix</a> &amp;A, const <a class="el" href="struct_lin_box_1_1_vector.html">Vector</a> &amp;b, const SolveMethod &amp;m)</td></tr>
<tr class="memdesc:aae140ae227da6759f38f0e004f9d9088"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solve dispatcher for automated category tag. <br /></td></tr>
<tr class="separator:aae140ae227da6759f38f0e004f9d9088"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72e6db2584254b0363106b3c268cc4a1"><td class="memTemplParams" colspan="2"><a id="a72e6db2584254b0363106b3c268cc4a1"></a>
template&lt;class ResultVector , class Matrix , class Vector &gt; </td></tr>
<tr class="memitem:a72e6db2584254b0363106b3c268cc4a1"><td class="memTemplItemLeft" align="right" valign="top">ResultVector &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_lin_box.html#a72e6db2584254b0363106b3c268cc4a1">solve</a> (ResultVector &amp;x, const <a class="el" href="class_lin_box_1_1_blas_matrix.html">Matrix</a> &amp;A, const <a class="el" href="struct_lin_box_1_1_vector.html">Vector</a> &amp;b)</td></tr>
<tr class="memdesc:a72e6db2584254b0363106b3c268cc4a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solve dispatcher for automated solve method. <br /></td></tr>
<tr class="separator:a72e6db2584254b0363106b3c268cc4a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadf74f02cdd745a4ef1cf941ac03fc21"><td class="memTemplParams" colspan="2"><a id="aadf74f02cdd745a4ef1cf941ac03fc21"></a>
template&lt;class RatVector , class RatMatrix , class Vector , class SolveMethod &gt; </td></tr>
<tr class="memitem:aadf74f02cdd745a4ef1cf941ac03fc21"><td class="memTemplItemLeft" align="right" valign="top">RatVector &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_lin_box.html#aadf74f02cdd745a4ef1cf941ac03fc21">solve</a> (RatVector &amp;x, const RatMatrix &amp;A, const <a class="el" href="struct_lin_box_1_1_vector.html">Vector</a> &amp;b, const <a class="el" href="struct_lin_box_1_1_ring_categories_1_1_rational_tag.html">RingCategories::RationalTag</a> &amp;tag, const SolveMethod &amp;m)</td></tr>
<tr class="memdesc:aadf74f02cdd745a4ef1cf941ac03fc21"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solve specialisation on RationalTag, with a generic method. <br /></td></tr>
<tr class="separator:aadf74f02cdd745a4ef1cf941ac03fc21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01a1d41b722955549320a598abf33a87"><td class="memTemplParams" colspan="2">template&lt;class RatVector , class Matrix , class Vector , class SolveMethod &gt; </td></tr>
<tr class="memitem:a01a1d41b722955549320a598abf33a87"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; std::is_same&lt; typename SolveMethod::CategoryTag, <a class="el" href="struct_lin_box_1_1_ring_categories_1_1_integer_tag.html">RingCategories::IntegerTag</a> &gt;::value &amp;&amp;std::is_same&lt; typename <a class="el" href="struct_lin_box_1_1_field_traits.html">FieldTraits</a>&lt; typename RatVector::Field &gt;::categoryTag, <a class="el" href="struct_lin_box_1_1_ring_categories_1_1_rational_tag.html">RingCategories::RationalTag</a> &gt;::value, RatVector &amp; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_lin_box.html#a01a1d41b722955549320a598abf33a87">solve</a> (RatVector &amp;x, const <a class="el" href="class_lin_box_1_1_blas_matrix.html">Matrix</a> &amp;A, const <a class="el" href="struct_lin_box_1_1_vector.html">Vector</a> &amp;b, const <a class="el" href="struct_lin_box_1_1_ring_categories_1_1_integer_tag.html">RingCategories::IntegerTag</a> &amp;tag, const SolveMethod &amp;m)</td></tr>
<tr class="memdesc:a01a1d41b722955549320a598abf33a87"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solve specialisation on IntegerTag with Vector&lt;QField&gt; as result.  <a href="#a01a1d41b722955549320a598abf33a87">More...</a><br /></td></tr>
<tr class="separator:a01a1d41b722955549320a598abf33a87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76e80bbf7b3c4a7100e56f028a69d84d"><td class="memTemplParams" colspan="2">template&lt;class Matrix , class Vector , class SolveMethod &gt; </td></tr>
<tr class="memitem:a76e80bbf7b3c4a7100e56f028a69d84d"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; std::is_same&lt; typename SolveMethod::CategoryTag, <a class="el" href="struct_lin_box_1_1_ring_categories_1_1_integer_tag.html">RingCategories::IntegerTag</a> &gt;::value, <a class="el" href="class_lin_box_1_1_vector_fraction.html">VectorFraction</a>&lt; typename Matrix::Field &gt; &amp; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_lin_box.html#a76e80bbf7b3c4a7100e56f028a69d84d">solve</a> (<a class="el" href="class_lin_box_1_1_vector_fraction.html">VectorFraction</a>&lt; typename Matrix::Field &gt; &amp;x, const <a class="el" href="class_lin_box_1_1_blas_matrix.html">Matrix</a> &amp;A, const <a class="el" href="struct_lin_box_1_1_vector.html">Vector</a> &amp;b, const <a class="el" href="struct_lin_box_1_1_ring_categories_1_1_integer_tag.html">RingCategories::IntegerTag</a> &amp;tag, const SolveMethod &amp;m)</td></tr>
<tr class="memdesc:a76e80bbf7b3c4a7100e56f028a69d84d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solve specialisation on IntegerTag with <a class="el" href="class_lin_box_1_1_vector_fraction.html" title="VectorFraction&lt;Domain&gt; is a vector of rational elements with common reduced denominator. ">VectorFraction</a> as result.  <a href="#a76e80bbf7b3c4a7100e56f028a69d84d">More...</a><br /></td></tr>
<tr class="separator:a76e80bbf7b3c4a7100e56f028a69d84d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20225678db734c74e788a8fa33d11644"><td class="memTemplParams" colspan="2">template&lt;class IntVector , class Matrix , class Vector , class CategoryTag , class SolveMethod &gt; </td></tr>
<tr class="memitem:a20225678db734c74e788a8fa33d11644"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_lin_box.html#a20225678db734c74e788a8fa33d11644">solve</a> (IntVector &amp;xNum, typename IntVector::Element &amp;xDen, const <a class="el" href="class_lin_box_1_1_blas_matrix.html">Matrix</a> &amp;A, const <a class="el" href="struct_lin_box_1_1_vector.html">Vector</a> &amp;b, const CategoryTag &amp;tag, const SolveMethod &amp;m)</td></tr>
<tr class="memdesc:a20225678db734c74e788a8fa33d11644"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rational solve Ax = b, for x expressed as xNum/xDen.  <a href="#a20225678db734c74e788a8fa33d11644">More...</a><br /></td></tr>
<tr class="separator:a20225678db734c74e788a8fa33d11644"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa62ca38e82acca89736fc068e4cd6b24"><td class="memTemplParams" colspan="2"><a id="aa62ca38e82acca89736fc068e4cd6b24"></a>
template&lt;class IntVector , class Matrix , class Vector , class SolveMethod &gt; </td></tr>
<tr class="memitem:aa62ca38e82acca89736fc068e4cd6b24"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_lin_box.html#aa62ca38e82acca89736fc068e4cd6b24">solve</a> (IntVector &amp;xNum, typename IntVector::Element &amp;xDen, const <a class="el" href="class_lin_box_1_1_blas_matrix.html">Matrix</a> &amp;A, const <a class="el" href="struct_lin_box_1_1_vector.html">Vector</a> &amp;b, const <a class="el" href="struct_lin_box_1_1_ring_categories_1_1_integer_tag.html">RingCategories::IntegerTag</a> &amp;tag, const SolveMethod &amp;m)</td></tr>
<tr class="memdesc:aa62ca38e82acca89736fc068e4cd6b24"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rational solve dispatcher for unimplemented methods. <br /></td></tr>
<tr class="separator:aa62ca38e82acca89736fc068e4cd6b24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91d60b5024b6b76be115d4cd82cd5fa7"><td class="memTemplParams" colspan="2"><a id="a91d60b5024b6b76be115d4cd82cd5fa7"></a>
template&lt;class IntVector , class Matrix , class Vector , class SolveMethod &gt; </td></tr>
<tr class="memitem:a91d60b5024b6b76be115d4cd82cd5fa7"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_lin_box.html#a91d60b5024b6b76be115d4cd82cd5fa7">solve</a> (IntVector &amp;xNum, typename IntVector::Element &amp;xDen, const <a class="el" href="class_lin_box_1_1_blas_matrix.html">Matrix</a> &amp;A, const <a class="el" href="struct_lin_box_1_1_vector.html">Vector</a> &amp;b, const SolveMethod &amp;m)</td></tr>
<tr class="memdesc:a91d60b5024b6b76be115d4cd82cd5fa7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rational solve dispatcher for automated category tag. <br /></td></tr>
<tr class="separator:a91d60b5024b6b76be115d4cd82cd5fa7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9eec420544eab774371cd57173f69100"><td class="memTemplParams" colspan="2"><a id="a9eec420544eab774371cd57173f69100"></a>
template&lt;class IntVector , class Matrix , class Vector &gt; </td></tr>
<tr class="memitem:a9eec420544eab774371cd57173f69100"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_lin_box.html#a9eec420544eab774371cd57173f69100">solve</a> (IntVector &amp;xNum, typename IntVector::Element &amp;xDen, const <a class="el" href="class_lin_box_1_1_blas_matrix.html">Matrix</a> &amp;A, const <a class="el" href="struct_lin_box_1_1_vector.html">Vector</a> &amp;b)</td></tr>
<tr class="memdesc:a9eec420544eab774371cd57173f69100"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rational solve dispatcher for automated solve method. <br /></td></tr>
<tr class="separator:a9eec420544eab774371cd57173f69100"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a4e737227dd257eb14f8b963e68f921"><td class="memTemplParams" colspan="2">template&lt;class ResultVector , class Matrix , class Vector , class CategoryTag , class SolveMethod &gt; </td></tr>
<tr class="memitem:a6a4e737227dd257eb14f8b963e68f921"><td class="memTemplItemLeft" align="right" valign="top">ResultVector &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_lin_box.html#a6a4e737227dd257eb14f8b963e68f921">solveInPlace</a> (ResultVector &amp;x, <a class="el" href="class_lin_box_1_1_blas_matrix.html">Matrix</a> &amp;A, const <a class="el" href="struct_lin_box_1_1_vector.html">Vector</a> &amp;b, const CategoryTag &amp;tag, const SolveMethod &amp;m)</td></tr>
<tr class="memdesc:a6a4e737227dd257eb14f8b963e68f921"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solve Ax = b, for x.  <a href="#a6a4e737227dd257eb14f8b963e68f921">More...</a><br /></td></tr>
<tr class="separator:a6a4e737227dd257eb14f8b963e68f921"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71ab510b71df81b6b7a6ab8bd040c554"><td class="memTemplParams" colspan="2"><a id="a71ab510b71df81b6b7a6ab8bd040c554"></a>
template&lt;class ResultVector , class Matrix , class Vector , class SolveMethod &gt; </td></tr>
<tr class="memitem:a71ab510b71df81b6b7a6ab8bd040c554"><td class="memTemplItemLeft" align="right" valign="top">ResultVector &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_lin_box.html#a71ab510b71df81b6b7a6ab8bd040c554">solveInPlace</a> (ResultVector &amp;x, <a class="el" href="class_lin_box_1_1_blas_matrix.html">Matrix</a> &amp;A, const <a class="el" href="struct_lin_box_1_1_vector.html">Vector</a> &amp;b, const SolveMethod &amp;m)</td></tr>
<tr class="memdesc:a71ab510b71df81b6b7a6ab8bd040c554"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solve in place dispatcher for automated category tag. <br /></td></tr>
<tr class="separator:a71ab510b71df81b6b7a6ab8bd040c554"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1533f0dfbd0f7807dc08b25dcf6f43b1"><td class="memTemplParams" colspan="2"><a id="a1533f0dfbd0f7807dc08b25dcf6f43b1"></a>
template&lt;class ResultVector , class Matrix , class Vector &gt; </td></tr>
<tr class="memitem:a1533f0dfbd0f7807dc08b25dcf6f43b1"><td class="memTemplItemLeft" align="right" valign="top">ResultVector &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_lin_box.html#a1533f0dfbd0f7807dc08b25dcf6f43b1">solveInPlace</a> (ResultVector &amp;x, <a class="el" href="class_lin_box_1_1_blas_matrix.html">Matrix</a> &amp;A, const <a class="el" href="struct_lin_box_1_1_vector.html">Vector</a> &amp;b)</td></tr>
<tr class="memdesc:a1533f0dfbd0f7807dc08b25dcf6f43b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solve in place dispatcher for automated solve method. <br /></td></tr>
<tr class="separator:a1533f0dfbd0f7807dc08b25dcf6f43b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc5519b3a119f5bb31d5cf10d77fc9ca"><td class="memTemplParams" colspan="2">template&lt;class IntVector , class Matrix , class Vector , class SolveMethod , class CategoryTag &gt; </td></tr>
<tr class="memitem:acc5519b3a119f5bb31d5cf10d77fc9ca"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_lin_box.html#acc5519b3a119f5bb31d5cf10d77fc9ca">solveInPlace</a> (IntVector &amp;xNum, typename IntVector::Element &amp;xDen, <a class="el" href="class_lin_box_1_1_blas_matrix.html">Matrix</a> &amp;A, const <a class="el" href="struct_lin_box_1_1_vector.html">Vector</a> &amp;b, const CategoryTag &amp;tag, const SolveMethod &amp;m)</td></tr>
<tr class="memdesc:acc5519b3a119f5bb31d5cf10d77fc9ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rational solve in place Ax = b, for x expressed as xNum/xDen.  <a href="#acc5519b3a119f5bb31d5cf10d77fc9ca">More...</a><br /></td></tr>
<tr class="separator:acc5519b3a119f5bb31d5cf10d77fc9ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac690d6cb1af19b68f6692bc162338d3"><td class="memTemplParams" colspan="2"><a id="aac690d6cb1af19b68f6692bc162338d3"></a>
template&lt;class IntVector , class Matrix , class Vector , class SolveMethod &gt; </td></tr>
<tr class="memitem:aac690d6cb1af19b68f6692bc162338d3"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_lin_box.html#aac690d6cb1af19b68f6692bc162338d3">solveInPlace</a> (IntVector &amp;xNum, typename IntVector::Element &amp;xDen, <a class="el" href="class_lin_box_1_1_blas_matrix.html">Matrix</a> &amp;A, const <a class="el" href="struct_lin_box_1_1_vector.html">Vector</a> &amp;b, const SolveMethod &amp;m)</td></tr>
<tr class="memdesc:aac690d6cb1af19b68f6692bc162338d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rational solve in place dispatcher for automated category tag. <br /></td></tr>
<tr class="separator:aac690d6cb1af19b68f6692bc162338d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e1c04503af434809dadc30f23137c4e"><td class="memTemplParams" colspan="2"><a id="a8e1c04503af434809dadc30f23137c4e"></a>
template&lt;class IntVector , class Matrix , class Vector &gt; </td></tr>
<tr class="memitem:a8e1c04503af434809dadc30f23137c4e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_lin_box.html#a8e1c04503af434809dadc30f23137c4e">solveInPlace</a> (IntVector &amp;xNum, typename IntVector::Element &amp;xDen, <a class="el" href="class_lin_box_1_1_blas_matrix.html">Matrix</a> &amp;A, const <a class="el" href="struct_lin_box_1_1_vector.html">Vector</a> &amp;b)</td></tr>
<tr class="memdesc:a8e1c04503af434809dadc30f23137c4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rational solve in place dispatcher for automated solve method. <br /></td></tr>
<tr class="separator:a8e1c04503af434809dadc30f23137c4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ced65416a091fd0c44c02175bed2f51"><td class="memTemplParams" colspan="2">template&lt;class BB &gt; </td></tr>
<tr class="memitem:a3ced65416a091fd0c44c02175bed2f51"><td class="memTemplItemLeft" align="right" valign="top">BB::Field::Element &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_lin_box.html#a3ced65416a091fd0c44c02175bed2f51">trace</a> (typename BB::Field::Element &amp;t, const BB &amp;A)</td></tr>
<tr class="memdesc:a3ced65416a091fd0c44c02175bed2f51"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_lin_box_1_1_sum.html" title="blackbox of a matrix sum without copying. ">Sum</a> of the eigenvalues.  <a href="#a3ced65416a091fd0c44c02175bed2f51">More...</a><br /></td></tr>
<tr class="separator:a3ced65416a091fd0c44c02175bed2f51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2e2b7150bd78ae61406d8768554abd14"><td class="memTemplParams" colspan="2">template&lt;class Blackbox , class MyMethod &gt; </td></tr>
<tr class="memitem:ga2e2b7150bd78ae61406d8768554abd14"><td class="memTemplItemLeft" align="right" valign="top">Blackbox::Field::Element &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__solutions.html#ga2e2b7150bd78ae61406d8768554abd14">valence</a> (typename Blackbox::Field::Element &amp;v, const Blackbox &amp;A, const MyMethod &amp;M)</td></tr>
<tr class="memdesc:ga2e2b7150bd78ae61406d8768554abd14"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the valence of A.  <a href="group__solutions.html#ga2e2b7150bd78ae61406d8768554abd14">More...</a><br /></td></tr>
<tr class="separator:ga2e2b7150bd78ae61406d8768554abd14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28045aed95ca616b2a22d3735ed94a61"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_lin_box.html#a28045aed95ca616b2a22d3735ed94a61">serialize</a> (std::vector&lt; uint8_t &gt; &amp;bytes, const Integer &amp;<a class="el" href="group__integers.html#ga69460c665a80daebb395e45f6f76db54">integer</a>)</td></tr>
<tr class="memdesc:a28045aed95ca616b2a22d3735ed94a61"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serializes an Integer with its underlying __mpz_struct.  <a href="#a28045aed95ca616b2a22d3735ed94a61">More...</a><br /></td></tr>
<tr class="separator:a28045aed95ca616b2a22d3735ed94a61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a082561d13dbb7bc68995d794dbbdd4ab"><td class="memItemLeft" align="right" valign="top"><a id="a082561d13dbb7bc68995d794dbbdd4ab"></a>
uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_lin_box.html#a082561d13dbb7bc68995d794dbbdd4ab">unserialize</a> (Integer &amp;<a class="el" href="group__integers.html#ga69460c665a80daebb395e45f6f76db54">integer</a>, const std::vector&lt; uint8_t &gt; &amp;bytes, uint64_t offset=0u)</td></tr>
<tr class="memdesc:a082561d13dbb7bc68995d794dbbdd4ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unserializes an Integer. <br /></td></tr>
<tr class="separator:a082561d13dbb7bc68995d794dbbdd4ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9d0885b4f7d1b52c9f8c92ab0ee97e5"><td class="memTemplParams" colspan="2">template&lt;class Field &gt; </td></tr>
<tr class="memitem:ad9d0885b4f7d1b52c9f8c92ab0ee97e5"><td class="memTemplItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_lin_box.html#ad9d0885b4f7d1b52c9f8c92ab0ee97e5">serialize</a> (std::vector&lt; uint8_t &gt; &amp;bytes, const <a class="el" href="class_lin_box_1_1_blas_matrix.html">BlasMatrix</a>&lt; Field &gt; &amp;M)</td></tr>
<tr class="memdesc:ad9d0885b4f7d1b52c9f8c92ab0ee97e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serializes a <a class="el" href="class_lin_box_1_1_blas_matrix.html" title="Dense matrix representation. ">BlasMatrix</a>.  <a href="#ad9d0885b4f7d1b52c9f8c92ab0ee97e5">More...</a><br /></td></tr>
<tr class="separator:ad9d0885b4f7d1b52c9f8c92ab0ee97e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afba64cc7de557f49ea53b96822a564e5"><td class="memTemplParams" colspan="2">template&lt;class Field &gt; </td></tr>
<tr class="memitem:afba64cc7de557f49ea53b96822a564e5"><td class="memTemplItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_lin_box.html#afba64cc7de557f49ea53b96822a564e5">unserialize</a> (<a class="el" href="class_lin_box_1_1_blas_matrix.html">BlasMatrix</a>&lt; Field &gt; &amp;M, const std::vector&lt; uint8_t &gt; &amp;bytes, uint64_t offset=0u)</td></tr>
<tr class="memdesc:afba64cc7de557f49ea53b96822a564e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unserializes a <a class="el" href="class_lin_box_1_1_blas_matrix.html" title="Dense matrix representation. ">BlasMatrix</a>.  <a href="#afba64cc7de557f49ea53b96822a564e5">More...</a><br /></td></tr>
<tr class="separator:afba64cc7de557f49ea53b96822a564e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cce41cacef3e6c938610c6e08f7f16d"><td class="memTemplParams" colspan="2">template&lt;class Field &gt; </td></tr>
<tr class="memitem:a9cce41cacef3e6c938610c6e08f7f16d"><td class="memTemplItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_lin_box.html#a9cce41cacef3e6c938610c6e08f7f16d">serialize</a> (std::vector&lt; uint8_t &gt; &amp;bytes, const SparseMatrix&lt; Field &gt; &amp;M)</td></tr>
<tr class="memdesc:a9cce41cacef3e6c938610c6e08f7f16d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serializes a SparseMatrix.  <a href="#a9cce41cacef3e6c938610c6e08f7f16d">More...</a><br /></td></tr>
<tr class="separator:a9cce41cacef3e6c938610c6e08f7f16d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad36e13d307b3553f5ad1650272f1ace0"><td class="memTemplParams" colspan="2">template&lt;class Field &gt; </td></tr>
<tr class="memitem:ad36e13d307b3553f5ad1650272f1ace0"><td class="memTemplItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_lin_box.html#ad36e13d307b3553f5ad1650272f1ace0">unserialize</a> (SparseMatrix&lt; Field &gt; &amp;M, const std::vector&lt; uint8_t &gt; &amp;bytes, uint64_t offset=0u)</td></tr>
<tr class="memdesc:ad36e13d307b3553f5ad1650272f1ace0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unserializes a SparseMatrix.  <a href="#ad36e13d307b3553f5ad1650272f1ace0">More...</a><br /></td></tr>
<tr class="separator:ad36e13d307b3553f5ad1650272f1ace0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a884340c246e258561d0eda1b287c9589"><td class="memTemplParams" colspan="2">template&lt;class Field &gt; </td></tr>
<tr class="memitem:a884340c246e258561d0eda1b287c9589"><td class="memTemplItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_lin_box.html#a884340c246e258561d0eda1b287c9589">serialize</a> (std::vector&lt; uint8_t &gt; &amp;bytes, const BlasVector&lt; Field &gt; &amp;V)</td></tr>
<tr class="memdesc:a884340c246e258561d0eda1b287c9589"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serializes a BlasVector.  <a href="#a884340c246e258561d0eda1b287c9589">More...</a><br /></td></tr>
<tr class="separator:a884340c246e258561d0eda1b287c9589"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac337ae125ffe1c3f657d695aea18eba0"><td class="memTemplParams" colspan="2">template&lt;class Field &gt; </td></tr>
<tr class="memitem:ac337ae125ffe1c3f657d695aea18eba0"><td class="memTemplItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_lin_box.html#ac337ae125ffe1c3f657d695aea18eba0">unserialize</a> (BlasVector&lt; Field &gt; &amp;V, const std::vector&lt; uint8_t &gt; &amp;bytes, uint64_t offset=0u)</td></tr>
<tr class="memdesc:ac337ae125ffe1c3f657d695aea18eba0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unserializes a BlasVector.  <a href="#ac337ae125ffe1c3f657d695aea18eba0">More...</a><br /></td></tr>
<tr class="separator:ac337ae125ffe1c3f657d695aea18eba0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67c56eddd0b0f458ece2563d529f4a79"><td class="memTemplParams" colspan="2"><a id="a67c56eddd0b0f458ece2563d529f4a79"></a>
template&lt;class Field &gt; </td></tr>
<tr class="memitem:a67c56eddd0b0f458ece2563d529f4a79"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_lin_box.html#a67c56eddd0b0f458ece2563d529f4a79">writeMMComment</a> (std::ostream &amp;os, Field &amp;F, std::string name, std::string comment)</td></tr>
<tr class="memdesc:a67c56eddd0b0f458ece2563d529f4a79"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write second line and comment part of matrix market header. <br /></td></tr>
<tr class="separator:a67c56eddd0b0f458ece2563d529f4a79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46a2cb287f10c65eab0db90e5f2dcf90"><td class="memTemplParams" colspan="2"><a id="a46a2cb287f10c65eab0db90e5f2dcf90"></a>
template&lt;class BB &gt; </td></tr>
<tr class="memitem:a46a2cb287f10c65eab0db90e5f2dcf90"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_lin_box.html#a46a2cb287f10c65eab0db90e5f2dcf90">writeMMCoordHeader</a> (std::ostream &amp;os, BB &amp;A, size_t nnz, std::string name, std::string comment=&quot;&quot;)</td></tr>
<tr class="memdesc:a46a2cb287f10c65eab0db90e5f2dcf90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write matrix market header (up to the i,j,val lines) for a sparse or structured matrix. <br /></td></tr>
<tr class="separator:a46a2cb287f10c65eab0db90e5f2dcf90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b10b4a292dca8402901228a0a96f9d3"><td class="memTemplParams" colspan="2"><a id="a3b10b4a292dca8402901228a0a96f9d3"></a>
template&lt;class BB &gt; </td></tr>
<tr class="memitem:a3b10b4a292dca8402901228a0a96f9d3"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_lin_box.html#a3b10b4a292dca8402901228a0a96f9d3">writeMMPatternHeader</a> (std::ostream &amp;os, BB &amp;A, size_t nnz, std::string name, std::string comment=&quot;&quot;)</td></tr>
<tr class="memdesc:a3b10b4a292dca8402901228a0a96f9d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write matrix market header (up to the i,j lines) for a {0,1} sparse or structured matrix. <br /></td></tr>
<tr class="separator:a3b10b4a292dca8402901228a0a96f9d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d2734ce4cdafd1d7a2a80253bb6813e"><td class="memTemplParams" colspan="2"><a id="a9d2734ce4cdafd1d7a2a80253bb6813e"></a>
template&lt;class BB &gt; </td></tr>
<tr class="memitem:a9d2734ce4cdafd1d7a2a80253bb6813e"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_lin_box.html#a9d2734ce4cdafd1d7a2a80253bb6813e">writeMMArrayHeader</a> (std::ostream &amp;os, BB &amp;A, std::string name, std::string comment=&quot;&quot;)</td></tr>
<tr class="memdesc:a9d2734ce4cdafd1d7a2a80253bb6813e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write matrix market header (up to the entry lines) for a dense matrix. <br /></td></tr>
<tr class="separator:a9d2734ce4cdafd1d7a2a80253bb6813e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c3e339c072b891ecbe3a72b73dc66a9"><td class="memTemplParams" colspan="2"><a id="a7c3e339c072b891ecbe3a72b73dc66a9"></a>
template&lt;class Mat &gt; </td></tr>
<tr class="memitem:a7c3e339c072b891ecbe3a72b73dc66a9"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_lin_box.html#a7c3e339c072b891ecbe3a72b73dc66a9">writeMMArray</a> (std::ostream &amp;os, <a class="el" href="class_lin_box_1_1_blas_matrix.html">Mat</a> &amp;A, std::string name, std::string comment=&quot;&quot;)</td></tr>
<tr class="memdesc:a7c3e339c072b891ecbe3a72b73dc66a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic dense matrix writer to matrix market array format (col major). <br /></td></tr>
<tr class="separator:a7c3e339c072b891ecbe3a72b73dc66a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0dd03b56beaaa7a098e7cfa828f9e985"><td class="memItemLeft" align="right" valign="top"><a id="a0dd03b56beaaa7a098e7cfa828f9e985"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_lin_box.html#a0dd03b56beaaa7a098e7cfa828f9e985">eltype</a> (float x)</td></tr>
<tr class="memdesc:a0dd03b56beaaa7a098e7cfa828f9e985"><td class="mdescLeft">&#160;</td><td class="mdescRight">eltype(x) returns a string containing the name of the type of field or ring element x. <br /></td></tr>
<tr class="separator:a0dd03b56beaaa7a098e7cfa828f9e985"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a514dd1ffda0862fabad1d998b911ef56"><td class="memTemplParams" colspan="2">template&lt;class Field , class Vector &gt; </td></tr>
<tr class="memitem:a514dd1ffda0862fabad1d998b911ef56"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="struct_lin_box_1_1_vector.html">Vector</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_lin_box.html#a514dd1ffda0862fabad1d998b911ef56">randomVector</a> (Field &amp;F, size_t n, typename Field::RandIter &amp;r)</td></tr>
<tr class="memdesc:a514dd1ffda0862fabad1d998b911ef56"><td class="mdescLeft">&#160;</td><td class="mdescRight">Random vector generator This templated function takes a field and a random field element generator and returns a vector of random field elements.  <a href="#a514dd1ffda0862fabad1d998b911ef56">More...</a><br /></td></tr>
<tr class="separator:a514dd1ffda0862fabad1d998b911ef56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bba68c5446a212c6540fe0348c95ac3"><td class="memTemplParams" colspan="2">template&lt;class Ring , class Matrix &gt; </td></tr>
<tr class="memitem:a3bba68c5446a212c6540fe0348c95ac3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_lin_box_1_1_blas_matrix.html">Matrix</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_lin_box.html#a3bba68c5446a212c6540fe0348c95ac3">randomAns</a> (const Ring &amp;R, <a class="el" href="class_lin_box_1_1_blas_matrix.html">Matrix</a> &amp;<a class="el" href="class_lin_box_1_1_blas_matrix.html">Mat</a>, size_t n, size_t epr)</td></tr>
<tr class="separator:a3bba68c5446a212c6540fe0348c95ac3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a261c9bbbb8f95a1dc0d670cd49d4fe0e"><td class="memItemLeft" align="right" valign="top">size_t &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_lin_box.html#a261c9bbbb8f95a1dc0d670cd49d4fe0e">RandIntInInt</a> (const size_t &amp;s, size_t &amp;RIII, const int &amp;seed=0)</td></tr>
<tr class="memdesc:a261c9bbbb8f95a1dc0d670cd49d4fe0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">gives a random number such that <img class="formulaInl" alt="$0 \leq RIII &lt; s$" src="form_72.png"/>.  <a href="#a261c9bbbb8f95a1dc0d670cd49d4fe0e">More...</a><br /></td></tr>
<tr class="separator:a261c9bbbb8f95a1dc0d670cd49d4fe0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72869b9c8cd5ed99887d9b8ab5017277"><td class="memItemLeft" align="right" valign="top"><a id="a72869b9c8cd5ed99887d9b8ab5017277"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_lin_box.html#a72869b9c8cd5ed99887d9b8ab5017277">RandomPermutation</a> (size_t *P, const size_t &amp;len)</td></tr>
<tr class="memdesc:a72869b9c8cd5ed99887d9b8ab5017277"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a random Lapack style Permutation <code>P</code> of size <code>len</code>. <br /></td></tr>
<tr class="separator:a72869b9c8cd5ed99887d9b8ab5017277"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50d39993dc790c4ce470225ddc42ed17"><td class="memTemplParams" colspan="2">template&lt;class Field &gt; </td></tr>
<tr class="memitem:a50d39993dc790c4ce470225ddc42ed17"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_lin_box.html#a50d39993dc790c4ce470225ddc42ed17">CheckRank</a> (const Field &amp;F, const typename Field ::Element *A, const size_t &amp;m, const size_t &amp;n, const size_t &amp;lda, const size_t &amp;alledged_rank)</td></tr>
<tr class="memdesc:a50d39993dc790c4ce470225ddc42ed17"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks we got the right rank.  <a href="#a50d39993dc790c4ce470225ddc42ed17">More...</a><br /></td></tr>
<tr class="separator:a50d39993dc790c4ce470225ddc42ed17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49e10d04e74cbcbc410062320862cd45"><td class="memTemplParams" colspan="2"><a id="a49e10d04e74cbcbc410062320862cd45"></a>
template&lt;class Field &gt; </td></tr>
<tr class="memitem:a49e10d04e74cbcbc410062320862cd45"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_lin_box.html#a49e10d04e74cbcbc410062320862cd45">RandomMatrixWithRank</a> (const Field &amp;F, typename Field ::Element *A, const size_t &amp;m, const size_t &amp;n, const size_t &amp;lda, const size_t &amp;<a class="el" href="group__solutions.html#gaf81b9dc67cedf2044133b59399dd2334">rank</a>)</td></tr>
<tr class="memdesc:a49e10d04e74cbcbc410062320862cd45"><td class="mdescLeft">&#160;</td><td class="mdescRight">Builds a <code>m</code> x <code>n</code> random matrix of rank <code>rank</code> over field <code>F</code>. <br /></td></tr>
<tr class="separator:a49e10d04e74cbcbc410062320862cd45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3804d7270e3982dc59cbf81f239bdcba"><td class="memTemplParams" colspan="2">template&lt;class Field &gt; </td></tr>
<tr class="memitem:a3804d7270e3982dc59cbf81f239bdcba"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_lin_box.html#a3804d7270e3982dc59cbf81f239bdcba">RandomMatrixWithDet</a> (const Field &amp;F, typename Field ::Element *A, const size_t &amp;m, const size_t &amp;lda, const typename Field ::Element &amp;<a class="el" href="group__solutions.html#ga017678ad2851590ad3335371136f1730">det</a>)</td></tr>
<tr class="memdesc:a3804d7270e3982dc59cbf81f239bdcba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Builds a <code>m</code> x <code>m</code> random matrix of determinant <code>det</code> over field <code>F</code>.  <a href="#a3804d7270e3982dc59cbf81f239bdcba">More...</a><br /></td></tr>
<tr class="separator:a3804d7270e3982dc59cbf81f239bdcba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf56754df11afb467f9af89f3a118f8b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_lin_box.html#acf56754df11afb467f9af89f3a118f8b">showAdvanceLinear</a> (size_t curr, size_t min, size_t max)</td></tr>
<tr class="memdesc:acf56754df11afb467f9af89f3a118f8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">show the advancement (on the terminal) suppose linear advancement  <a href="#acf56754df11afb467f9af89f3a118f8b">More...</a><br /></td></tr>
<tr class="separator:acf56754df11afb467f9af89f3a118f8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0581b070e8f0a28532f2732096b437cc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_lin_box.html#a0581b070e8f0a28532f2732096b437cc">showFinish</a> (size_t curr, size_t all)</td></tr>
<tr class="memdesc:a0581b070e8f0a28532f2732096b437cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">tells the current series of measure has completed (on the terminal)  <a href="#a0581b070e8f0a28532f2732096b437cc">More...</a><br /></td></tr>
<tr class="separator:a0581b070e8f0a28532f2732096b437cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9dfd12d40192113024a8365780c789d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_lin_box.html#ac9dfd12d40192113024a8365780c789d">showSkip</a> (size_t curr, size_t all)</td></tr>
<tr class="memdesc:ac9dfd12d40192113024a8365780c789d"><td class="mdescLeft">&#160;</td><td class="mdescRight">tells the current series of measure was skipped (on the terminal)  <a href="#ac9dfd12d40192113024a8365780c789d">More...</a><br /></td></tr>
<tr class="separator:ac9dfd12d40192113024a8365780c789d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1e7a4da3ef5a0d951a1ca333b994384"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_lin_box.html#ac1e7a4da3ef5a0d951a1ca333b994384">computeMFLOPS</a> (const double &amp;tim, const double mflo, const size_t rpt=1)</td></tr>
<tr class="memdesc:ac1e7a4da3ef5a0d951a1ca333b994384"><td class="mdescLeft">&#160;</td><td class="mdescRight">computes the number of megaflops.  <a href="#ac1e7a4da3ef5a0d951a1ca333b994384">More...</a><br /></td></tr>
<tr class="separator:ac1e7a4da3ef5a0d951a1ca333b994384"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a199e98d6fcea6afebf75c459a2e4ac3e"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_lin_box.html#a199e98d6fcea6afebf75c459a2e4ac3e">computeMFLOPS</a> (const <a class="el" href="namespace_lin_box.html#a94cbbcce791d72e74c60f9fbe3ad2921">dvector_t</a> &amp;tim, const double mflo, <a class="el" href="namespace_lin_box_1_1_tag.html#aeb30bde7bdea621040f3206487315cbf">Tag::TimeSelect</a> ts=Tag::TimeSelect::bestThree)</td></tr>
<tr class="memdesc:a199e98d6fcea6afebf75c459a2e4ac3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">computes the number of megaflops.  <a href="#a199e98d6fcea6afebf75c459a2e4ac3e">More...</a><br /></td></tr>
<tr class="separator:a199e98d6fcea6afebf75c459a2e4ac3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefbb240a3757623be97233836a133e55"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_lin_box.html#aefbb240a3757623be97233836a133e55">isDigit</a> (const std::string &amp;s)</td></tr>
<tr class="memdesc:aefbb240a3757623be97233836a133e55"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if a string is actually a double.  <a href="#aefbb240a3757623be97233836a133e55">More...</a><br /></td></tr>
<tr class="separator:aefbb240a3757623be97233836a133e55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb1fd9d5919759a9b794acae86d0bb4f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_lin_box.html#abb1fd9d5919759a9b794acae86d0bb4f">fortifiedString</a> (const std::string &amp;s)</td></tr>
<tr class="memdesc:abb1fd9d5919759a9b794acae86d0bb4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tells is a string has double quotes around.  <a href="#abb1fd9d5919759a9b794acae86d0bb4f">More...</a><br /></td></tr>
<tr class="separator:abb1fd9d5919759a9b794acae86d0bb4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a486320b0fb42371d8332a035c4c4850e"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_lin_box.html#a486320b0fb42371d8332a035c4c4850e">unfortifyString</a> (const std::string &amp;s)</td></tr>
<tr class="memdesc:a486320b0fb42371d8332a035c4c4850e"><td class="mdescLeft">&#160;</td><td class="mdescRight">removes the surrounding quotes.  <a href="#a486320b0fb42371d8332a035c4c4850e">More...</a><br /></td></tr>
<tr class="separator:a486320b0fb42371d8332a035c4c4850e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0553ed623696a5c6efee36bbe48d366f"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_lin_box.html#a0553ed623696a5c6efee36bbe48d366f">fortifyString</a> (const std::string &amp;s)</td></tr>
<tr class="memdesc:a0553ed623696a5c6efee36bbe48d366f"><td class="mdescLeft">&#160;</td><td class="mdescRight">adds surrounding quotes.  <a href="#a0553ed623696a5c6efee36bbe48d366f">More...</a><br /></td></tr>
<tr class="separator:a0553ed623696a5c6efee36bbe48d366f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a954446eb85941a79614cfe92fabc8150"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_lin_box.html#a954446eb85941a79614cfe92fabc8150">getDateTime</a> (const std::string &amp;sep)</td></tr>
<tr class="memdesc:a954446eb85941a79614cfe92fabc8150"><td class="mdescLeft">&#160;</td><td class="mdescRight">get ISO time and date  <a href="#a954446eb85941a79614cfe92fabc8150">More...</a><br /></td></tr>
<tr class="separator:a954446eb85941a79614cfe92fabc8150"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28ce971af884bab6bee881c74d378de7"><td class="memItemLeft" align="right" valign="top"><a id="a28ce971af884bab6bee881c74d378de7"></a>
smatrix_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_lin_box.html#a28ce971af884bab6bee881c74d378de7">getMachineInformation</a> ()</td></tr>
<tr class="memdesc:a28ce971af884bab6bee881c74d378de7"><td class="mdescLeft">&#160;</td><td class="mdescRight">get some machine information (not cpu yet) <br /></td></tr>
<tr class="separator:a28ce971af884bab6bee881c74d378de7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5508403b1a6849cfb70d8352501ffc14"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a5508403b1a6849cfb70d8352501ffc14"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_lin_box.html#a5508403b1a6849cfb70d8352501ffc14">toString</a> (T &amp;nam)</td></tr>
<tr class="memdesc:a5508403b1a6849cfb70d8352501ffc14"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts anything to a string.  <a href="#a5508403b1a6849cfb70d8352501ffc14">More...</a><br /></td></tr>
<tr class="separator:a5508403b1a6849cfb70d8352501ffc14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95b0accd738faf9e346b9b28e336eb28"><td class="memItemLeft" align="right" valign="top"><a id="a95b0accd738faf9e346b9b28e336eb28"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_lin_box.html#a95b0accd738faf9e346b9b28e336eb28">findKeyword</a> (size_t &amp;i, const svector_t::const_iterator &amp;begin, const svector_t::const_iterator &amp;end, const std::string &amp;keyword)</td></tr>
<tr class="memdesc:a95b0accd738faf9e346b9b28e336eb28"><td class="mdescLeft">&#160;</td><td class="mdescRight">finds keyword betwen begin and end, return true if found and i is the index where it is (possibly correspondig to end) <br /></td></tr>
<tr class="separator:a95b0accd738faf9e346b9b28e336eb28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68aa09907256b11d5397a635ad6946a9"><td class="memItemLeft" align="right" valign="top"><a id="a68aa09907256b11d5397a635ad6946a9"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_lin_box.html#a68aa09907256b11d5397a635ad6946a9">fit2</a> (const <a class="el" href="namespace_lin_box.html#a94cbbcce791d72e74c60f9fbe3ad2921">dvector_t</a> &amp;X, const <a class="el" href="namespace_lin_box.html#a94cbbcce791d72e74c60f9fbe3ad2921">dvector_t</a> &amp;Y, int n, double x)</td></tr>
<tr class="memdesc:a68aa09907256b11d5397a635ad6946a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">fit X[n-1,n],Y[n-1,n] and return evaluation at x. <br /></td></tr>
<tr class="separator:a68aa09907256b11d5397a635ad6946a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc8cf6ea54c07afd7b5da2bb31131fe2"><td class="memItemLeft" align="right" valign="top"><a id="adc8cf6ea54c07afd7b5da2bb31131fe2"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_lin_box.html#adc8cf6ea54c07afd7b5da2bb31131fe2">fit3</a> (const <a class="el" href="namespace_lin_box.html#a94cbbcce791d72e74c60f9fbe3ad2921">dvector_t</a> &amp;X, const <a class="el" href="namespace_lin_box.html#a94cbbcce791d72e74c60f9fbe3ad2921">dvector_t</a> &amp;Y, int n, double x)</td></tr>
<tr class="memdesc:adc8cf6ea54c07afd7b5da2bb31131fe2"><td class="mdescLeft">&#160;</td><td class="mdescRight">fit X[n-2,n],Y[n-2,n] and return evaluation at x. <br /></td></tr>
<tr class="separator:adc8cf6ea54c07afd7b5da2bb31131fe2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Butterfly</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="el" href="class_lin_box_1_1_butterfly.html" title="Switching Network based BlackBox Matrix. ">Butterfly</a> preconditioner and supporting function </p>
</div></td></tr>
<tr class="memitem:aa2828603a1fe51dc4608786f915f776b"><td class="memItemLeft" align="right" valign="top">std::vector&lt; bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_lin_box.html#aa2828603a1fe51dc4608786f915f776b">setButterfly</a> (const std::vector&lt; bool &gt; &amp;x, size_t j=0)</td></tr>
<tr class="memdesc:aa2828603a1fe51dc4608786f915f776b"><td class="mdescLeft">&#160;</td><td class="mdescRight">A function used with <a class="el" href="class_lin_box_1_1_butterfly.html" title="Switching Network based BlackBox Matrix. ">Butterfly</a> Blackbox Matrices.  <a href="#aa2828603a1fe51dc4608786f915f776b">More...</a><br /></td></tr>
<tr class="separator:aa2828603a1fe51dc4608786f915f776b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a8448cecf00f718531123ac12bbaa37fc"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a8448cecf00f718531123ac12bbaa37fc"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt;!std::is_unsigned&lt; T &gt;::value, bool &gt;::value&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_lin_box.html#a8448cecf00f718531123ac12bbaa37fc">isPositive</a> (const T &amp;t)</td></tr>
<tr class="memdesc:a8448cecf00f718531123ac12bbaa37fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Positiveness of an integer.  <a href="#a8448cecf00f718531123ac12bbaa37fc">More...</a><br /></td></tr>
<tr class="separator:a8448cecf00f718531123ac12bbaa37fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb87b8e2ee65bf902e3ef96cd60507af"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:acb87b8e2ee65bf902e3ef96cd60507af"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; std::is_unsigned&lt; T &gt;::value, bool &gt;::value&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_lin_box.html#acb87b8e2ee65bf902e3ef96cd60507af">isPositive</a> (const T &amp;t)</td></tr>
<tr class="memdesc:acb87b8e2ee65bf902e3ef96cd60507af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Positiveness of an integer.  <a href="#acb87b8e2ee65bf902e3ef96cd60507af">More...</a><br /></td></tr>
<tr class="separator:acb87b8e2ee65bf902e3ef96cd60507af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a619cc9f1310a1cb604d39eece6bbd08b"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a619cc9f1310a1cb604d39eece6bbd08b"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt;!std::is_unsigned&lt; T &gt;::value, bool &gt;::value&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_lin_box.html#a619cc9f1310a1cb604d39eece6bbd08b">isNegative</a> (const T &amp;t)</td></tr>
<tr class="memdesc:a619cc9f1310a1cb604d39eece6bbd08b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Positiveness of an integer.  <a href="#a619cc9f1310a1cb604d39eece6bbd08b">More...</a><br /></td></tr>
<tr class="separator:a619cc9f1310a1cb604d39eece6bbd08b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b2d50a6fb149226d1a75f1712a51484"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a1b2d50a6fb149226d1a75f1712a51484"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; std::is_unsigned&lt; T &gt;::value, bool &gt;::value&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_lin_box.html#a1b2d50a6fb149226d1a75f1712a51484">isNegative</a> (const T &amp;t)</td></tr>
<tr class="memdesc:a1b2d50a6fb149226d1a75f1712a51484"><td class="mdescLeft">&#160;</td><td class="mdescRight">Positiveness of an integer.  <a href="#a1b2d50a6fb149226d1a75f1712a51484">More...</a><br /></td></tr>
<tr class="separator:a1b2d50a6fb149226d1a75f1712a51484"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5efd3e8354ccf70dbbb16ce9d1466514"><td class="memTemplParams" colspan="2">template&lt;typename IntType &gt; </td></tr>
<tr class="memitem:a5efd3e8354ccf70dbbb16ce9d1466514"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_lin_box.html#a5efd3e8354ccf70dbbb16ce9d1466514">isOdd</a> (const IntType &amp;value)</td></tr>
<tr class="memdesc:a5efd3e8354ccf70dbbb16ce9d1466514"><td class="mdescLeft">&#160;</td><td class="mdescRight">Positiveness of an integer.  <a href="#a5efd3e8354ccf70dbbb16ce9d1466514">More...</a><br /></td></tr>
<tr class="separator:a5efd3e8354ccf70dbbb16ce9d1466514"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4af3cf75e62259d3c156fb37c120c503"><td class="memTemplParams" colspan="2">template&lt;typename IntType &gt; </td></tr>
<tr class="memitem:a4af3cf75e62259d3c156fb37c120c503"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_lin_box.html#a4af3cf75e62259d3c156fb37c120c503">isEven</a> (const IntType &amp;p)</td></tr>
<tr class="memdesc:a4af3cf75e62259d3c156fb37c120c503"><td class="mdescLeft">&#160;</td><td class="mdescRight">Positiveness of an integer.  <a href="#a4af3cf75e62259d3c156fb37c120c503">More...</a><br /></td></tr>
<tr class="separator:a4af3cf75e62259d3c156fb37c120c503"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Namespace in which all linbox code resides. </p>
<p>Provides way to serialize any kind of data, like matrices, vectors and Integer in a platform-independent way.</p>
<p>The matrix class <a class="el" href="class_lin_box_1_1_sliced.html" title="The Sliced Matrix class _Domain must be a GF(3) rep, BaseT must be an unsigned int type...">Sliced</a> is defined.</p>
<dl class="bug"><dt><b><a class="el" href="bug.html#_bug000007">Bug:</a></b></dt><dd>it is dangerous to include matrices defs that include hom for their rebind... </dd></dl>
<p>The subdirectories of <code>linbox/</code> contain the template source code for all the <a class="el" href="namespace_lin_box.html" title="Namespace in which all linbox code resides. ">LinBox</a> functionality. See the <a href="modules.html">Modules</a> list for the documentation of the main parts of linbox.</p>
<dl class="section warning"><dt>Warning</dt><dd>The timer comes from Givaro and lives in its anonymous namespace.</dd></dl>
<dl class="bug"><dt><b><a class="el" href="bug.html#_bug000034">Bug:</a></b></dt><dd>those are not just traits: </dd></dl>
<dl class="bug"><dt><b><a class="el" href="bug.html#_bug000036">Bug:</a></b></dt><dd>this does not belong here. </dd></dl>
<p>It adheres to the <a class="el" href="namespace_lin_box.html" title="Namespace in which all linbox code resides. ">LinBox</a> dense matrix interface.</p>
<p>It depends on SlicedBase, also defined here, which packs GF(3) elements into a pair of ints. The int type is a template parameter.</p>
<p>Serialize functions add data to a prexisting vector of bytes, they return the number of bytes written. Unserialize ones read a vector of bytes starting at a specific offset, the number of bytes read.</p>
<p>As a convention, all numbers are written little-endian.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000081">Todo:</a></b></dt><dd>GMP Integers can be configured with limbs of different sizes (32 or 64 bits), depending on the machine. We do not handle that right now, but storing info about their dimension might be a good idea, to at least emit a warning. </dd></dl>
</div><h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="aa01a95537fc86573cc753898e378253b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa01a95537fc86573cc753898e378253b">&#9670;&nbsp;</a></span>IterationResult</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespace_lin_box.html#aa01a95537fc86573cc753898e378253b">IterationResult</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return type for CRA iteration. </p>
<p>The function object passed to the <a class="el" href="struct_lin_box_1_1_chinese_remainder.html" title="No doc. ">ChineseRemainder</a> operators should return one of these values on each iteration. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="aa01a95537fc86573cc753898e378253ba2f453cfe638e57e27bb0c9512436111e"></a>CONTINUE&#160;</td><td class="fielddoc"><p>successful iteration; add to the result and keep going </p>
</td></tr>
<tr><td class="fieldname"><a id="aa01a95537fc86573cc753898e378253bab85df04e922fe1dd3c1f0692faeaacef"></a>SKIP&#160;</td><td class="fielddoc"><p>"bad prime"; ignore this result and keep going </p>
</td></tr>
<tr><td class="fieldname"><a id="aa01a95537fc86573cc753898e378253ba1104c54a9ec6549e4ef9562b687596fb"></a>RESTART&#160;</td><td class="fielddoc"><p>all previous iterations were bad; start over with this residue </p>
</td></tr>
</table>

</div>
</div>
<a id="ac48d19db31bc6518994e9a0e2aafbe55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac48d19db31bc6518994e9a0e2aafbe55">&#9670;&nbsp;</a></span>Singularity</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespace_lin_box.html#ac48d19db31bc6518994e9a0e2aafbe55">Singularity</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Singularity of the system. </p>
<p>Only meaningful if the matrix is square. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ac48d19db31bc6518994e9a0e2aafbe55a88183b946cc5f0e8c96b2e66e1c74a7e"></a>Unknown&#160;</td><td class="fielddoc"><p>We don't know yet, or the matrix is not square. </p>
</td></tr>
<tr><td class="fieldname"><a id="ac48d19db31bc6518994e9a0e2aafbe55ad8d948ef62e0cd4caec19ca9c0e29438"></a>Singular&#160;</td><td class="fielddoc"><p>The matrix is non-invertible. </p>
</td></tr>
<tr><td class="fieldname"><a id="ac48d19db31bc6518994e9a0e2aafbe55a2f8ab52628435cfcfbf74aa206b84c54"></a>NonSingular&#160;</td><td class="fielddoc"><p>The matrix is invertible. </p>
</td></tr>
</table>

</div>
</div>
<a id="a10235377a5d8fe76c611f71b195cb97e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10235377a5d8fe76c611f71b195cb97e">&#9670;&nbsp;</a></span>Dispatch</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespace_lin_box.html#a10235377a5d8fe76c611f71b195cb97e">Dispatch</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>For integer-based methods that evaluate multiple times the system at different moduli, decides how to dispatch each sub-computations. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a10235377a5d8fe76c611f71b195cb97ea06b9281e396db002010bde1de57262eb"></a>Auto&#160;</td><td class="fielddoc"><p>Let implementation decide what to use. </p>
</td></tr>
<tr><td class="fieldname"><a id="a10235377a5d8fe76c611f71b195cb97eaa7e82daa7280af25afbaa076ac16eb1e"></a>Sequential&#160;</td><td class="fielddoc"><p>All sub-computations are done sequentially. </p>
</td></tr>
<tr><td class="fieldname"><a id="a10235377a5d8fe76c611f71b195cb97eaedb3c4d18c4d80ab94156b7df8669c17"></a>SMP&#160;</td><td class="fielddoc"><p>Use symmetric multiprocessing (Paladin) to do sub-computations. </p>
</td></tr>
<tr><td class="fieldname"><a id="a10235377a5d8fe76c611f71b195cb97ea8c16cbebef45d87fd2b36ce69f46c526"></a>Distributed&#160;</td><td class="fielddoc"><p>Use MPI to distribute sub-computations accross nodes. </p>
</td></tr>
<tr><td class="fieldname"><a id="a10235377a5d8fe76c611f71b195cb97ea55f4b4a94111759e08b3acb1acd12b8c"></a>Combined&#160;</td><td class="fielddoc"><p>Use MPI then Paladin on each node. </p>
</td></tr>
</table>

</div>
</div>
<a id="a8bb2ba2f883b980c7f099ff88780c979"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8bb2ba2f883b980c7f099ff88780c979">&#9670;&nbsp;</a></span>SingularSolutionType</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespace_lin_box.html#a8bb2ba2f883b980c7f099ff88780c979">SingularSolutionType</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>For Dixon method, which solution type to get when the system is singular. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a8bb2ba2f883b980c7f099ff88780c979ac172d0b7b7d4c61a931d50369d37b11f"></a>Deterministic&#160;</td><td class="fielddoc"><p>The solution should be the easiest to compute and always the same. </p>
</td></tr>
<tr><td class="fieldname"><a id="a8bb2ba2f883b980c7f099ff88780c979a64663f4646781c9c0110838b905daa23"></a>Random&#160;</td><td class="fielddoc"><p>The solution should be random and different at each call. </p>
</td></tr>
<tr><td class="fieldname"><a id="a8bb2ba2f883b980c7f099ff88780c979a66ce80e4c8c2f9e396a68443123e9a9b"></a>Diophantine&#160;</td><td class="fielddoc"><p>The solution is given over the integers. </p>
</td></tr>
</table>

</div>
</div>
<a id="adac1c2aa74e98e485c02f73279b71a38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adac1c2aa74e98e485c02f73279b71a38">&#9670;&nbsp;</a></span>Preconditioner</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespace_lin_box.html#adac1c2aa74e98e485c02f73279b71a38">Preconditioner</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Preconditioner to ensure generic rank profile. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="adac1c2aa74e98e485c02f73279b71a38a6adf97f83acf6453d4a6a4b1070f3754"></a>None&#160;</td><td class="fielddoc"><p>Do not use any preconditioner. </p>
</td></tr>
<tr><td class="fieldname"><a id="adac1c2aa74e98e485c02f73279b71a38a29ecfc45c7bd93061222062f86d4161d"></a>Butterfly&#160;</td><td class="fielddoc"><p>Use a butterfly network, see <a class="el" href="class_lin_box_1_1_butterfly.html">Butterfly</a>. </p>
</td></tr>
<tr><td class="fieldname"><a id="adac1c2aa74e98e485c02f73279b71a38a7407fb7e6a4df6392aaabd2368157312"></a>Sparse&#160;</td><td class="fielddoc"><p>Use a sparse preconditioner, c.f. </p>
<p>(Mulders 2000). </p>
</td></tr>
<tr><td class="fieldname"><a id="adac1c2aa74e98e485c02f73279b71a38a0997ef5d0d6bb91dd9f45c07f854cfc6"></a>Toeplitz&#160;</td><td class="fielddoc"><p>Use a <a class="el" href="class_lin_box_1_1_toeplitz.html" title="This is the blackbox representation of a Toeplitz matrix. ">Toeplitz</a> preconditioner, c.f. </p>
<p>(Kaltofen and Saunders 1991). </p>
</td></tr>
<tr><td class="fieldname"><a id="adac1c2aa74e98e485c02f73279b71a38aed6d39beb2a6a848f7a46781bee2a6d9"></a>Symmetrize&#160;</td><td class="fielddoc"><p>Use At A (Eberly and Kaltofen 1997). </p>
</td></tr>
<tr><td class="fieldname"><a id="adac1c2aa74e98e485c02f73279b71a38a969dc23d80808af65801199eb634693a"></a>PartialDiagonal&#160;</td><td class="fielddoc"><p>Use A D, where D is a random non-singular diagonal matrix (Eberly and Kaltofen 1997). </p>
</td></tr>
<tr><td class="fieldname"><a id="adac1c2aa74e98e485c02f73279b71a38ae0b27830bfdf7a0c6a232085ddd9fb69"></a>PartialDiagonalSymmetrize&#160;</td><td class="fielddoc"><p>Use At D A (Eberly and Kaltofen 1997). </p>
</td></tr>
<tr><td class="fieldname"><a id="adac1c2aa74e98e485c02f73279b71a38a8e5f43eeeda5a7d8b1d188981c45213b"></a>FullDiagonal&#160;</td><td class="fielddoc"><p>Use D1 At D2 A D1 (Eberly and Kaltofen 1997). </p>
</td></tr>
<tr><td class="fieldname"><a id="adac1c2aa74e98e485c02f73279b71a38a9a71a13863c84ba34fc41595fc2ee0c6"></a>Dense&#160;</td><td class="fielddoc"><p>Multiply ( or add?) by a random dense matrix (used by Dixon). </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="afd31751f8254901f546a014ff89ae8dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd31751f8254901f546a014ff89ae8dc">&#9670;&nbsp;</a></span>NullSpaceBasisIn() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t &amp; NullSpaceBasisIn </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespace_lin_box_1_1_tag.html#a9cb105f1dce242753103f15ee5e767a6">Tag::Side</a>&#160;</td>
          <td class="paramname"><em>Side</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_lin_box_1_1_blas_matrix.html">BlasMatrix</a>&lt; Field &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_lin_box_1_1_blas_matrix.html">BlasMatrix</a>&lt; Field &gt; &amp;&#160;</td>
          <td class="paramname"><em>Ker</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t &amp;&#160;</td>
          <td class="paramname"><em>kerdim</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Nullspace of a dense matrix on a finite field. </p>
<p>A is modified. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">F</td><td>field </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">Side</td><td><code>SideTag::Left</code> or <code>SideTag::Right</code> nullspace. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">A</td><td>Input matrix </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">Ker</td><td>Nullspace of the matrix (Allocated in the routine) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">kerdim</td><td>rank of the kernel </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>kerdim</code> </dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000008">Todo:</a></b></dt><dd>make it work for <a class="el" href="class_lin_box_1_1_blas_submatrix.html" title="Dense Submatrix representation. ">BlasSubmatrix</a> too </dd></dl>

</div>
</div>
<a id="a864a1c4b74c1472ee876af306a1a1c76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a864a1c4b74c1472ee876af306a1a1c76">&#9670;&nbsp;</a></span>NullSpaceBasisIn() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t &amp; NullSpaceBasisIn </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespace_lin_box_1_1_tag.html#a9cb105f1dce242753103f15ee5e767a6">Tag::Side</a>&#160;</td>
          <td class="paramname"><em>Side</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_lin_box_1_1_blas_submatrix.html">BlasSubmatrix</a>&lt; <a class="el" href="class_lin_box_1_1_dense_mat.html">DenseMat</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_lin_box_1_1_blas_matrix.html">BlasMatrix</a>&lt; typename DenseMat::Field &gt; &amp;&#160;</td>
          <td class="paramname"><em>Ker</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t &amp;&#160;</td>
          <td class="paramname"><em>kerdim</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000010">Todo:</a></b></dt><dd>uses too much memory </dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000011">Todo:</a></b></dt><dd>use copy </dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000011">Todo:</a></b></dt><dd>use copy </dd></dl>

</div>
</div>
<a id="a459cc873d0c9b59fd8206cb878d734e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a459cc873d0c9b59fd8206cb878d734e0">&#9670;&nbsp;</a></span>NullSpaceBasis()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t &amp; NullSpaceBasis </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespace_lin_box_1_1_tag.html#a9cb105f1dce242753103f15ee5e767a6">Tag::Side</a>&#160;</td>
          <td class="paramname"><em>Side</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_lin_box_1_1_blas_matrix.html">BlasMatrix</a>&lt; Field &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_lin_box_1_1_blas_matrix.html">BlasMatrix</a>&lt; Field &gt; &amp;&#160;</td>
          <td class="paramname"><em>Ker</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t &amp;&#160;</td>
          <td class="paramname"><em>kerdim</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Nullspace of a dense matrix on a finite field. </p>
<p>A is preserved. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">F</td><td>field </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">Side</td><td><code>SideTag::Left</code> or <code>SideTag::Right</code> nullspace. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">A</td><td>Input matrix </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">Ker</td><td>Nullspace of the matrix (Allocated in the routine) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">kerdim</td><td>rank of the kernel </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>kerdim</code> </dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000009">Todo:</a></b></dt><dd>make it work for <a class="el" href="class_lin_box_1_1_blas_submatrix.html" title="Dense Submatrix representation. ">BlasSubmatrix</a> too </dd></dl>

</div>
</div>
<a id="aff1c51aeaaf27483111a6e82abe344e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff1c51aeaaf27483111a6e82abe344e6">&#9670;&nbsp;</a></span>NullSpaceBasisIn() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t LinBox::NullSpaceBasisIn </td>
          <td>(</td>
          <td class="paramtype">const Field &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespace_lin_box_1_1_tag.html#a9cb105f1dce242753103f15ee5e767a6">Tag::Side</a>&#160;</td>
          <td class="paramname"><em>Side</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t &amp;&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename Field::Element *&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t &amp;&#160;</td>
          <td class="paramname"><em>lda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename Field::Element *&amp;&#160;</td>
          <td class="paramname"><em>Ker</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t &amp;&#160;</td>
          <td class="paramname"><em>ldk</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t &amp;&#160;</td>
          <td class="paramname"><em>kerdim</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the kernel of a dense matrix using <code>LQUP</code>. </p>
<p>Acccording to the dimensions of the input matrix, we chose different methods. </p><dl class="section warning"><dt>Warning</dt><dd>timings may vary and these choices were made on an experimental basis.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">F</td><td>Field </td></tr>
    <tr><td class="paramname">Side</td><td>left or right from <code>LinBox::SideTag</code> </td></tr>
    <tr><td class="paramname">m</td><td>rows </td></tr>
    <tr><td class="paramname">n</td><td>cols </td></tr>
    <tr><td class="paramname">A</td><td>input matrix </td></tr>
    <tr><td class="paramname">lda</td><td>leading dimension of A </td></tr>
    <tr><td class="paramname">Ker</td><td>Kernel. <code>NULL</code> if <code>kerdim==0</code> </td></tr>
    <tr><td class="paramname">ldk</td><td>leading dimension of the kernel. </td></tr>
    <tr><td class="paramname">kerdim</td><td>dimension of the kernel. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>dimension of the kernel.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>A is modified. </dd></dl>

</div>
</div>
<a id="ad4da40968c90f38c6f0c0f5a0a9d7478"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4da40968c90f38c6f0c0f5a0a9d7478">&#9670;&nbsp;</a></span>partial_hegcd()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool partial_hegcd </td>
          <td>(</td>
          <td class="paramtype">Ring &amp;&#160;</td>
          <td class="paramname"><em>Z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename Ring::Element &amp;&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename Ring::Element &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename Ring::Element &amp;&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename Ring::Element &amp;&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename Ring::Element &amp;&#160;</td>
          <td class="paramname"><em>denBound</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="namespace_lin_box.html#ad4da40968c90f38c6f0c0f5a0a9d7478" title="partial_hegcd() sets e, b from the remainder sequence of n,d. ">partial_hegcd()</a> sets e, b from the remainder sequence of n,d. </p>
<p>It requires positive n and d. It sets e to the first r_i (remainder) and b to the corresponding q_i (coefficient of n) such that 2r_i &lt; |q_i| and |q_i| &lt;= B (the given denominator bound). True is returned iff such e, b exist.</p>
<p>If not, b is the largest q_i such that |q_i| &lt;= B, and e is the corresponding remainder. In this case b is the denominator of a plausibly approximated but not well approximated rational. It can be used speculatively. </p>

</div>
</div>
<a id="a291ce9ee1caffc6a62e86e773e943cae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a291ce9ee1caffc6a62e86e773e943cae">&#9670;&nbsp;</a></span>dyadicToRational()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int LinBox::dyadicToRational </td>
          <td>(</td>
          <td class="paramtype">const Ring &amp;&#160;</td>
          <td class="paramname"><em>Z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename Ring::Element &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename Ring::Element &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename Ring::Element &amp;&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename Ring::Element &amp;&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename Ring::Element &amp;&#160;</td>
          <td class="paramname"><em>B</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Rational reconstruction of a/b from n/d with denominator bound B. </p>
<p>We give a/b, the continued fraction approximant of n/d that satisfies |a/b - n/d| &lt; 1/2d (well approximated) and 0 &lt; b &lt;= B. Return value is 0, if no such approximant exists. Return value is 1, if either (i) a second well approximated rational with denominator bounded by B may exist, or (ii) the well approximated condition is not met for a/b. In these cases, a/b may be used speculatively. Return value is 2, if the approximant is guaranteed (because bB &lt;= d).</p>
<p>If no fraction is well approximated the last b &lt;= B in the remainder sequence of n,d is given.</p>
<p>If d = 2^k and n = sum_i=l to k n_i 2^i, then * n/d = sum_{i=l down to 0} n_i/2^{k-i} is a {<em>dyadic</em> rational}. Numbers of this form are produced for example by numeric-symbolic iterations.</p>
<p>If it is known that n/d is the most accurate approximation with denominator d to a/b, and that the denominator b is bounded by B, i.e. b &lt;= B, then such a/b is uniquely determined, provided d &gt;= bB. ...in that case, such a/b is returned by <a class="el" href="namespace_lin_box.html#a291ce9ee1caffc6a62e86e773e943cae" title="Rational reconstruction of a/b from n/d with denominator bound B. ">dyadicToRational()</a>. This follows from two facts: First, by definition, n/d is an accurate approximation to a/b with b &lt;= d when |n/d - a/b| &lt; 1/2d. Otherwise (n-1)/d or (n+1)/d would be a better approximation. Second, if a/b and a'/b' are distinct rationals, then |a/b - a'/b'| &gt;= 1/bb'. Thus if a'/b' is another rational accurately approximated by n/d, we have 1/bb' &lt;= |a/b - a'/b'| &lt;= |a/b - n/d| + |n/d - a'/b'| &lt;= 1/2d + 1/2d = 1/d. So bb' &gt; d &gt;= bB, thus b' &gt; B.</p>
<p>In summary: If it exists, the unique a/b is given such that n/d approximates a/b to within 1/2d and b &lt;= B. Otherwise a plausible a/b is given or failure is signaled.</p>
<p>"Symbolic-Numeric Exact Rational Linear System Solver" by Saunders, Wood, Youse. describes the construction. </p>

</div>
</div>
<a id="a34c6fa70e417caf67f6ae08942d4a4c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34c6fa70e417caf67f6ae08942d4a4c0">&#9670;&nbsp;</a></span>checkBlasPrime()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool LinBox::checkBlasPrime </td>
          <td>(</td>
          <td class="paramtype">const Prime&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>NO DOC ! </p>
<dl class="bug"><dt><b><a class="el" href="bug.html#_bug000012">Bug:</a></b></dt><dd>why is this hard coded ? </dd></dl>

</div>
</div>
<a id="ad3cc295b1c4afedee8007e8d17d9315a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3cc295b1c4afedee8007e8d17d9315a">&#9670;&nbsp;</a></span>create_MatrixQadic()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void create_MatrixQadic </td>
          <td>(</td>
          <td class="paramtype">const Domain &amp;&#160;</td>
          <td class="paramname"><em>D</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const IMatrix &amp;&#160;</td>
          <td class="paramname"><em>Mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>chunks</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>num_chunks</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__integers.html#ga69460c665a80daebb395e45f6f76db54">integer</a>&#160;</td>
          <td class="paramname"><em>shift</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>split an integer matrix into a padic chunk representation </p>

</div>
</div>
<a id="a71dc6f175dd9ce18d05876d4df55f9ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71dc6f175dd9ce18d05876d4df55f9ae">&#9670;&nbsp;</a></span>create_VectorQadic()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LinBox::create_VectorQadic </td>
          <td>(</td>
          <td class="paramtype">const Domain &amp;&#160;</td>
          <td class="paramname"><em>D</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_lin_box_1_1_vector.html">Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>chunks</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>num_chunks</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>split an integer vector into a padic chunk representation </p>

</div>
</div>
<a id="a6ddbba67773a02edfc666b3aa7bd2d9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ddbba67773a02edfc666b3aa7bd2d9c">&#9670;&nbsp;</a></span>create_VectorQadic_32()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LinBox::create_VectorQadic_32 </td>
          <td>(</td>
          <td class="paramtype">const Domain &amp;&#160;</td>
          <td class="paramname"><em>D</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_lin_box_1_1_vector.html">Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>chunks</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>num_chunks</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>split an integer vector into a padic chunk representation </p>

</div>
</div>
<a id="aa2828603a1fe51dc4608786f915f776b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2828603a1fe51dc4608786f915f776b">&#9670;&nbsp;</a></span>setButterfly()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; bool &gt; setButterfly </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; bool &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>j</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A function used with <a class="el" href="class_lin_box_1_1_butterfly.html" title="Switching Network based BlackBox Matrix. ">Butterfly</a> Blackbox Matrices. </p>
<p>This function takes an STL vector x of booleans, and returns a vector y of booleans such that setting the switches marked by true flags in y to be on (or to swap elements) the true elements x will be switched to a given contiguous block through the use of a <a class="el" href="class_lin_box_1_1_butterfly.html" title="Switching Network based BlackBox Matrix. ">Butterfly</a> switching network. The integer parameter j marks where this block is to begin. If x has r true elements, the <a class="el" href="class_lin_box_1_1_butterfly.html" title="Switching Network based BlackBox Matrix. ">Butterfly</a> switching network will place these elements in a contiguous block starting at j and ending at j + r - 1. Wrap around shall be considered to preserve contiguity. The value of j is defaulted to be zero, and it is only allowed to be non-zero is the size of x is a power of 2. </p><dl class="section return"><dt>Returns</dt><dd>vector of booleans for setting switches </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>vector of booleans marking elements to switch into contiguous block </td></tr>
    <tr><td class="paramname">j</td><td>offset of contiguous block </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a685681f5c16e22c4b3dbbedd3aa09f32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a685681f5c16e22c4b3dbbedd3aa09f32">&#9670;&nbsp;</a></span>naturallog()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double LinBox::naturallog </td>
          <td>(</td>
          <td class="paramtype">const Givaro::Integer &amp;&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Natural logarithm (ln). </p>
<p>log(2) being close to 0.69314718055994531 </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>integer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ln(a). </dd></dl>

</div>
</div>
<a id="a8448cecf00f718531123ac12bbaa37fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8448cecf00f718531123ac12bbaa37fc">&#9670;&nbsp;</a></span>isPositive() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;!std::is_unsigned&lt;T&gt;::value, bool&gt;::value LinBox::isPositive </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Positiveness of an integer. </p>
<p>Essentially usefull in debug mode to avoid compiler warnings about comparison always true for some unsigned type. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>integer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> iff <code>x&gt;=0</code>. </dd></dl>

</div>
</div>
<a id="acb87b8e2ee65bf902e3ef96cd60507af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb87b8e2ee65bf902e3ef96cd60507af">&#9670;&nbsp;</a></span>isPositive() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;std::is_unsigned&lt;T&gt;::value, bool&gt;::value LinBox::isPositive </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Positiveness of an integer. </p>
<p>Essentially usefull in debug mode to avoid compiler warnings about comparison always true for some unsigned type. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>integer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> iff <code>x&gt;=0</code>. </dd></dl>

</div>
</div>
<a id="a619cc9f1310a1cb604d39eece6bbd08b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a619cc9f1310a1cb604d39eece6bbd08b">&#9670;&nbsp;</a></span>isNegative() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;!std::is_unsigned&lt;T&gt;::value, bool&gt;::value LinBox::isNegative </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Positiveness of an integer. </p>
<p>Essentially usefull in debug mode to avoid compiler warnings about comparison always true for some unsigned type. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>integer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> iff <code>x&gt;=0</code>. </dd></dl>

</div>
</div>
<a id="a1b2d50a6fb149226d1a75f1712a51484"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b2d50a6fb149226d1a75f1712a51484">&#9670;&nbsp;</a></span>isNegative() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;std::is_unsigned&lt;T&gt;::value, bool&gt;::value LinBox::isNegative </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Positiveness of an integer. </p>
<p>Essentially usefull in debug mode to avoid compiler warnings about comparison always true for some unsigned type. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>integer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> iff <code>x&gt;=0</code>. </dd></dl>

</div>
</div>
<a id="a5efd3e8354ccf70dbbb16ce9d1466514"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5efd3e8354ccf70dbbb16ce9d1466514">&#9670;&nbsp;</a></span>isOdd()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool LinBox::isOdd </td>
          <td>(</td>
          <td class="paramtype">const IntType &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Positiveness of an integer. </p>
<p>Essentially usefull in debug mode to avoid compiler warnings about comparison always true for some unsigned type. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>integer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> iff <code>x&gt;=0</code>. </dd></dl>

</div>
</div>
<a id="a4af3cf75e62259d3c156fb37c120c503"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4af3cf75e62259d3c156fb37c120c503">&#9670;&nbsp;</a></span>isEven()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool LinBox::isEven </td>
          <td>(</td>
          <td class="paramtype">const IntType &amp;&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Positiveness of an integer. </p>
<p>Essentially usefull in debug mode to avoid compiler warnings about comparison always true for some unsigned type. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>integer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> iff <code>x&gt;=0</code>. </dd></dl>

</div>
</div>
<a id="a1532e1a9a6996527a47cdcda184e4972"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1532e1a9a6996527a47cdcda184e4972">&#9670;&nbsp;</a></span>operator<<() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; LinBox::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_lin_box_1_1_blas_matrix.html">BlasMatrix</a>&lt; _Field, _Storage &gt; &amp;&#160;</td>
          <td class="paramname"><em>Mat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write a matrix to a stream. </p>
<p>The <code>C++</code> way using <code>operator&lt;&lt; </code> </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">o</td><td>output stream </td></tr>
    <tr><td class="paramname">Mat</td><td>matrix to write. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a23bda014eb3e127b6d6e4853a937d92a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23bda014eb3e127b6d6e4853a937d92a">&#9670;&nbsp;</a></span>RandomBlasPermutation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RandomBlasPermutation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_lin_box_1_1_blas_permutation.html">BlasPermutation</a>&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>P</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000038">Todo:</a></b></dt><dd>To be factorized. </dd></dl>

</div>
</div>
<a id="adac36fcecbe6faa1f650365eaf2ada9e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adac36fcecbe6faa1f650365eaf2ada9e">&#9670;&nbsp;</a></span>operator<<() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; LinBox::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>o</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_lin_box_1_1_dense_mat.html">DenseMat</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>Mat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write a matrix to a stream. </p>
<p>The C++ way using <code>operator&lt;&lt;</code> </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">o</td><td>output stream </td></tr>
    <tr><td class="paramname">Mat</td><td>matrix to write. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5dce21ab38ae1f7de0e6d8a96ab0b95d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5dce21ab38ae1f7de0e6d8a96ab0b95d">&#9670;&nbsp;</a></span>prepare()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_lin_box_1_1_vector.html">Vector</a>&amp; LinBox::prepare </td>
          <td>(</td>
          <td class="paramtype">const Field &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_lin_box_1_1_vector.html">Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename Field::Element &amp;&#160;</td>
          <td class="paramname"><em>a</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>y &lt;- ay. </p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000056">Todo:</a></b></dt><dd><a class="el" href="struct_lin_box_1_1_vector.html" title="Vector ?? ">Vector</a> knows Field </dd></dl>

</div>
</div>
<a id="a740a339db9f98fa431d9c35a2608bb74"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a740a339db9f98fa431d9c35a2608bb74">&#9670;&nbsp;</a></span>create_prime_sequence()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_lin_box_1_1_prime_sequence.html">PrimeSequence</a>&lt;typename Container::const_iterator&gt; LinBox::create_prime_sequence </td>
          <td>(</td>
          <td class="paramtype">const Container &amp;&#160;</td>
          <td class="paramname"><em>cont</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>convenience factory to create a <a class="el" href="class_lin_box_1_1_prime_sequence.html" title="Adaptor class to make a fixed-length sequence behave like a PrimeIterator. ">PrimeSequence</a> from an STL-like container. </p>

</div>
</div>
<a id="a10620e33be02e43a88f6bcab547b6d9b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10620e33be02e43a88f6bcab547b6d9b">&#9670;&nbsp;</a></span>charpoly() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Polynomial&amp; LinBox::charpoly </td>
          <td>(</td>
          <td class="paramtype">Polynomial &amp;&#160;</td>
          <td class="paramname"><em>P</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Blackbox &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MyMethod &amp;&#160;</td>
          <td class="paramname"><em>M</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>...using an optional <a class="el" href="struct_lin_box_1_1_method.html" title="Define which method to use when working on a system. ">Method</a> parameter </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">P</td><td>- the output characteristic polynomial. If the polynomial is of degree d, this random access container has size d+1, the 0-th entry is the constant coefficient and the d-th is 1 since the charpoly is monic. </td></tr>
    <tr><td class="paramname">A</td><td>- a blackbox matrix Optional </td></tr>
    <tr><td class="paramname">M</td><td>- the method object. Generally, the default object suffices and the algorithm used is determined by the class of M. Basic methods are Method::Blackbox, Method::Elimination, and <a class="el" href="namespace_lin_box.html#a10235377a5d8fe76c611f71b195cb97ea06b9281e396db002010bde1de57262eb" title="Let implementation decide what to use. ">Method::Auto</a> (the default). See methods.h for more options. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to P. </dd></dl>

</div>
</div>
<a id="a8a283f87fdb8f32c71024bbf3df97812"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a283f87fdb8f32c71024bbf3df97812">&#9670;&nbsp;</a></span>charpoly() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Polynomial&amp; LinBox::charpoly </td>
          <td>(</td>
          <td class="paramtype">Polynomial &amp;&#160;</td>
          <td class="paramname"><em>P</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Blackbox &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_lin_box_1_1_ring_categories_1_1_modular_tag.html">RingCategories::ModularTag</a> &amp;&#160;</td>
          <td class="paramname"><em>tag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Method::DenseElimination &amp;&#160;</td>
          <td class="paramname"><em>M</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the characteristic polynomial over <img class="formulaInl" alt="$\mathbf{Z}_p$" src="form_61.png"/>. </p>
<p>Compute the characteristic polynomial of a matrix using dense elimination methods</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">P</td><td>Polynomial where to store the result </td></tr>
    <tr><td class="paramname">A</td><td>Blackbox representing the matrix </td></tr>
    <tr><td class="paramname">tag</td><td></td></tr>
    <tr><td class="paramname">M</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a48263ffbcd961eb72f8999d17d1845b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48263ffbcd961eb72f8999d17d1845b6">&#9670;&nbsp;</a></span>charpoly() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Polynomial&amp; LinBox::charpoly </td>
          <td>(</td>
          <td class="paramtype">Polynomial &amp;&#160;</td>
          <td class="paramname"><em>P</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Blackbox &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_lin_box_1_1_ring_categories_1_1_modular_tag.html">RingCategories::ModularTag</a> &amp;&#160;</td>
          <td class="paramname"><em>tag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Method::Blackbox &amp;&#160;</td>
          <td class="paramname"><em>M</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the characteristic polynomial over <img class="formulaInl" alt="$\mathbf{Z}_p$" src="form_61.png"/>. </p>
<p>Compute the characteristic polynomial of a matrix, represented via a blackBox.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">P</td><td>Polynomial where to store the result </td></tr>
    <tr><td class="paramname">A</td><td>Blackbox representing the matrix </td></tr>
    <tr><td class="paramname">tag</td><td></td></tr>
    <tr><td class="paramname">M</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acdad6b9b36b03567629621cf8ab8df14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acdad6b9b36b03567629621cf8ab8df14">&#9670;&nbsp;</a></span>rowEchelon() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t LinBox::rowEchelon </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_lin_box_1_1_blas_matrix.html">Matrix</a> &amp;&#160;</td>
          <td class="paramname"><em>E</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_lin_box_1_1_blas_matrix.html">Matrix</a> &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const CategoryTag &amp;&#160;</td>
          <td class="paramname"><em>tag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const EchelonMethod &amp;&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the row echelon form of a matrix, not reduced. </p>
<p>Returns the row echelon form. The pivots are nonzero but not necessarily ones. The form is not reduced, which means that coefficients above each pivot are not necessarily zeros.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">E</td><td>the row echelon form </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">A</td><td>matrix </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tag</td><td>domain of computation </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">m</td><td>method to use (</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>solutions/method.h) </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>the rank of the matrix </dd></dl>

</div>
</div>
<a id="a8505c023af741d49d22daea8642987a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8505c023af741d49d22daea8642987a3">&#9670;&nbsp;</a></span>rowEchelon() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t LinBox::rowEchelon </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_lin_box_1_1_blas_matrix.html">Matrix</a> &amp;&#160;</td>
          <td class="paramname"><em>E</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_lin_box_1_1_blas_matrix.html">Matrix</a> &amp;&#160;</td>
          <td class="paramname"><em>T</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_lin_box_1_1_blas_matrix.html">Matrix</a> &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const CategoryTag &amp;&#160;</td>
          <td class="paramname"><em>tag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const EchelonMethod &amp;&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the row echelon form of a matrix, not reduced, and the related transformation matrix. </p>
<p>Returns the row echelon form E and a transformation matrix T such that T . A = E. The pivots are nonzero but not necessarily ones. The form is not reduced, which means that coefficients above each pivot are not necessarily zeros.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">E</td><td>the row echelon form </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">T</td><td>the transformation matrix </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">A</td><td>matrix </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tag</td><td>domain of computation </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">m</td><td>method to use (</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>solutions/method.h) </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>the rank of the matrix </dd></dl>

</div>
</div>
<a id="a7dae23c53eb662bed52e2560e1568e7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7dae23c53eb662bed52e2560e1568e7c">&#9670;&nbsp;</a></span>rowEchelonize() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t LinBox::rowEchelonize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_lin_box_1_1_blas_matrix.html">Matrix</a> &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const CategoryTag &amp;&#160;</td>
          <td class="paramname"><em>tag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const EchelonMethod &amp;&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Replace the input matrix by its row echelon form, not reduced. </p>
<p>The pivots are nonzero but not necessarily ones. The form is not reduced, which means that coefficients above each pivot are not necessarily zeros.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">[in/out]</td><td>A matrix </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tag</td><td>domain of computation </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">m</td><td>method to use (</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>solutions/method.h) </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>the rank of the matrix </dd></dl>

</div>
</div>
<a id="a16eb70498b2f34f8bb4ded0e1172bfa5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16eb70498b2f34f8bb4ded0e1172bfa5">&#9670;&nbsp;</a></span>rowEchelonize() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t LinBox::rowEchelonize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_lin_box_1_1_blas_matrix.html">Matrix</a> &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_lin_box_1_1_blas_matrix.html">Matrix</a> &amp;&#160;</td>
          <td class="paramname"><em>T</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const CategoryTag &amp;&#160;</td>
          <td class="paramname"><em>tag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const EchelonMethod &amp;&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the row echelon form of a matrix, not reduced, and the related transformation matrix. </p>
<p>Returns the row echelon form E and a transformation matrix T such that T . A = E. The input matrix is replaced by the row echelon form. The pivots are nonzero but not necessarily ones. The form is not reduced, which means that coefficients above each pivot are not necessarily zeros.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">[in/out]</td><td>A matrix </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">T</td><td>the transformation matrix </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tag</td><td>domain of computation </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">m</td><td>method to use (</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>solutions/method.h) </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>the rank of the matrix </dd></dl>

</div>
</div>
<a id="aaaf14c38b5a2a11b9c7bbe43e4f7f9f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaaf14c38b5a2a11b9c7bbe43e4f7f9f5">&#9670;&nbsp;</a></span>reducedRowEchelon() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t LinBox::reducedRowEchelon </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_lin_box_1_1_blas_matrix.html">Matrix</a> &amp;&#160;</td>
          <td class="paramname"><em>E</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_lin_box_1_1_blas_matrix.html">Matrix</a> &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const CategoryTag &amp;&#160;</td>
          <td class="paramname"><em>tag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const EchelonMethod &amp;&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the reduced row echelon form of a matrix. </p>
<p>Returns the reduced row echelon form. The pivots are ones. The form is reduced, which means that coefficients above each pivot are zeros.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">E</td><td>the reduced row echelon form </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">A</td><td>matrix </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tag</td><td>domain of computation </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">m</td><td>method to use (</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>solutions/method.h) </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>the rank of the matrix </dd></dl>

</div>
</div>
<a id="ae4e489547464dae2375dda0b2d321235"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4e489547464dae2375dda0b2d321235">&#9670;&nbsp;</a></span>reducedRowEchelon() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t LinBox::reducedRowEchelon </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_lin_box_1_1_blas_matrix.html">Matrix</a> &amp;&#160;</td>
          <td class="paramname"><em>E</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_lin_box_1_1_blas_matrix.html">Matrix</a> &amp;&#160;</td>
          <td class="paramname"><em>T</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_lin_box_1_1_blas_matrix.html">Matrix</a> &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const CategoryTag &amp;&#160;</td>
          <td class="paramname"><em>tag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const EchelonMethod &amp;&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the reduced row echelon form of a matrix, and the related transformation matrix. </p>
<p>Returns the reduced row echelon form E and a transformation matrix T such that T . A = E. The pivots are ones. The form is reduced, which means that coefficients above each pivot are zeros.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">E</td><td>the reduced row echelon form </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">T</td><td>the transformation matrix </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">A</td><td>matrix </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tag</td><td>domain of computation </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">m</td><td>method to use (</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>solutions/method.h) </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>the rank of the matrix </dd></dl>

</div>
</div>
<a id="a882e925d852b7445ca03a78ee8af3db2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a882e925d852b7445ca03a78ee8af3db2">&#9670;&nbsp;</a></span>reducedRowEchelonize() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t LinBox::reducedRowEchelonize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_lin_box_1_1_blas_matrix.html">Matrix</a> &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const CategoryTag &amp;&#160;</td>
          <td class="paramname"><em>tag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const EchelonMethod &amp;&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Replace the input matrix by its reduced row echelon form. </p>
<p>The pivots are ones. The form is reduced, which means that coefficients above each pivot are zeros.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">[in/out]</td><td>A matrix </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tag</td><td>domain of computation </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">m</td><td>method to use (</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>solutions/method.h) </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>the rank of the matrix </dd></dl>

</div>
</div>
<a id="a5fbb7ba4faaaf59a90cd10a86dc56c56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5fbb7ba4faaaf59a90cd10a86dc56c56">&#9670;&nbsp;</a></span>reducedRowEchelonize() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t LinBox::reducedRowEchelonize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_lin_box_1_1_blas_matrix.html">Matrix</a> &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_lin_box_1_1_blas_matrix.html">Matrix</a> &amp;&#160;</td>
          <td class="paramname"><em>T</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const CategoryTag &amp;&#160;</td>
          <td class="paramname"><em>tag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const EchelonMethod &amp;&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the reduced row echelon form of a matrix, and the related transformation matrix. </p>
<p>Returns the reduced row echelon form E and a transformation matrix T such that T . A = E. The input matrix is replaced by the reduced row echelon form. The pivots are ones. The form is reduced, which means that coefficients above each pivot are zeros.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">[in/out]</td><td>A matrix </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">T</td><td>the transformation matrix </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tag</td><td>domain of computation </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">m</td><td>method to use (</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>solutions/method.h) </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>the rank of the matrix </dd></dl>

</div>
</div>
<a id="a4628133347c77a535394011e3f7d507b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4628133347c77a535394011e3f7d507b">&#9670;&nbsp;</a></span>colEchelon() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t LinBox::colEchelon </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_lin_box_1_1_blas_matrix.html">Matrix</a> &amp;&#160;</td>
          <td class="paramname"><em>E</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_lin_box_1_1_blas_matrix.html">Matrix</a> &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const CategoryTag &amp;&#160;</td>
          <td class="paramname"><em>tag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const EchelonMethod &amp;&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the column echelon form of a matrix, not reduced. </p>
<p>Returns the column echelon form. The pivots are nonzero but not necessarily ones. The form is not reduced, which means that coefficients above each pivot are not necessarily zeros.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">E</td><td>the column echelon form </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">A</td><td>matrix </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tag</td><td>domain of computation </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">m</td><td>method to use (</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>solutions/method.h) </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>the rank of the matrix </dd></dl>

</div>
</div>
<a id="a30e0afbbab786da986b3a1819525e1c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30e0afbbab786da986b3a1819525e1c3">&#9670;&nbsp;</a></span>colEchelon() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t LinBox::colEchelon </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_lin_box_1_1_blas_matrix.html">Matrix</a> &amp;&#160;</td>
          <td class="paramname"><em>E</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_lin_box_1_1_blas_matrix.html">Matrix</a> &amp;&#160;</td>
          <td class="paramname"><em>T</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_lin_box_1_1_blas_matrix.html">Matrix</a> &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const CategoryTag &amp;&#160;</td>
          <td class="paramname"><em>tag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const EchelonMethod &amp;&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the column echelon form of a matrix, not reduced, and the related transformation matrix. </p>
<p>Returns the column echelon form E and a transformation matrix T such that T . A = E. The pivots are nonzero but not necessarily ones. The form is not reduced, which means that coefficients above each pivot are not necessarily zeros.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">E</td><td>the column echelon form </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">T</td><td>the transformation matrix </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">A</td><td>matrix </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tag</td><td>domain of computation </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">m</td><td>method to use (</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>solutions/method.h) </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>the rank of the matrix </dd></dl>

</div>
</div>
<a id="a0966fcfc89a7ad664e21376f2e1e8598"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0966fcfc89a7ad664e21376f2e1e8598">&#9670;&nbsp;</a></span>colEchelonize() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t LinBox::colEchelonize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_lin_box_1_1_blas_matrix.html">Matrix</a> &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const CategoryTag &amp;&#160;</td>
          <td class="paramname"><em>tag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const EchelonMethod &amp;&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Replace the input matrix by its column echelon form, not reduced. </p>
<p>The pivots are nonzero but not necessarily ones. The form is not reduced, which means that coefficients above each pivot are not necessarily zeros.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">[in/out]</td><td>A matrix </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tag</td><td>domain of computation </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">m</td><td>method to use (</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>solutions/method.h) </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>the rank of the matrix </dd></dl>

</div>
</div>
<a id="ae47c1a6f0fdd080f96cd2cf76f3648fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae47c1a6f0fdd080f96cd2cf76f3648fe">&#9670;&nbsp;</a></span>colEchelonize() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t LinBox::colEchelonize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_lin_box_1_1_blas_matrix.html">Matrix</a> &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_lin_box_1_1_blas_matrix.html">Matrix</a> &amp;&#160;</td>
          <td class="paramname"><em>T</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const CategoryTag &amp;&#160;</td>
          <td class="paramname"><em>tag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const EchelonMethod &amp;&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the column echelon form of a matrix, not reduced, and the related transformation matrix. </p>
<p>Returns the column echelon form E and a transformation matrix T such that T . A = E. The input matrix is replaced by the column echelon form. The pivots are nonzero but not necessarily ones. The form is not reduced, which means that coefficients above each pivot are not necessarily zeros.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">[in/out]</td><td>A matrix </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">T</td><td>the transformation matrix </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tag</td><td>domain of computation </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">m</td><td>method to use (</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>solutions/method.h) </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>the rank of the matrix </dd></dl>

</div>
</div>
<a id="a4bfbbd1a27e15894415a5d3ab67d7e56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4bfbbd1a27e15894415a5d3ab67d7e56">&#9670;&nbsp;</a></span>reducedColEchelon() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t LinBox::reducedColEchelon </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_lin_box_1_1_blas_matrix.html">Matrix</a> &amp;&#160;</td>
          <td class="paramname"><em>E</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_lin_box_1_1_blas_matrix.html">Matrix</a> &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const CategoryTag &amp;&#160;</td>
          <td class="paramname"><em>tag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const EchelonMethod &amp;&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the reduced column echelon form of a matrix. </p>
<p>Returns the reduced column echelon form. The pivots are ones. The form is reduced, which means that coefficients above each pivot are zeros.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">E</td><td>the reduced column echelon form </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">A</td><td>matrix </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tag</td><td>domain of computation </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">m</td><td>method to use (</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>solutions/method.h) </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>the rank of the matrix </dd></dl>

</div>
</div>
<a id="a220bb4e68cd747e8a9e82233e47f14e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a220bb4e68cd747e8a9e82233e47f14e3">&#9670;&nbsp;</a></span>reducedColEchelon() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t LinBox::reducedColEchelon </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_lin_box_1_1_blas_matrix.html">Matrix</a> &amp;&#160;</td>
          <td class="paramname"><em>E</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_lin_box_1_1_blas_matrix.html">Matrix</a> &amp;&#160;</td>
          <td class="paramname"><em>T</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_lin_box_1_1_blas_matrix.html">Matrix</a> &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const CategoryTag &amp;&#160;</td>
          <td class="paramname"><em>tag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const EchelonMethod &amp;&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the reduced column echelon form of a matrix, and the related transformation matrix. </p>
<p>Returns the reduced column echelon form E and a transformation matrix T such that T . A = E. The pivots are ones. The form is reduced, which means that coefficients above each pivot are zeros.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">E</td><td>the reduced column echelon form </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">T</td><td>the transformation matrix </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">A</td><td>matrix </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tag</td><td>domain of computation </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">m</td><td>method to use (</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>solutions/method.h) </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>the rank of the matrix </dd></dl>

</div>
</div>
<a id="a76525c64e06d1e064f57d44bdd6af957"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76525c64e06d1e064f57d44bdd6af957">&#9670;&nbsp;</a></span>reducedColEchelonize() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t LinBox::reducedColEchelonize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_lin_box_1_1_blas_matrix.html">Matrix</a> &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const CategoryTag &amp;&#160;</td>
          <td class="paramname"><em>tag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const EchelonMethod &amp;&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Replace the input matrix by its reduced column echelon form. </p>
<p>The pivots are ones. The form is reduced, which means that coefficients above each pivot are zeros.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">[in/out]</td><td>A matrix </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tag</td><td>domain of computation </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">m</td><td>method to use (</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>solutions/method.h) </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>the rank of the matrix </dd></dl>

</div>
</div>
<a id="aefbd85604ed49895b0e83b0885d467e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aefbd85604ed49895b0e83b0885d467e9">&#9670;&nbsp;</a></span>reducedColEchelonize() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t LinBox::reducedColEchelonize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_lin_box_1_1_blas_matrix.html">Matrix</a> &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_lin_box_1_1_blas_matrix.html">Matrix</a> &amp;&#160;</td>
          <td class="paramname"><em>T</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const CategoryTag &amp;&#160;</td>
          <td class="paramname"><em>tag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const EchelonMethod &amp;&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the reduced column echelon form of a matrix, and the related transformation matrix. </p>
<p>Returns the reduced column echelon form E and a transformation matrix T such that T . A = E. The input matrix is replaced by the reduced column echelon form. The pivots are ones. The form is reduced, which means that coefficients above each pivot are zeros.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">[in/out]</td><td>A matrix </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">T</td><td>the transformation matrix </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tag</td><td>domain of computation </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">m</td><td>method to use (</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>solutions/method.h) </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>the rank of the matrix </dd></dl>

</div>
</div>
<a id="a3972c11d794b51a6a78a370cef2d56a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3972c11d794b51a6a78a370cef2d56a6">&#9670;&nbsp;</a></span>HadamardRowLogBound()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void HadamardRowLogBound </td>
          <td>(</td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>logBound</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>minLogNorm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const IMatrix &amp;&#160;</td>
          <td class="paramname"><em>A</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Precise Hadamard bound (bound on determinant) by taking the row-wise euclidean norm. </p>
<p>The result is expressed as bit size. </p>

</div>
</div>
<a id="adb5010cb1f820989dab458fc7bed0c56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb5010cb1f820989dab458fc7bed0c56">&#9670;&nbsp;</a></span>HadamardColLogBound()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void HadamardColLogBound </td>
          <td>(</td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>logBound</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>minLogNorm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const IMatrix &amp;&#160;</td>
          <td class="paramname"><em>A</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Precise Hadamard bound (bound on determinant) by taking the column-wise euclidean norm. </p>
<p>The result is expressed as bit size. </p>

</div>
</div>
<a id="a9c0c0bbd8cce2bd2c8ba7033bc24eaf9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c0c0bbd8cce2bd2c8ba7033bc24eaf9">&#9670;&nbsp;</a></span>DetailedHadamardBound()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">HadamardLogBoundDetails DetailedHadamardBound </td>
          <td>(</td>
          <td class="paramtype">const IMatrix &amp;&#160;</td>
          <td class="paramname"><em>A</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Precise Hadamard bound (bound on determinant) by taking the minimum of the column-wise and the row-wise euclidean norm. </p>
<p>The results are expressed as bit size. </p>

</div>
</div>
<a id="a9ac0421dd3df3e55d96b86118112e2fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ac0421dd3df3e55d96b86118112e2fd">&#9670;&nbsp;</a></span>HadamardBound()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double HadamardBound </td>
          <td>(</td>
          <td class="paramtype">const IMatrix &amp;&#160;</td>
          <td class="paramname"><em>A</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Precise Hadamard bound (bound on determinant) by taking the minimum of the column-wise and the row-wise euclidean norm. </p>
<p>The result is expressed as bit size. </p>

</div>
</div>
<a id="abb9002510c82416c37c8380f416ecbbd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb9002510c82416c37c8380f416ecbbd">&#9670;&nbsp;</a></span>InfinityNorm()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Integer &amp; InfinityNorm </td>
          <td>(</td>
          <td class="paramtype">Integer &amp;&#160;</td>
          <td class="paramname"><em>max</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const IMatrix &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MatrixCategories::RowColMatrixTag &amp;&#160;</td>
          <td class="paramname"><em>tag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the bit size of the Hadamard bound. </p>
<p>This is a larger estimation but faster to compute. </p>

</div>
</div>
<a id="acbb0991103d6fd7fdbb8c3ed878d9830"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acbb0991103d6fd7fdbb8c3ed878d9830">&#9670;&nbsp;</a></span>FastCharPolyDumasPernetWanBound()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double FastCharPolyDumasPernetWanBound </td>
          <td>(</td>
          <td class="paramtype">const IMatrix &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Integer &amp;&#160;</td>
          <td class="paramname"><em>infnorm</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Bound on the coefficients of the characteristic polynomial. </p>
<dl class="bib"><dt><b><a class="el" href="bib.html#_bib000018">Bibliography:</a></b></dt><dd>"Efficient Computation of the Characteristic Polynomial".</dd></dl>
<p>Dumas Pernet Wan ISSAC'05.</p>
<dl class="bib"><dt><b><a class="el" href="bib.html#_bib000019">Bibliography:</a></b></dt><dd>"Efficient Computation of the Characteristic Polynomial".</dd></dl>
<p>Dumas Pernet Wan ISSAC'05. </p>

</div>
</div>
<a id="a45b441a86d2cc4fa12e11254c0e715fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45b441a86d2cc4fa12e11254c0e715fc">&#9670;&nbsp;</a></span>FastCharPolyGoldsteinGrahamBound()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double FastCharPolyGoldsteinGrahamBound </td>
          <td>(</td>
          <td class="paramtype">const IMatrix &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Integer &amp;&#160;</td>
          <td class="paramname"><em>infnorm</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A.J. </p>
<p>Goldstein et R.L. Graham. A Hadamard-type bound on the coefficients of a determinant of polynomials. SIAM Review, volume 15, 1973, pages 657?658.</p>
<p>Goldstein et R.L. Graham. A Hadamard-type bound on the coefficients of a determinant of polynomials. SIAM Review, volume 15, 1973, pages 657-658. </p>

</div>
</div>
<a id="a99564f23a7353cb8cc8ade629b556a50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99564f23a7353cb8cc8ade629b556a50">&#9670;&nbsp;</a></span>RationalSolveHadamardBound()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; std::is_same&lt; typename <a class="el" href="struct_lin_box_1_1_field_traits.html">FieldTraits</a>&lt; typename Matrix::Field &gt;::categoryTag, <a class="el" href="struct_lin_box_1_1_ring_categories_1_1_integer_tag.html">RingCategories::IntegerTag</a> &gt;::value, RationalSolveHadamardBoundData &gt;::type RationalSolveHadamardBound </td>
          <td>(</td>
          <td class="paramtype">const Matrix &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_lin_box_1_1_vector.html">Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bound on the rational solution of a linear system Ax = b. </p>
<p>Return bounds on the bit sizes of both denominator and numerator of the solution x.</p>
<dl class="section note"><dt>Note</dt><dd>Matrix and <a class="el" href="struct_lin_box_1_1_vector.html" title="Vector ?? ">Vector</a> should be over Integer. </dd></dl>

</div>
</div>
<a id="a0af7fd65b1b4bf21836bee9f98a80255"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0af7fd65b1b4bf21836bee9f98a80255">&#9670;&nbsp;</a></span>FastHadamardBound()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double LinBox::FastHadamardBound </td>
          <td>(</td>
          <td class="paramtype">const IMatrix &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Integer &amp;&#160;</td>
          <td class="paramname"><em>infnorm</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the bit size of the Hadamard bound. </p>
<p>This is a larger estimation but faster to compute. </p>

</div>
</div>
<a id="a22e887fb47b29e918a1a4305335bbabb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22e887fb47b29e918a1a4305335bbabb">&#9670;&nbsp;</a></span>isPositiveDefinite() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool LinBox::isPositiveDefinite </td>
          <td>(</td>
          <td class="paramtype">const Blackbox &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MyMethod &amp;&#160;</td>
          <td class="paramname"><em>M</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the isPositiveDefinite of A. </p>
<p>The isPositiveDefinite of a linear operator A, represented as a black box, is computed over the ring or field of A.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>Black box of which to compute the isPositiveDefinite </td></tr>
    <tr><td class="paramname">M</td><td>may be a <a class="el" href="namespace_lin_box.html#a10235377a5d8fe76c611f71b195cb97ea06b9281e396db002010bde1de57262eb" title="Let implementation decide what to use. ">Method::Auto</a> (default), Method::Blackbox, Method::Elimination, or of other method type. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="addbc23ec04522da6dfdfe4c1f8ae6afc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#addbc23ec04522da6dfdfe4c1f8ae6afc">&#9670;&nbsp;</a></span>isPositiveDefinite() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool LinBox::isPositiveDefinite </td>
          <td>(</td>
          <td class="paramtype">const Blackbox &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_lin_box_1_1_ring_categories_1_1_integer_tag.html">RingCategories::IntegerTag</a> &amp;&#160;</td>
          <td class="paramname"><em>tag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespace_lin_box.html#a10235377a5d8fe76c611f71b195cb97ea06b9281e396db002010bde1de57262eb">Method::Auto</a> &amp;&#160;</td>
          <td class="paramname"><em>M</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="bug"><dt><b><a class="el" href="bug.html#_bug000085">Bug:</a></b></dt><dd>should try a modular minpoly and decide on the degree of that... </dd></dl>
<dl class="bug"><dt><b><a class="el" href="bug.html#_bug000086">Bug:</a></b></dt><dd>this crude size check can be refined </dd></dl>

</div>
</div>
<a id="aa8e9dc4359118f1b4f93cb01bc8abbe2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8e9dc4359118f1b4f93cb01bc8abbe2">&#9670;&nbsp;</a></span>isPositiveDefinite() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool LinBox::isPositiveDefinite </td>
          <td>(</td>
          <td class="paramtype">const Blackbox &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_lin_box_1_1_ring_categories_1_1_integer_tag.html">RingCategories::IntegerTag</a> &amp;&#160;</td>
          <td class="paramname"><em>tag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Method::DenseElimination &amp;&#160;</td>
          <td class="paramname"><em>M</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="bug"><dt><b><a class="el" href="bug.html#_bug000087">Bug:</a></b></dt><dd>why map (same field)? This is a copy. </dd></dl>

</div>
</div>
<a id="a07fab2363dd6f649b8ba96d90f1830ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07fab2363dd6f649b8ba96d90f1830ac">&#9670;&nbsp;</a></span>isPositiveSemiDefinite() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool LinBox::isPositiveSemiDefinite </td>
          <td>(</td>
          <td class="paramtype">const Blackbox &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MyMethod &amp;&#160;</td>
          <td class="paramname"><em>M</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine if A is positive semidefinite. </p>
<p>The positive semidefiniteness of a linear operator A, represented as a black box, is computed over the ring or field (characteristic 0) of A.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>Black box of which to compute the isPositiveSemiDefinite </td></tr>
    <tr><td class="paramname">M</td><td>may be a <a class="el" href="namespace_lin_box.html#a10235377a5d8fe76c611f71b195cb97ea06b9281e396db002010bde1de57262eb" title="Let implementation decide what to use. ">Method::Auto</a> (SemiDefault), Method::Blackbox, Method::Elimination, or of other method type. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7ffb6619f43ef4b97e50bb0810787225"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ffb6619f43ef4b97e50bb0810787225">&#9670;&nbsp;</a></span>isPositiveSemiDefinite() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool LinBox::isPositiveSemiDefinite </td>
          <td>(</td>
          <td class="paramtype">const Blackbox &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_lin_box_1_1_ring_categories_1_1_integer_tag.html">RingCategories::IntegerTag</a> &amp;&#160;</td>
          <td class="paramname"><em>tag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Method::DenseElimination &amp;&#160;</td>
          <td class="paramname"><em>M</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section warning"><dt>Warning</dt><dd>this is a copy </dd></dl>

</div>
</div>
<a id="afc868c07af266200afa8592d083ea5ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc868c07af266200afa8592d083ea5ed">&#9670;&nbsp;</a></span>rankInPlace()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t&amp; LinBox::rankInPlace </td>
          <td>(</td>
          <td class="paramtype">size_t &amp;&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Blackbox &amp;&#160;</td>
          <td class="paramname"><em>A</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="namespace_lin_box_1_1_rank.html" title="Rank of the system, if known. ">Rank</a> of <code>A</code>. </p>
<p><code>A</code> may be modified </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>matrix </td></tr>
    <tr><td class="paramname">r</td><td>rank </td></tr>
  </table>
  </dd>
</dl>
<dl class="bug"><dt><b><a class="el" href="bug.html#_bug000088">Bug:</a></b></dt><dd>there is no Elimination() method there. </dd></dl>

</div>
</div>
<a id="adfde1de28c0b3f498bcec29850c9c0d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adfde1de28c0b3f498bcec29850c9c0d5">&#9670;&nbsp;</a></span>rank() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t&amp; LinBox::rank </td>
          <td>(</td>
          <td class="paramtype">size_t &amp;&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Blackbox &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_lin_box_1_1_ring_categories_1_1_modular_tag.html">RingCategories::ModularTag</a> &amp;&#160;</td>
          <td class="paramname"><em>tag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespace_lin_box.html#a10235377a5d8fe76c611f71b195cb97ea06b9281e396db002010bde1de57262eb">Method::Auto</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="bug"><dt><b><a class="el" href="bug.html#_bug000089">Bug:</a></b></dt><dd>choose (benchmark) better cuttoff (size, nbnz, sparse rep) </dd></dl>

</div>
</div>
<a id="aadd94634e20c65da01ddc12e8fdf135a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aadd94634e20c65da01ddc12e8fdf135a">&#9670;&nbsp;</a></span>rank() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t&amp; LinBox::rank </td>
          <td>(</td>
          <td class="paramtype">size_t &amp;&#160;</td>
          <td class="paramname"><em>res</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Blackbox &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_lin_box_1_1_ring_categories_1_1_modular_tag.html">RingCategories::ModularTag</a> &amp;&#160;</td>
          <td class="paramname"><em>tag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Method::Wiedemann &amp;&#160;</td>
          <td class="paramname"><em>M</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>M may be <code>Method::Wiedemann()</code>. </p>
<dl class="bug"><dt><b><a class="el" href="bug.html#_bug000090">Bug:</a></b></dt><dd>This is too much for solutions. It belongs in algorithms </dd></dl>

</div>
</div>
<a id="a7f10e874b0ff76927361596ffde1b670"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f10e874b0ff76927361596ffde1b670">&#9670;&nbsp;</a></span>solve() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LinBox::solve </td>
          <td>(</td>
          <td class="paramtype">IntVector &amp;&#160;</td>
          <td class="paramname"><em>xNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename IntVector::Element &amp;&#160;</td>
          <td class="paramname"><em>xDen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_lin_box_1_1_blas_matrix.html">Matrix</a> &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_lin_box_1_1_vector.html">Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_lin_box_1_1_ring_categories_1_1_integer_tag.html">RingCategories::IntegerTag</a> &amp;&#160;</td>
          <td class="paramname"><em>tag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Method::CRA&lt; IterationMethod &gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Solve specialization with Chinese Remainder Algorithm method for an Integer or Rational tags. </p>
<p>If a <a class="el" href="namespace_lin_box.html#a10235377a5d8fe76c611f71b195cb97ea8c16cbebef45d87fd2b36ce69f46c526" title="Use MPI to distribute sub-computations accross nodes. ">Dispatch::Distributed</a> is used, please note that the result will only be set on the master node. </p>

</div>
</div>
<a id="acb4c3ef55845dd94844fb9ebbf1176f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb4c3ef55845dd94844fb9ebbf1176f6">&#9670;&nbsp;</a></span>solve() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ResultVector&amp; LinBox::solve </td>
          <td>(</td>
          <td class="paramtype">ResultVector &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_lin_box_1_1_blas_matrix.html">Matrix</a> &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_lin_box_1_1_vector.html">Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const CategoryTag &amp;&#160;</td>
          <td class="paramname"><em>tag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SolveMethod &amp;&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Solve Ax = b, for x. </p>
<p>Returns a vector x such that Ax = b.</p>
<p>Specifically:</p><ul>
<li>A non singular: the unique solution is returned.</li>
<li>A singular:<ul>
<li>Consistent system: a random solution is returned. The method parameter can contain an hint that an arbitrary element of the solution space is acceptable instead, which can be faster to compute if one doesn't expect a result in that case.</li>
<li>Inconsistent system: LinboxMathInconsistentSystem is thrown.</li>
<li>Internal failure: <a class="el" href="class_lin_box_1_1_linbox_error.html" title="base class for execption handling in LinBox ">LinboxError</a> is thrown.</li>
</ul>
</li>
</ul>
<p>CategoryTag is defaulted to <code><a class="el" href="struct_lin_box_1_1_field_traits.html" title="FieldTrait. ">FieldTraits</a>&lt;Matrix::Field&gt;::categoryTag()</code> when omitted.</p>
<ul>
<li><a class="el" href="namespace_lin_box.html#a10235377a5d8fe76c611f71b195cb97ea06b9281e396db002010bde1de57262eb" title="Let implementation decide what to use. ">Method::Auto</a><ul>
<li>DenseMatrix &gt; Method::DenseElimination</li>
<li>SparseMatrix &gt; Method::SparseElimination</li>
<li>Otherwise | - Row or column dimension &lt; LINBOX_USE_BLACKBOX_THRESHOLD &gt; Method::Elimination | - Otherwise &gt; Method::Blackbox</li>
</ul>
</li>
<li>Method::Elimination<ul>
<li>DenseMatrix &gt; Method::DenseElimination</li>
<li>SparseMatrix &gt; Method::SparseElimination</li>
<li>Otherwise &gt; Method::DenseElimination or Method::SparseElimination given matrix sparsity</li>
</ul>
</li>
<li>Method::DenseElimination<ul>
<li>DenseMatrix | - ModularTag &gt; <code>LQUPMatrix&lt;Field&gt;::left_solve</code> | - IntegerTag | | - RatVector &gt; Method::Dixon | | - Otherwise &gt; Error | - Otherwise &gt; Error (Not implemented)</li>
<li>Otherwise &gt; Method::DenseElimination but copy to a DenseMatrix first</li>
</ul>
</li>
<li>Method::SparseElimination<ul>
<li>SparseMatrix | - IntegerTag &gt; Method::Dixon | - Otherwise &gt; <code><a class="el" href="class_lin_box_1_1_gauss_domain.html" title="Repository of functions for rank by elimination on sparse matrices. ">GaussDomain</a>&lt;Field&gt;<a class="el" href="namespace_lin_box.html#a0b6ec687d48d29617575bb1eb48765dd" title="Solve in place specialisation for Auto. ">solveInPlace</a></code></li>
<li>Otherwise &gt; Method::SparseElimination but copy to SparseMatrix first</li>
</ul>
</li>
<li>Method::CRA<ul>
<li>IntegerTag | - <a class="el" href="namespace_lin_box.html#a10235377a5d8fe76c611f71b195cb97ea8c16cbebef45d87fd2b36ce69f46c526" title="Use MPI to distribute sub-computations accross nodes. ">Dispatch::Distributed</a> &gt; <code>ChineseRemainderDistributed</code> | - Otherwise &gt; <code><a class="el" href="struct_lin_box_1_1_rational_chinese_remainder.html" title="Chinese remainder of rationals. ">RationalChineseRemainder</a></code></li>
<li>Otherwise &gt; Error</li>
</ul>
</li>
<li>Method::Dixon<ul>
<li>IntegerTag | - DenseMatrix &gt; <code><a class="el" href="class_lin_box_1_1_rational_solver.html" title="Interface for the different specialization of p-adic lifting based solvers. ">RationalSolver</a>&lt;..., Method::Dixon&gt;</code> | - SparseMatrix &gt; <code><a class="el" href="class_lin_box_1_1_rational_solver.html" title="Interface for the different specialization of p-adic lifting based solvers. ">RationalSolver</a>&lt;..., Method::SparseElimination&gt;</code> | - Otherwise &gt; Error</li>
<li>Otherwise &gt; Error</li>
</ul>
</li>
<li>Method::Blackbox &gt; Method::Wiedemann</li>
<li>Method::Wiedemann<ul>
<li>ModularTag &gt; <code><a class="el" href="class_lin_box_1_1_wiedemann_solver.html" title="Linear system solvers based on Wiedemann&#39;s method. ">WiedemannSolver</a></code></li>
<li>IntegerTag &gt; Method::Dixon</li>
<li>Otherwise &gt; Error</li>
</ul>
</li>
<li>Method::BlockWiedemann [<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000003">Deprecated:</a></b></dt><dd>, not tested]<ul>
<li>ModularTag &gt; <code>BlockWiedemannSolver</code></li>
<li>Otherwise &gt; Error</li>
</ul>
</dd></dl>
</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">x</td><td>solution, can be a rational solution (vector of numerators and one denominator) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">A</td><td>matrix </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">b</td><td>target </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tag</td><td>domain of computation </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">m</td><td>method to use (</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>solutions/method.h) </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>reference to <code>x</code> </dd></dl>

</div>
</div>
<a id="a01a1d41b722955549320a598abf33a87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01a1d41b722955549320a598abf33a87">&#9670;&nbsp;</a></span>solve() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;std::is_same&lt;typename SolveMethod::CategoryTag, <a class="el" href="struct_lin_box_1_1_ring_categories_1_1_integer_tag.html">RingCategories::IntegerTag</a>&gt;::value &amp;&amp; std::is_same&lt;typename <a class="el" href="struct_lin_box_1_1_field_traits.html">FieldTraits</a>&lt;typename RatVector::Field&gt;::categoryTag, <a class="el" href="struct_lin_box_1_1_ring_categories_1_1_rational_tag.html">RingCategories::RationalTag</a>&gt;::value, RatVector&amp;&gt;::type LinBox::solve </td>
          <td>(</td>
          <td class="paramtype">RatVector &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_lin_box_1_1_blas_matrix.html">Matrix</a> &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_lin_box_1_1_vector.html">Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_lin_box_1_1_ring_categories_1_1_integer_tag.html">RingCategories::IntegerTag</a> &amp;&#160;</td>
          <td class="paramname"><em>tag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SolveMethod &amp;&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Solve specialisation on IntegerTag with Vector&lt;QField&gt; as result. </p>
<p>This forward to the rational interface (num, den). But will only work if the ResultVector if a vector of some Rational type. </p>

</div>
</div>
<a id="a76e80bbf7b3c4a7100e56f028a69d84d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76e80bbf7b3c4a7100e56f028a69d84d">&#9670;&nbsp;</a></span>solve() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;std::is_same&lt;typename SolveMethod::CategoryTag, <a class="el" href="struct_lin_box_1_1_ring_categories_1_1_integer_tag.html">RingCategories::IntegerTag</a>&gt;::value, <a class="el" href="class_lin_box_1_1_vector_fraction.html">VectorFraction</a>&lt;typename Matrix::Field&gt;&amp;&gt;::type LinBox::solve </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_lin_box_1_1_vector_fraction.html">VectorFraction</a>&lt; typename Matrix::Field &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_lin_box_1_1_blas_matrix.html">Matrix</a> &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_lin_box_1_1_vector.html">Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_lin_box_1_1_ring_categories_1_1_integer_tag.html">RingCategories::IntegerTag</a> &amp;&#160;</td>
          <td class="paramname"><em>tag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SolveMethod &amp;&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Solve specialisation on IntegerTag with <a class="el" href="class_lin_box_1_1_vector_fraction.html" title="VectorFraction&lt;Domain&gt; is a vector of rational elements with common reduced denominator. ">VectorFraction</a> as result. </p>
<p>This forward to the rational interface (num, den). </p>

</div>
</div>
<a id="a20225678db734c74e788a8fa33d11644"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20225678db734c74e788a8fa33d11644">&#9670;&nbsp;</a></span>solve() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LinBox::solve </td>
          <td>(</td>
          <td class="paramtype">IntVector &amp;&#160;</td>
          <td class="paramname"><em>xNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename IntVector::Element &amp;&#160;</td>
          <td class="paramname"><em>xDen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_lin_box_1_1_blas_matrix.html">Matrix</a> &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_lin_box_1_1_vector.html">Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const CategoryTag &amp;&#160;</td>
          <td class="paramname"><em>tag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SolveMethod &amp;&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Rational solve Ax = b, for x expressed as xNum/xDen. </p>
<p>Second interface for solving, only valid for <a class="el" href="struct_lin_box_1_1_ring_categories_1_1_integer_tag.html" title="If it is isomorphic to Z. ">RingCategories::IntegerTag</a>.</p>
<p>Solve with this interface will usually go for CRA or Dixon lifting, as non-modular elimination would snowball elements to very big values. </p>

</div>
</div>
<a id="a6a4e737227dd257eb14f8b963e68f921"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a4e737227dd257eb14f8b963e68f921">&#9670;&nbsp;</a></span>solveInPlace() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ResultVector&amp; LinBox::solveInPlace </td>
          <td>(</td>
          <td class="paramtype">ResultVector &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_lin_box_1_1_blas_matrix.html">Matrix</a> &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_lin_box_1_1_vector.html">Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const CategoryTag &amp;&#160;</td>
          <td class="paramname"><em>tag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SolveMethod &amp;&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Solve Ax = b, for x. </p>
<p>Returns a vector x such that Ax = b. A can be modified.</p>
<p>See documentation for <code>solve</code>. </p>

</div>
</div>
<a id="acc5519b3a119f5bb31d5cf10d77fc9ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc5519b3a119f5bb31d5cf10d77fc9ca">&#9670;&nbsp;</a></span>solveInPlace() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LinBox::solveInPlace </td>
          <td>(</td>
          <td class="paramtype">IntVector &amp;&#160;</td>
          <td class="paramname"><em>xNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename IntVector::Element &amp;&#160;</td>
          <td class="paramname"><em>xDen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_lin_box_1_1_blas_matrix.html">Matrix</a> &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_lin_box_1_1_vector.html">Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const CategoryTag &amp;&#160;</td>
          <td class="paramname"><em>tag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SolveMethod &amp;&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Rational solve in place Ax = b, for x expressed as xNum/xDen. </p>
<p>The matrix A might be modified.</p>
<p>Second interface for solving in place, only valid for <a class="el" href="struct_lin_box_1_1_ring_categories_1_1_integer_tag.html" title="If it is isomorphic to Z. ">RingCategories::IntegerTag</a>. </p>

</div>
</div>
<a id="a3ced65416a091fd0c44c02175bed2f51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ced65416a091fd0c44c02175bed2f51">&#9670;&nbsp;</a></span>trace()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BB::Field::Element &amp; trace </td>
          <td>(</td>
          <td class="paramtype">typename BB::Field::Element &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const BB &amp;&#160;</td>
          <td class="paramname"><em>A</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="class_lin_box_1_1_sum.html" title="blackbox of a matrix sum without copying. ">Sum</a> of the eigenvalues. </p>
<p>Also it is the sum of the diagonal entries.</p>
<p>Runtime on n by n matrix is n times the cost of <a class="el" href="namespace_lin_box.html#ab391e49b8420d85600bb3b961add5489" title="Getting the i,j entry of the blackbox. ">getEntry()</a>. This is linear in n for those classes where getEntry is constant time (eg DenseMatrix and SparseMatrix). Trace is constant time when the diagonal is necessarily constant, eg. for <a class="el" href="class_lin_box_1_1_scalar_matrix.html" title="Blackbox for aI. ">ScalarMatrix</a> and <a class="el" href="class_lin_box_1_1_toeplitz.html" title="This is the blackbox representation of a Toeplitz matrix. ">Toeplitz</a>. Worst case time is cost of n blackbox applies (matrix vector products), and apply cost typically ranges between O(n) and O(n^2). </p>

</div>
</div>
<a id="a28045aed95ca616b2a22d3735ed94a61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28045aed95ca616b2a22d3735ed94a61">&#9670;&nbsp;</a></span>serialize() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t serialize </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; uint8_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>bytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Integer &amp;&#160;</td>
          <td class="paramname"><em>integer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Serializes an Integer with its underlying __mpz_struct. </p>
<p>Returns the number of bytes written.</p>
<p>Format is (by bytes count): 0-3 _mp_size Number of mp_limb_t in _mp_d, can be negative to indicate negative number. 4-.. _mp_d The limbs of length (abs(_mp_size) * sizeof(mp_limb_t)) </p>
<dl class="section note"><dt>Note</dt><dd>As said, we're not sure of how many bytes we will write here, because mp_limb_t can be either 32 or 64 bytes-long depending on configuration. We force it to be 64 bit-long so that it becomes platform-independent.</dd>
<dd>
As said, we're not sure of how many bytes we will write here, because mp_limb_t can be either 32 or 64 bytes-long depending on configuration. We force it to be 64 bit-long so that it becomes platform-independent.</dd></dl>

</div>
</div>
<a id="ad9d0885b4f7d1b52c9f8c92ab0ee97e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9d0885b4f7d1b52c9f8c92ab0ee97e5">&#9670;&nbsp;</a></span>serialize() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t serialize </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; uint8_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>bytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_lin_box_1_1_blas_matrix.html">BlasMatrix</a>&lt; Field &gt; &amp;&#160;</td>
          <td class="paramname"><em>M</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Serializes a <a class="el" href="class_lin_box_1_1_blas_matrix.html" title="Dense matrix representation. ">BlasMatrix</a>. </p>
<p>Format is (by bytes count): 0-7 n Row dimension of matrix 8-15 m Column dimension of matrix 16-.. Entries of the matrix, (n * m) row-majored </p>

</div>
</div>
<a id="afba64cc7de557f49ea53b96822a564e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afba64cc7de557f49ea53b96822a564e5">&#9670;&nbsp;</a></span>unserialize() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t unserialize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_lin_box_1_1_blas_matrix.html">BlasMatrix</a>&lt; Field &gt; &amp;&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; uint8_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>bytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>offset</em> = <code>0u</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unserializes a <a class="el" href="class_lin_box_1_1_blas_matrix.html" title="Dense matrix representation. ">BlasMatrix</a>. </p>
<p>The matrix will be resized if necessary. </p>

</div>
</div>
<a id="a9cce41cacef3e6c938610c6e08f7f16d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9cce41cacef3e6c938610c6e08f7f16d">&#9670;&nbsp;</a></span>serialize() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t serialize </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; uint8_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>bytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SparseMatrix&lt; Field &gt; &amp;&#160;</td>
          <td class="paramname"><em>M</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Serializes a SparseMatrix. </p>
<p>Format is (by bytes count): 0-7 n Row dimension of matrix 8-15 m Column dimension of matrix 23-.. Entries of the matrix, only non-zero, stored as: 0-7 i Row index 8-15 j Column index 16-.. Entry value (8 bytes) End of sparse entries, with a value of 0xFFFFFFFF'FFFFFFFF </p>

</div>
</div>
<a id="ad36e13d307b3553f5ad1650272f1ace0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad36e13d307b3553f5ad1650272f1ace0">&#9670;&nbsp;</a></span>unserialize() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t unserialize </td>
          <td>(</td>
          <td class="paramtype">SparseMatrix&lt; Field &gt; &amp;&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; uint8_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>bytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>offset</em> = <code>0u</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unserializes a SparseMatrix. </p>
<p>The matrix will be resized if necessary. </p>

</div>
</div>
<a id="a884340c246e258561d0eda1b287c9589"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a884340c246e258561d0eda1b287c9589">&#9670;&nbsp;</a></span>serialize() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t serialize </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; uint8_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>bytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const BlasVector&lt; Field &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Serializes a BlasVector. </p>
<p>Format is (by bytes count): 0-7 l Length of the vector 16-.. Entries of the vector </p>

</div>
</div>
<a id="ac337ae125ffe1c3f657d695aea18eba0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac337ae125ffe1c3f657d695aea18eba0">&#9670;&nbsp;</a></span>unserialize() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t unserialize </td>
          <td>(</td>
          <td class="paramtype">BlasVector&lt; Field &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; uint8_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>bytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>offset</em> = <code>0u</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unserializes a BlasVector. </p>
<p>The vector will be resized if necessary. </p>

</div>
</div>
<a id="a514dd1ffda0862fabad1d998b911ef56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a514dd1ffda0862fabad1d998b911ef56">&#9670;&nbsp;</a></span>randomVector()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_lin_box_1_1_vector.html">Vector</a> LinBox::randomVector </td>
          <td>(</td>
          <td class="paramtype">Field &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename Field::RandIter &amp;&#160;</td>
          <td class="paramname"><em>r</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Random vector generator This templated function takes a field and a random field element generator and returns a vector of random field elements. </p>
<p>The vector is dense in the field elements, even if the vector is a sparse <a class="el" href="namespace_lin_box.html" title="Namespace in which all linbox code resides. ">LinBox</a> vector. The funtion is templatized by the field and the vector types being used. This function calls another function by the same name with an additional parameter of the vector category of the vector it is called with. This mechanism is used because functions cannot have partial template specializations like classes can. This new, extended function can be specialized for specific fields and vectors to allow for better performance. </p><dl class="section return"><dt>Returns</dt><dd>v vector of random field elements </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">F</td><td>Field in which arithmetic is done </td></tr>
    <tr><td class="paramname">n</td><td>integer number of elements in vector </td></tr>
    <tr><td class="paramname">r</td><td>Random field element generator </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3bba68c5446a212c6540fe0348c95ac3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3bba68c5446a212c6540fe0348c95ac3">&#9670;&nbsp;</a></span>randomAns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_lin_box_1_1_blas_matrix.html">Matrix</a>&amp; LinBox::randomAns </td>
          <td>(</td>
          <td class="paramtype">const Ring &amp;&#160;</td>
          <td class="paramname"><em>R</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_lin_box_1_1_blas_matrix.html">Matrix</a> &amp;&#160;</td>
          <td class="paramname"><em>Mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>epr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="bug"><dt><b><a class="el" href="bug.html#_bug000104">Bug:</a></b></dt><dd>use BlasVector. </dd></dl>

</div>
</div>
<a id="a261c9bbbb8f95a1dc0d670cd49d4fe0e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a261c9bbbb8f95a1dc0d670cd49d4fe0e">&#9670;&nbsp;</a></span>RandIntInInt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t&amp; LinBox::RandIntInInt </td>
          <td>(</td>
          <td class="paramtype">const size_t &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t &amp;&#160;</td>
          <td class="paramname"><em>RIII</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>seed</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>gives a random number such that <img class="formulaInl" alt="$0 \leq RIII &lt; s$" src="form_72.png"/>. </p>
<p>basic.. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>sup </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">seed</td><td>seed. If <code>0</code> (default) we create a new one. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">RIII</td><td>random integer in the interval <img class="formulaInl" alt="$[[0, s-1]]$" src="form_73.png"/>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to <code>RIII</code> </dd></dl>

</div>
</div>
<a id="a50d39993dc790c4ce470225ddc42ed17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50d39993dc790c4ce470225ddc42ed17">&#9670;&nbsp;</a></span>CheckRank()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool LinBox::CheckRank </td>
          <td>(</td>
          <td class="paramtype">const Field &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename Field ::Element *&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t &amp;&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t &amp;&#160;</td>
          <td class="paramname"><em>lda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t &amp;&#160;</td>
          <td class="paramname"><em>alledged_rank</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks we got the right rank. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">F</td><td>field </td></tr>
    <tr><td class="paramname">A</td><td>matrix </td></tr>
    <tr><td class="paramname">m</td><td>rows </td></tr>
    <tr><td class="paramname">n</td><td>cols </td></tr>
    <tr><td class="paramname">lda</td><td>leadin dimmension </td></tr>
    <tr><td class="paramname">alledged_rank</td><td>supposedly correct rank.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>alledged_rank==rank(A)</code> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">alledged_rank</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="bug"><dt><b><a class="el" href="bug.html#_bug000127">Bug:</a></b></dt><dd>not used </dd></dl>

</div>
</div>
<a id="a3804d7270e3982dc59cbf81f239bdcba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3804d7270e3982dc59cbf81f239bdcba">&#9670;&nbsp;</a></span>RandomMatrixWithDet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LinBox::RandomMatrixWithDet </td>
          <td>(</td>
          <td class="paramtype">const Field &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename Field ::Element *&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t &amp;&#160;</td>
          <td class="paramname"><em>lda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename Field ::Element &amp;&#160;</td>
          <td class="paramname"><em>det</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Builds a <code>m</code> x <code>m</code> random matrix of determinant <code>det</code> over field <code>F</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">det</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="bug"><dt><b><a class="el" href="bug.html#_bug000128">Bug:</a></b></dt><dd>not used </dd></dl>

</div>
</div>
<a id="acf56754df11afb467f9af89f3a118f8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf56754df11afb467f9af89f3a118f8b">&#9670;&nbsp;</a></span>showAdvanceLinear()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void showAdvanceLinear </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>curr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>min</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>max</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>show the advancement (on the terminal) suppose linear advancement </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">curr</td><td>current iteration </td></tr>
    <tr><td class="paramname">min</td><td>starting iteration </td></tr>
    <tr><td class="paramname">max</td><td>terminal iteration </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0581b070e8f0a28532f2732096b437cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0581b070e8f0a28532f2732096b437cc">&#9670;&nbsp;</a></span>showFinish()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void showFinish </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>curr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>all</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>tells the current series of measure has completed (on the terminal) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">curr</td><td>current iteration </td></tr>
    <tr><td class="paramname">all</td><td>number of iterations </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac9dfd12d40192113024a8365780c789d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9dfd12d40192113024a8365780c789d">&#9670;&nbsp;</a></span>showSkip()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void showSkip </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>curr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>all</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>tells the current series of measure was skipped (on the terminal) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">curr</td><td>current iteration </td></tr>
    <tr><td class="paramname">all</td><td>number of iterations </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac1e7a4da3ef5a0d951a1ca333b994384"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1e7a4da3ef5a0d951a1ca333b994384">&#9670;&nbsp;</a></span>computeMFLOPS() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double computeMFLOPS </td>
          <td>(</td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>tim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>mflo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>rpt</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>computes the number of megaflops. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tim</td><td>timer (seconds) </td></tr>
    <tr><td class="paramname">mflo</td><td>number of operations (1e6 operations) </td></tr>
    <tr><td class="paramname">rpt</td><td>number of experiences </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>mflo/(tim*rpt) </dd></dl>

</div>
</div>
<a id="a199e98d6fcea6afebf75c459a2e4ac3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a199e98d6fcea6afebf75c459a2e4ac3e">&#9670;&nbsp;</a></span>computeMFLOPS() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double computeMFLOPS </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespace_lin_box.html#a94cbbcce791d72e74c60f9fbe3ad2921">dvector_t</a> &amp;&#160;</td>
          <td class="paramname"><em>tim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>mflo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_lin_box_1_1_tag.html#aeb30bde7bdea621040f3206487315cbf">Tag::TimeSelect</a>&#160;</td>
          <td class="paramname"><em>ts</em> = <code>Tag::TimeSelect::bestThree</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>computes the number of megaflops. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tim</td><td>timer (seconds) </td></tr>
    <tr><td class="paramname">mflo</td><td>number of operations (1e6 operations) </td></tr>
    <tr><td class="paramname">ts</td><td>number of experiences to select. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>TimeSelect. Default to the best three </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>mflo/(tim*rpt) </dd></dl>

</div>
</div>
<a id="aefbb240a3757623be97233836a133e55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aefbb240a3757623be97233836a133e55">&#9670;&nbsp;</a></span>isDigit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool isDigit </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if a string is actually a double. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>string to check </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true/false </dd></dl>

</div>
</div>
<a id="abb1fd9d5919759a9b794acae86d0bb4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb1fd9d5919759a9b794acae86d0bb4f">&#9670;&nbsp;</a></span>fortifiedString()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool fortifiedString </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tells is a string has double quotes around. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>string to test </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if s[0] == s[last] == '"' </dd></dl>

</div>
</div>
<a id="a486320b0fb42371d8332a035c4c4850e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a486320b0fb42371d8332a035c4c4850e">&#9670;&nbsp;</a></span>unfortifyString()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string unfortifyString </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>removes the surrounding quotes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>removes quotes around if necessary </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>s without surrounding double quotes if necessary </dd></dl>

</div>
</div>
<a id="a0553ed623696a5c6efee36bbe48d366f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0553ed623696a5c6efee36bbe48d366f">&#9670;&nbsp;</a></span>fortifyString()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string fortifyString </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>adds surrounding quotes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>add quotes around if necessary </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>s with surrounding double quotes if necessary </dd></dl>

</div>
</div>
<a id="a954446eb85941a79614cfe92fabc8150"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a954446eb85941a79614cfe92fabc8150">&#9670;&nbsp;</a></span>getDateTime()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string getDateTime </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>sep</em> = <code>&quot;&#160;&quot;</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>get ISO time and date </p>
<p>get ISO time and date year-time YYYY-MM-DD 'sep' HH:MM:SS 'sep' (GMT)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sep</td><td>separation between </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5508403b1a6849cfb70d8352501ffc14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5508403b1a6849cfb70d8352501ffc14">&#9670;&nbsp;</a></span>toString()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string LinBox::toString </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>nam</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts anything to a string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nam</td><td>to be put in a string. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Wed Jun 5 2019 14:05:43 for linbox by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
