<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>linbox: examples/smithsparse.C</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">linbox
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',false,false,'search.php','Search');
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">examples/smithsparse.C</div>  </div>
</div><!--header-->
<div class="contents">
<p>Smith form by sparse elmination, Integer Smith by valence method, or local at a prime power.See smithvalence for valence method with more options and information.</p>
<p>For local smith, moduli greater than 2^32 are not supported here (easily changed). matrix is read from file or generated from a small selection of example families. Run the program with no arguments for a synopsis of the command line parameters.</p>
<div class="fragment"><div class="line"><span class="comment">/*</span></div><div class="line"><span class="comment"> * examples/smithsparse.C</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * Copyright (C) 2005, 2010  D. Saunders, Z. Wang, J-G Dumas</span></div><div class="line"><span class="comment"> * ========LICENCE========</span></div><div class="line"><span class="comment"> * This file is part of the library LinBox.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * LinBox is free software: you can redistribute it and/or modify</span></div><div class="line"><span class="comment"> * it under the terms of the  GNU Lesser General Public</span></div><div class="line"><span class="comment"> * License as published by the Free Software Foundation; either</span></div><div class="line"><span class="comment"> * version 2.1 of the License, or (at your option) any later version.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * This library is distributed in the hope that it will be useful,</span></div><div class="line"><span class="comment"> * but WITHOUT ANY WARRANTY; without even the implied warranty of</span></div><div class="line"><span class="comment"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU</span></div><div class="line"><span class="comment"> * Lesser General Public License for more details.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * You should have received a copy of the GNU Lesser General Public</span></div><div class="line"><span class="comment"> * License along with this library; if not, write to the Free Software</span></div><div class="line"><span class="comment"> * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA</span></div><div class="line"><span class="comment"> * ========LICENCE========</span></div><div class="line"><span class="comment"> */</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="linbox-config_8h.html">linbox/linbox-config.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;string&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;vector&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;list&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">using namespace </span><a class="code" href="namespacestd.html">std</a>;</div><div class="line"></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="modular_8h.html">linbox/ring/modular.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="sparse-matrix_8h.html">linbox/matrix/sparse-matrix.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;linbox/algorithms/smith-form-sparseelim-local.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;linbox/algorithms/smith-form-sparseelim-poweroftwo.h&gt;</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="timer_8h.html">linbox/util/timer.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;linbox/ring/pir-modular-int32.h&gt;</span></div><div class="line"><span class="preprocessor">#define SILENT </span></div><div class="line"><span class="preprocessor">#define NOT_USING_OMP</span></div><div class="line"><span class="preprocessor">#include &quot;smithvalence.h&quot;</span></div><div class="line"><span class="preprocessor">#undef NOT_USING_OMP</span></div><div class="line"><span class="preprocessor">#undef SILENT </span></div><div class="line"></div><div class="line"><span class="keyword">using namespace </span><a class="code" href="namespace_lin_box.html">LinBox</a>;</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> I1, <span class="keyword">class</span> Lp&gt; <span class="keywordtype">void</span> <a name="a0"></a><a class="code" href="blackbox_2smith_8_c.html#a2dbc867fa25de06ae61108deaf57f1fa">distinct</a> (I1 a, I1 b, Lp&amp; c);</div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> I&gt; <span class="keywordtype">void</span> display(I b, I e);</div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> Int_type, <span class="keyword">class</span> Ring_type = Givaro::ZRing&lt;Int_type&gt; &gt;</div><div class="line"><span class="keywordtype">void</span> runpoweroftworank(ifstream&amp; input, <span class="keyword">const</span> <span class="keywordtype">size_t</span> exponent, <span class="keywordtype">size_t</span> StPr);</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>* argv[])</div><div class="line">{</div><div class="line">    Givaro::Timer chrono; </div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> (argc &lt; 2 or 3 &lt; argc) {</div><div class="line">        cout &lt;&lt;</div><div class="line"><span class="stringliteral">&quot;Usage: &quot;</span> &lt;&lt; <span class="comment">/*argv[0] &lt;&lt;*/</span> <span class="stringliteral">&quot;smithsparse file [m]&quot;</span>  &lt;&lt; endl &lt;&lt;</div><div class="line"><span class="stringliteral">&quot;  where file contains the matrix in any supported format and m is the modulus.&quot;</span> &lt;&lt; endl &lt;&lt;</div><div class="line"><span class="stringliteral">&quot;  With no m, Smith form over Z by the valence method is done.&quot;</span> &lt;&lt; endl &lt;&lt;</div><div class="line"><span class="stringliteral">&quot;  Use smithvalence.C to have more options and get more output info.&quot;</span> &lt;&lt; endl &lt;&lt;</div><div class="line"><span class="stringliteral">&quot;  Given m, a prime power, local Smith form over Z_m is done via sparse elim.&quot;</span> &lt;&lt; endl &lt;&lt;</div><div class="line"><span class="stringliteral">&quot;  Use power_ranks.C or poweroftwo_rank.C to have more options and get more output info.&quot;</span> &lt;&lt; endl &lt;&lt;</div><div class="line"><span class="stringliteral">&quot;  See mats.C for some examples that have been used in smith form algorithm testing&quot;</span> &lt;&lt; endl;</div><div class="line">        <span class="keywordflow">return</span> 0;</div><div class="line">    }</div><div class="line"></div><div class="line">    chrono.start();</div><div class="line">    ifstream input(argv[1]);</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> (argc &gt; 2) { <span class="comment">// so over Z_m</span></div><div class="line">        <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> m = atoi(argv[2]);</div><div class="line">        <span class="keywordflow">if</span> (m &gt; 4967296) {<span class="comment">// too big</span></div><div class="line">            cerr &lt;&lt; <span class="stringliteral">&quot;Modulus too large for this example&quot;</span> &lt;&lt; endl;</div><div class="line">            <span class="keywordflow">return</span> -1;</div><div class="line">        } </div><div class="line">        <span class="keywordflow">if</span> (m%2 == 0) { <span class="comment">// local at small power of 2.</span></div><div class="line">            runpoweroftworank&lt;uint64_t, Givaro::ZRing&lt;int64_t&gt; &gt;(input, 32, 0);</div><div class="line">        } <span class="keywordflow">else</span> {  <span class="comment">// local at general Z_p^e</span></div><div class="line"></div><div class="line">            <span class="keyword">typedef</span> Givaro::Modular&lt;int32_t&gt; SPIR;</div><div class="line">            SPIR R(m);</div><div class="line"></div><div class="line">            SparseMatrix&lt;SPIR, SparseMatrixFormat::SparseSeq &gt; B (R);</div><div class="line">            B.read(input);</div><div class="line"></div><div class="line">        </div><div class="line">        <span class="comment">//  cout &lt;&lt; &quot;matrix is &quot; &lt;&lt; B.rowdim() &lt;&lt; &quot; by &quot; &lt;&lt; B.coldim() &lt;&lt; endl;</span></div><div class="line">        <span class="comment">//  if (B.rowdim() &lt;= 10 &amp;&amp; B.coldim() &lt;= 10) B.write(cout) &lt;&lt; endl;</span></div><div class="line"></div><div class="line">            Integer p(m), im(m);</div><div class="line">                <span class="comment">// Should better ask user to give the prime !!!</span></div><div class="line">            Givaro::IntPrimeDom IPD;</div><div class="line">            <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> k = 2; ( ( ! IPD.isprime(p) ) &amp;&amp; (p &gt; 1) ); ++k)</div><div class="line">                Givaro::root( p, im, k );</div><div class="line"></div><div class="line">            <span class="comment">// using Sparse Elimination</span></div><div class="line">            <a name="_a1"></a><a class="code" href="class_lin_box_1_1_power_gauss_domain.html">LinBox::PowerGaussDomain&lt; SPIR &gt;</a> PGD( R );</div><div class="line">            vector&lt;pair&lt;size_t,SPIR::Element&gt; &gt; vec;</div><div class="line">            LinBox::Permutation&lt;SPIR&gt; Q(R,B.coldim());</div><div class="line"></div><div class="line">            PGD(vec, B, Q, (int32_t)m, (int32_t)p);</div><div class="line"></div><div class="line">            <span class="keyword">typedef</span> list&lt; SPIR::Element &gt; List;</div><div class="line">            List L;</div><div class="line">            <span class="keywordflow">for</span> ( <span class="keyword">auto</span> p_it = vec.begin(); p_it != vec.end(); ++p_it) {</div><div class="line">                <span class="keywordflow">for</span>(<span class="keywordtype">size_t</span> i = 0; i &lt; (size_t) p_it-&gt;first; ++i)</div><div class="line">                    L.push_back((SPIR::Element)p_it-&gt;second);</div><div class="line">            }</div><div class="line">            <span class="keywordtype">size_t</span> M = (B.rowdim() &gt; B.coldim() ? B.coldim() : B.rowdim());</div><div class="line">            <span class="keywordtype">size_t</span> Min = (B.rowdim() &lt; B.coldim() ? B.coldim() : B.rowdim());</div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = L.size(); i &lt; M; ++i)</div><div class="line">                L.push_back(0);</div><div class="line"></div><div class="line">            list&lt;pair&lt;SPIR::Element, size_t&gt; &gt; pl;</div><div class="line"></div><div class="line">            <a class="code" href="blackbox_2smith_8_c.html#a2dbc867fa25de06ae61108deaf57f1fa">distinct</a>(L.begin(), L.end(), pl);</div><div class="line"></div><div class="line">            <span class="comment">//cout &lt;&lt; &quot;#&quot;;</span></div><div class="line"></div><div class="line">             <span class="comment">//display(local.begin(), local.end());</span></div><div class="line">            display(pl.begin(), pl.end());</div><div class="line">            <span class="comment">//cout &lt;&lt; &quot;# local, PowerGaussDomain&lt;int32_t&gt;(&quot; &lt;&lt; M &lt;&lt; &quot;), n = &quot; &lt;&lt; Min &lt;&lt; endl;</span></div><div class="line"></div><div class="line"></div><div class="line">            chrono.stop();</div><div class="line">            cout &lt;&lt; <span class="stringliteral">&quot;T&quot;</span> &lt;&lt; M &lt;&lt; <span class="stringliteral">&quot;local(PowerGaussDomain&lt;int32_t&gt;)&quot;</span> &lt;&lt; m &lt;&lt; <span class="stringliteral">&quot; := &quot;</span></div><div class="line">                &lt;&lt; chrono &lt;&lt; endl;</div><div class="line">        }</div><div class="line">        </div><div class="line"></div><div class="line">    } <span class="keywordflow">else</span> {<span class="comment">// argc is 2, so use valence method over ZZ</span></div><div class="line"></div><div class="line">        Givaro::ZRing&lt;Integer&gt; ZZ;</div><div class="line">        <span class="keyword">typedef</span> SparseMatrix&lt;Givaro::ZRing&lt;Integer&gt; &gt;  Blackbox;</div><div class="line">        Blackbox A (ZZ);</div><div class="line">        A.read(input);</div><div class="line">    </div><div class="line">    <span class="comment">//  cout &lt;&lt; &quot;A is &quot; &lt;&lt; A.rowdim() &lt;&lt; &quot; by &quot; &lt;&lt; A.coldim() &lt;&lt; endl;</span></div><div class="line">    </div><div class="line">        Givaro::ZRing&lt;Integer&gt;::Element val_A;</div><div class="line">    </div><div class="line">        chrono.start();</div><div class="line">        <a name="_a2"></a><a class="code" href="class_lin_box_1_1_transpose.html">Transpose&lt;Blackbox&gt;</a> T(&amp;A);</div><div class="line">        <span class="keywordflow">if</span> (A.rowdim() &gt; A.coldim()) {<span class="comment">//ata</span></div><div class="line">            <a name="_a3"></a><a class="code" href="class_lin_box_1_1_compose.html">Compose&lt; Transpose&lt;Blackbox&gt;</a>, Blackbox &gt; C (&amp;T, &amp;A);</div><div class="line">        <span class="comment">//  cout &lt;&lt; &quot;A^T A is &quot; &lt;&lt; C.rowdim() &lt;&lt; &quot; by &quot; &lt;&lt; C.coldim() &lt;&lt; endl;</span></div><div class="line">            <a name="a4"></a><a class="code" href="group__solutions.html#ga2e2b7150bd78ae61406d8768554abd14">valence</a>(val_A, C);</div><div class="line">        }</div><div class="line">        <span class="keywordflow">else</span> <span class="keywordflow">if</span> (A.rowdim() &lt; A.coldim()) {<span class="comment">//aat</span></div><div class="line">            <a class="code" href="class_lin_box_1_1_compose.html">Compose&lt; Blackbox, Transpose&lt;Blackbox&gt;</a> &gt; C (&amp;A, &amp;T);</div><div class="line">        <span class="comment">//  cout &lt;&lt; &quot;A A^T is &quot; &lt;&lt; C.rowdim() &lt;&lt; &quot; by &quot; &lt;&lt; C.coldim() &lt;&lt; endl;</span></div><div class="line">            <a class="code" href="group__solutions.html#ga2e2b7150bd78ae61406d8768554abd14">valence</a>(val_A, C);</div><div class="line">        }</div><div class="line">        <span class="keywordflow">else</span> { <span class="comment">// square, just a</span></div><div class="line">            <a class="code" href="group__solutions.html#ga2e2b7150bd78ae61406d8768554abd14">valence</a>(val_A, A);</div><div class="line">        }</div><div class="line">    </div><div class="line">        <span class="comment">//cout &lt;&lt; &quot;Valence is &quot; &lt;&lt; val_A &lt;&lt; endl;</span></div><div class="line">    </div><div class="line">        vector&lt;integer&gt; Moduli;</div><div class="line">        vector&lt;size_t&gt; exponents;</div><div class="line">        Givaro::IntFactorDom&lt;&gt; FTD;</div><div class="line">    </div><div class="line">        <span class="keyword">typedef</span> pair&lt;integer,unsigned long&gt; PairIntRk;</div><div class="line">        vector&lt; PairIntRk &gt; smith;</div><div class="line">    </div><div class="line">    </div><div class="line">        <a class="code" href="group__integers.html#ga69460c665a80daebb395e45f6f76db54">integer</a> coprimeV=2;</div><div class="line">        <span class="keywordflow">while</span> ( gcd(val_A,coprimeV) &gt; 1 ) {</div><div class="line">            FTD.nextprimein(coprimeV);</div><div class="line">        }</div><div class="line">    </div><div class="line">        <span class="comment">//cout &lt;&lt; &quot;integer rank: &quot; &lt;&lt; endl;</span></div><div class="line">    </div><div class="line">        <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> coprimeR; LRank(coprimeR, argv[1], coprimeV);</div><div class="line">        smith.push_back(PairIntRk(coprimeV, coprimeR));</div><div class="line">        <span class="comment">//         cerr &lt;&lt; &quot;Rank mod &quot; &lt;&lt; coprimeV &lt;&lt; &quot; is &quot; &lt;&lt; coprimeR &lt;&lt; endl;</span></div><div class="line">    </div><div class="line">        <span class="comment">//cout &lt;&lt; &quot;Some factors (5000 factoring loop bound): &quot;;</span></div><div class="line">        FTD.set(Moduli, exponents, val_A, 5000);</div><div class="line">        vector&lt;size_t&gt;::const_iterator eit=exponents.begin();</div><div class="line">        <span class="comment">//for(vector&lt;integer&gt;::const_iterator mit=Moduli.begin();</span></div><div class="line">        <span class="comment">//    mit != Moduli.end(); ++mit,++eit)</span></div><div class="line">        <span class="comment">//  cout &lt;&lt; *mit &lt;&lt; &#39;^&#39; &lt;&lt; *eit &lt;&lt; &#39; &#39;;</span></div><div class="line">        <span class="comment">//cout &lt;&lt; endl;</span></div><div class="line">    </div><div class="line">        vector&lt;integer&gt; SmithDiagonal(coprimeR,<a name="a5"></a><a class="code" href="group__integers.html#ga69460c665a80daebb395e45f6f76db54">integer</a>(1));</div><div class="line">    </div><div class="line">        <span class="keywordflow">for</span>(vector&lt;integer&gt;::const_iterator mit=Moduli.begin();</div><div class="line">            mit != Moduli.end(); ++mit) {</div><div class="line">            <span class="keywordtype">size_t</span> r; LRank(r, argv[1], *mit);</div><div class="line">            <span class="comment">//             cerr &lt;&lt; &quot;Rank mod &quot; &lt;&lt; *mit &lt;&lt; &quot; is &quot; &lt;&lt; r &lt;&lt; endl;</span></div><div class="line">            smith.push_back(PairIntRk(*mit, r));</div><div class="line">            <span class="keywordflow">for</span>(<span class="keywordtype">size_t</span> i=r; i &lt; coprimeR; ++i)</div><div class="line">                SmithDiagonal[i] *= *mit;</div><div class="line">        }</div><div class="line">    </div><div class="line">    </div><div class="line">        eit=exponents.begin();</div><div class="line">        vector&lt;PairIntRk&gt;::const_iterator sit=smith.begin();</div><div class="line">        <span class="keywordflow">for</span>( ++sit; sit != smith.end(); ++sit, ++eit) {</div><div class="line">            <span class="keywordflow">if</span> (sit-&gt;second != coprimeR) {</div><div class="line">                vector&lt;size_t&gt; ranks;</div><div class="line">                ranks.push_back(sit-&gt;second);</div><div class="line">                <span class="keywordtype">size_t</span> effexp;</div><div class="line">                <span class="keywordflow">if</span> (*eit &gt; 1) {</div><div class="line">                    PRank(ranks, effexp, argv[1], sit-&gt;first, *eit, coprimeR);</div><div class="line">                }</div><div class="line">                <span class="keywordflow">else</span> {</div><div class="line">                    PRank(ranks, effexp, argv[1], sit-&gt;first, 2, coprimeR);</div><div class="line">                }</div><div class="line">                <span class="keywordflow">if</span> (ranks.size() == 1) ranks.push_back(coprimeR);</div><div class="line">    </div><div class="line">                <span class="keywordflow">if</span> (effexp &lt; *eit) {</div><div class="line">                    <span class="keywordflow">for</span>(<span class="keywordtype">size_t</span> expo = effexp&lt;&lt;1; ranks.back() &lt; coprimeR; expo&lt;&lt;=1) {</div><div class="line">                        PRankInteger(ranks, argv[1], sit-&gt;first, expo, coprimeR);</div><div class="line">                    }</div><div class="line">                } <span class="keywordflow">else</span> {</div><div class="line">    </div><div class="line">                    <span class="keywordflow">for</span>(<span class="keywordtype">size_t</span> expo = (*eit)&lt;&lt;1; ranks.back() &lt; coprimeR; expo&lt;&lt;=1) {</div><div class="line">                        PRank(ranks, effexp, argv[1], sit-&gt;first, expo, coprimeR);</div><div class="line">                        <span class="keywordflow">if</span> (ranks.size() &lt; expo) {</div><div class="line">         <span class="comment">//                   cerr &lt;&lt; &quot;It seems we need a larger prime power, it will take longer ...&quot; &lt;&lt; endl;</span></div><div class="line">                                <span class="comment">// break;</span></div><div class="line">                            PRankInteger(ranks, argv[1], sit-&gt;first, expo, coprimeR);</div><div class="line">                        }</div><div class="line">                    }</div><div class="line">                }</div><div class="line">    </div><div class="line">                vector&lt;size_t&gt;::const_iterator rit=ranks.begin();</div><div class="line">                <span class="comment">// size_t modrank = *rit;</span></div><div class="line">                <span class="keywordflow">for</span>(++rit; rit!= ranks.end(); ++rit) {</div><div class="line">                    <span class="keywordflow">if</span> ((*rit)&gt;= coprimeR) <span class="keywordflow">break</span>;</div><div class="line">                    <span class="keywordflow">for</span>(<span class="keywordtype">size_t</span> i=(*rit); i &lt; coprimeR; ++i)</div><div class="line">                        SmithDiagonal[i] *= sit-&gt;first;</div><div class="line">                    <span class="comment">// modrank = *rit;</span></div><div class="line">                }</div><div class="line">            }</div><div class="line">        }</div><div class="line">    </div><div class="line">        <a class="code" href="group__integers.html#ga69460c665a80daebb395e45f6f76db54">integer</a> si=1;</div><div class="line">        <span class="keywordtype">size_t</span> num=0;</div><div class="line">        cout &lt;&lt; <span class="charliteral">&#39;(&#39;</span>;</div><div class="line">        <span class="keywordflow">for</span>( vector&lt;integer&gt;::const_iterator dit=SmithDiagonal.begin();</div><div class="line">             dit != SmithDiagonal.end(); ++dit) {</div><div class="line">            <span class="keywordflow">if</span> (*dit == si) ++num;</div><div class="line">            <span class="keywordflow">else</span> {</div><div class="line">                <span class="keywordflow">if</span> (num &gt; 0)</div><div class="line">                    cout &lt;&lt; <span class="charliteral">&#39;[&#39;</span> &lt;&lt; si &lt;&lt; <span class="charliteral">&#39;,&#39;</span> &lt;&lt; num &lt;&lt; <span class="stringliteral">&quot;] &quot;</span>;</div><div class="line">                num=1;</div><div class="line">                si = *dit;</div><div class="line">            }</div><div class="line">        }</div><div class="line">        cout &lt;&lt; <span class="charliteral">&#39;[&#39;</span> &lt;&lt; si &lt;&lt; <span class="charliteral">&#39;,&#39;</span> &lt;&lt; num &lt;&lt; <span class="stringliteral">&quot;] )&quot;</span> &lt;&lt; endl;</div><div class="line">        chrono.stop();</div><div class="line">        cout &lt;&lt; <span class="stringliteral">&quot;T&quot;</span> &lt;&lt; A.rowdim() &lt;&lt; <span class="stringliteral">&quot;smithvalence(ZRing&lt;Integer&gt;):= &quot;</span></div><div class="line">            &lt;&lt; chrono &lt;&lt; endl;</div><div class="line">    </div><div class="line">    }</div><div class="line">    <span class="keywordflow">return</span> 0;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> I1, <span class="keyword">class</span> Lp&gt;</div><div class="line"><span class="keywordtype">void</span> <a class="code" href="blackbox_2smith_8_c.html#a2dbc867fa25de06ae61108deaf57f1fa">distinct</a> (I1 a, I1 b, Lp&amp; c)</div><div class="line">{</div><div class="line">    <span class="keyword">typename</span> iterator_traits&lt;I1&gt;::value_type e;</div><div class="line">    <span class="keywordtype">size_t</span> count = 0;</div><div class="line">    <span class="keywordflow">if</span> (a != b) {e = *a; ++a; count = 1;}</div><div class="line">    <span class="keywordflow">else</span> <span class="keywordflow">return</span>;</div><div class="line">    <span class="keywordflow">while</span> (a != b)</div><div class="line">    {  <span class="keywordflow">if</span> (*a == e) ++count;</div><div class="line">    <span class="keywordflow">else</span></div><div class="line">    { c.push_back(<span class="keyword">typename</span> Lp::value_type(e, count));</div><div class="line">    e = *a; count = 1;</div><div class="line">    }</div><div class="line">    ++a;</div><div class="line">    }</div><div class="line">    c.push_back(<span class="keyword">typename</span> Lp::value_type(e, count));</div><div class="line">    <span class="keywordflow">return</span>;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> I&gt;</div><div class="line"><span class="keywordtype">void</span> display(I b, I e)</div><div class="line">{ cout &lt;&lt; <span class="stringliteral">&quot;(&quot;</span>;</div><div class="line"> <span class="keywordflow">for</span> (I p = b; p != e; ++p) cout &lt;&lt; <span class="charliteral">&#39;[&#39;</span> &lt;&lt; p-&gt;first &lt;&lt; <span class="stringliteral">&quot;,&quot;</span> &lt;&lt; p-&gt;second &lt;&lt; <span class="stringliteral">&quot;] &quot;</span>;</div><div class="line"> cout &lt;&lt; <span class="stringliteral">&quot;)&quot;</span> &lt;&lt; endl;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> Int_type, <span class="keyword">class</span> Ring_type&gt;</div><div class="line"><span class="keywordtype">void</span> runpoweroftworank(ifstream&amp; input, <span class="keyword">const</span> <span class="keywordtype">size_t</span> exponent, <span class="keywordtype">size_t</span> StPr) {</div><div class="line">    <span class="keyword">typedef</span> std::vector&lt;std::pair&lt;size_t,Int_type&gt; &gt; Smith_t;</div><div class="line">    <span class="keyword">typedef</span> Ring_type Ring; <span class="comment">// signed ?</span></div><div class="line">    <span class="keyword">typedef</span> LinBox::SparseMatrix&lt;Ring, </div><div class="line">        <a name="_a6"></a><a class="code" href="class_lin_box_1_1_sparse_matrix_format_1_1_sparse_seq.html">LinBox::SparseMatrixFormat::SparseSeq</a> &gt; SparseMat;</div><div class="line"></div><div class="line">    Smith_t local;</div><div class="line">    Ring R;</div><div class="line">    <a name="_a7"></a><a class="code" href="class_lin_box_1_1_matrix_stream.html">LinBox::MatrixStream&lt;Ring&gt;</a> ms( R, input );</div><div class="line">    SparseMat A (ms);</div><div class="line"></div><div class="line">    input.close();</div><div class="line">    <a name="_a8"></a><a class="code" href="class_lin_box_1_1_power_gauss_domain_power_of_two.html">LinBox::PowerGaussDomainPowerOfTwo&lt; Int_type &gt;</a> PGD;</div><div class="line">    LinBox::GF2 F2;</div><div class="line">    Permutation&lt;GF2&gt; Q(F2,A.coldim());</div><div class="line">            </div><div class="line">    cout &lt;&lt; <span class="stringliteral">&quot;A is &quot;</span> &lt;&lt; A.rowdim() &lt;&lt; <span class="stringliteral">&quot; by &quot;</span> &lt;&lt; A.coldim() &lt;&lt; endl;</div><div class="line">    <span class="keywordflow">if</span> (A.rowdim() &lt;= 20 &amp;&amp; A.coldim() &lt;= 20) A.write(cout,Tag::FileFormat::Maple) &lt;&lt; endl;</div><div class="line"></div><div class="line">    Givaro::Timer tim; </div><div class="line">    tim.clear(); tim.start();</div><div class="line">    <span class="keywordflow">if</span> (StPr)</div><div class="line">        PGD(local, A, Q, exponent, StPr);</div><div class="line">    <span class="keywordflow">else</span></div><div class="line">        PGD(local, A, Q, exponent);</div><div class="line">    tim.stop();</div><div class="line"></div><div class="line">    R.write(std::cout &lt;&lt; <span class="stringliteral">&quot;Local Smith Form &quot;</span>) &lt;&lt; <span class="stringliteral">&quot; : &quot;</span> &lt;&lt; std::endl &lt;&lt; <span class="charliteral">&#39;(&#39;</span>;</div><div class="line">    <span class="keywordtype">int</span> num = A.rowdim();</div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">auto</span>  p = local.begin(); p != local.end(); ++p) {</div><div class="line">        std::cout &lt;&lt; <span class="charliteral">&#39;[&#39;</span> &lt;&lt; p-&gt;second &lt;&lt; <span class="charliteral">&#39;,&#39;</span> &lt;&lt; p-&gt;first &lt;&lt; <span class="stringliteral">&quot;] &quot;</span>;</div><div class="line">        num -= p-&gt;first;</div><div class="line">    }</div><div class="line">    <span class="keywordflow">if</span> (num &gt; 0) std::cout &lt;&lt; <span class="charliteral">&#39;[&#39;</span> &lt;&lt; F2.zero &lt;&lt; <span class="charliteral">&#39;,&#39;</span> &lt;&lt; num &lt;&lt; <span class="stringliteral">&quot;] &quot;</span>;</div><div class="line">    std::cout &lt;&lt; <span class="charliteral">&#39;)&#39;</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    std::cerr &lt;&lt; tim &lt;&lt; std::endl;</div><div class="line">} <span class="comment">// runpowerof2</span></div><div class="line"></div><div class="line"><span class="comment">// Local Variables:</span></div><div class="line"><span class="comment">// mode: C++</span></div><div class="line"><span class="comment">// tab-width: 4</span></div><div class="line"><span class="comment">// indent-tabs-mode: nil</span></div><div class="line"><span class="comment">// c-basic-offset: 4</span></div><div class="line"><span class="comment">// End:</span></div><div class="line"><span class="comment">// vim:sts=4:sw=4:ts=4:et:sr:cino=&gt;s,f0,{0,g0,(0,\:0,t0,+0,=s</span></div></div><!-- fragment --> </div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Wed Jun 5 2019 14:05:42 for linbox by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
