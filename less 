tests/test-sum.C:76:/* Test 1: Application of zero matrix onto random vectors
tests/test-sum.C:78: * Construct a random diagonal matrix and its opposite, then construct
tests/test-sum.C:79: * the sum of the two matrices. Apply to random vectors and check that
tests/test-sum.C:165: * Compute a random diagonal matrix and use the transpose test in test-generic.h
tests/test-sum.C:170: * iterations - Number of random vectors to which to apply matrix
tests/test-sum.C:180:	commentator().start ("Testing random transpose", "testRandomTranspose", iterations);
tests/test-sum.C:186:		r.random (d[i]);
tests/test-matrix-domain.C:1122:/* Test 11: black box multiply by I on the left, test on random vectors
tests/test-matrix-domain.C:1176:/* Test 12: black box multiply by I on the right, test on random vectors
tests/test-matrix-domain.C:1264:	// Create a random row permutation
tests/test-matrix-domain.C:1269:			row1 = (unsigned)(MT.randomInt () % M.rowdim ());
tests/test-matrix-domain.C:1270:			row2 = (unsigned)(MT.randomInt () % M.rowdim ());
tests/test-matrix-domain.C:1307:	// Create a random column permutation
tests/test-matrix-domain.C:1312:			col1 = (unsigned)(MT.randomInt () % M.coldim ());
tests/test-matrix-domain.C:1313:			col2 = (unsigned)(MT.randomInt () % M.coldim ());
tests/test-matrix-domain.C:1529:	Diagonal<Field> A1b (F, n, true); // random, nonsingular
tests/.gitignore:45:test-random-matrix
tests/test-rat-minpoly.C:60: * Constructs a random diagonal rational matrix D such that d[2i,2i]=d[2i+1,2i+1]
tests/test-diagonal.C:61:/* Test 1: Application of identity matrix onto random vectors
tests/test-diagonal.C:63: * Construct the identity matrix and a series of randomly-generated
tests/test-diagonal.C:138: * Generates a random diagonal nonsingular matrix and computes its minimal
tests/test-diagonal.C:144: * iterations - Number of random diagonal matrices to construct
tests/test-diagonal.C:155:	commentator().start ("Testing random minpoly", "testRandomMinpoly", stream.m ());
tests/test-diagonal.C:205:	// try it with the random cstor of diagonal
tests/test-diagonal.C:211:				<< "ERROR: zeroes in random diagonal" << endl;
tests/test-diagonal.C:221: * Compute a random diagonal matrix and use the linearity test in test-generic.h
tests/test-diagonal.C:227: * iterations - Number of random vectors to which to apply matrix
tests/test-diagonal.C:240:	commentator().start ("Testing random transpose", "testRandomLinearity", stream1.m ());
tests/test-diagonal.C:264: * Compute a random diagonal matrix and use the transpose test in test-generic.h
tests/test-diagonal.C:269: * iterations - Number of random vectors to which to apply matrix
tests/test-diagonal.C:282:	commentator().start ("Testing random transpose", "testRandomTranspose", stream1.m ());
tests/test-cra.C:35:#include "linbox/randiter/random-prime.h"
tests/test-cra.C:102:		residues[i] = Integer::random(PrimeSize-1);
tests/test-cra.C:175:	size_t resbits = 1 + (random() % (pprod.bitsize() - 1));
tests/test-cra.C:176:	Integer actual = Integer::random(resbits);
tests/test-cra.C:245:	size_t resbits = 1 + (random() % maxbits);
tests/test-cra.C:246:	Integer actual = Integer::random(resbits);
tests/test-cra.C:321:			residues[i][j] = Integer::random(PrimeSize-1);
tests/test-cra.C:412:				residues[k].setEntry( i,j,Integer::random(PrimeSize-1) );
tests/test-cra.C:506:			residues[k][i] = Integer::random(PrimeSize-1) ;
tests/test-cra.C:578:    Integer act_den = Integer::random(bitlen);
tests/test-cra.C:581:        num_elt = Integer::random<false>(bitlen);
tests/test-cra.C:710:			residues[k][i] = Integer::random(PrimeSize-1) ;
tests/checker.C:71:skip("test-givaro-fields", "may fail on small fields because of supposed non-randomness or failure to find a non trivial element");
tests/test-opencl-domain.C:127:				A.setEntry(k,j,G.random(tmp));
tests/test-opencl-domain.C:128:				B.setEntry(k,j,G.random(tmp));
tests/test-opencl-domain.C:177:				A_b.setEntry(k,j,G.random(tmp));
tests/test-opencl-domain.C:178:				B.setEntry(k,j,G.random(tmp));
tests/test-opencl-domain.C:229:				A.setEntry(k,j,G.random(tmp));
tests/test-opencl-domain.C:230:				B_b.setEntry(k,j,G.random(tmp));
tests/test-opencl-domain.C:283:				A.setEntry(k,j,G.random(tmp));
tests/test-opencl-domain.C:284:				B.setEntry(k,j,G.random(tmp));
tests/test-opencl-domain.C:285:				C.setEntry(k,j,G.random(tmp));
tests/test-opencl-domain.C:335:				A.setEntry(k,j,G.random(tmp));
tests/test-opencl-domain.C:336:				B.setEntry(k,j,G.random(tmp));
tests/test-opencl-domain.C:337:				C_b.setEntry(k,j,G.random(tmp));
tests/test-opencl-domain.C:390:				A.setEntry(k,j,G.random(tmp));
tests/test-opencl-domain.C:391:				B.setEntry(k,j,G.random(tmp));
tests/test-opencl-domain.C:392:				C.setEntry(k,j,G.random(tmp));
tests/test-opencl-domain.C:442:				A.setEntry(k,j,G.random(tmp));
tests/test-opencl-domain.C:443:				B.setEntry(k,j,G.random(tmp));
tests/test-opencl-domain.C:444:				C_b.setEntry(k,j,G.random(tmp));
tests/test-opencl-domain.C:497:				A.setEntry(k,j,G.random(tmp));
tests/test-opencl-domain.C:498:				B.setEntry(k,j,G.random(tmp));
tests/test-opencl-domain.C:499:				C.setEntry(k,j,G.random(tmp));
tests/test-opencl-domain.C:549:				A.setEntry(k,j,G.random(tmp));
tests/test-opencl-domain.C:550:				B.setEntry(k,j,G.random(tmp));
tests/test-opencl-domain.C:551:				C_b.setEntry(k,j,G.random(tmp));
tests/test-opencl-domain.C:604:				A.setEntry(k,j,G.random(tmp));
tests/test-opencl-domain.C:605:				B.setEntry(k,j,G.random(tmp));
tests/test-opencl-domain.C:606:				C.setEntry(k,j,G.random(tmp));
tests/test-opencl-domain.C:679:				A.setEntry(k,j,G.random(tmp));
tests/test-opencl-domain.C:680:				B.setEntry(k,j,G.random(tmp));
tests/test-opencl-domain.C:681:				C_b.setEntry(k,j,G.random(tmp));
tests/test-opencl-domain.C:733:				A.setEntry(k,j,G.random(tmp));
tests/test-opencl-domain.C:734:				B.setEntry(k,j,G.random(tmp));
tests/test-opencl-domain.C:818:			A.setEntry(k,j,G.random(temp));
tests/test-opencl-domain.C:819:			B.setEntry(k,j,G.random(temp));
tests/test-la-block-lanczos.C:55:/* Test 1: Test solution of random system
tests/test-la-block-lanczos.C:66:	commentator().start ("Testing random solve (Block Lanczos)", "testRandomSolve", y_stream.size ());
tests/test-la-block-lanczos.C:128:/* Test 2: Test sampling of nullspace of random system
tests/test-butterfly.C:237: * Construct a random dense matrix and a submatrix thereof. Call testLinearity
tests/test-butterfly.C:243: * N - Number of random vectors to which to apply
tests/test-butterfly.C:253:	commentator().start ("Testing random linearity", "testRandomLinearity", v1_stream.size ());
tests/test-butterfly.C:271: * Construct a random dense matrix and a submatrix thereof. Call testLinearity
tests/test-butterfly.C:277: * N - Number of random vectors to which to apply
tests/test-butterfly.C:287:	commentator().start ("Testing random transpose", "testRandomTranspose", v1_stream.size ());
tests/test-butterfly.C:316:		{ 'k', "-k K", "K nonzero elements in random vectors.",        TYPE_INT,     &k },
tests/test-permutation.C:121:	P.random();
tests/test-smith-form-local.C:53:/** @brief Test 1: Invariant factors of random dense matrices.
tests/test-smith-form-local.C:55: * Construct a random matrix which is equivalent to a random diagonal matrix,
tests/test-smith-form-local.C:212:		r.random(e);
tests/test-smith-form-local.C:213:		do { r.random(e); } while (R.isZero(e));
tests/test-ftrmm.C:67:	size_t M    = random()%(_LB_MAX_SZ/2) ;
tests/test-ftrmm.C:68:	size_t N    = random()%(_LB_MAX_SZ/2) ; // B is £MxN£ in a £ldb x rows£ table
tests/test-ftrmm.C:69:	size_t ldb  = random()%_LB_MAX_SZ ;
tests/test-ftrmm.C:70:	size_t lda  = random()%_LB_MAX_SZ ;
tests/test-ftrmm.C:72:	while (ldb<N) ldb = random()%_LB_MAX_SZ; // £ldb >= N£
tests/test-ftrmm.C:79:	while (lda<K) lda = random()%_LB_MAX_SZ; // £ldba>= N£
tests/test-ftrmm.C:110:	for (size_t i = 0 ; i < rows*lda ; ++i) G.random( *(A+i) ) ;
tests/test-ftrmm.C:118:	for (size_t i = 0 ; i < rows*ldb  ; ++i) G.random( *(B+i) ) ;
tests/test-ftrmm.C:128:	Gn.random(alpha);
tests/test-ftrmm.C:383:		for (size_t i = 0 ; i < K ; ++i) Gn.random(*(A+i*(lda+1))) ; // invertible diag !
tests/test-ftrmm.C:418:	size_t M    = random()%_LB_MAX_SZ+1 ;
tests/test-ftrmm.C:419:	size_t N    = random()%_LB_MAX_SZ+1 ;
tests/test-ftrmm.C:420:	size_t lda  = random()%_LB_MAX_SZ+1 ;
tests/test-ftrmm.C:441:	for (size_t i = 0 ; i < M*lda ; ++i) G.random( *(A+i) ) ;
tests/test-ftrmm.C:447:	size_t r = (size_t)random()%M ;
tests/test-ftrmm.C:475:	r = (size_t)random()%N ;
tests/test-ftrmm.C:510:	size_t M    = random()%_LB_MAX_SZ+1 ; // rows of (t)A and C
tests/test-ftrmm.C:511:	size_t N    = random()%_LB_MAX_SZ+1 ; // cols of (t)B and C
tests/test-ftrmm.C:512:	size_t K    = random()%_LB_MAX_SZ+1 ; // cols of (t)A, rows of (t)B
tests/test-ftrmm.C:516:	size_t lda  = random()%(_LB_MAX_SZ/2) ;
tests/test-ftrmm.C:518:	size_t ldb  = random()%(_LB_MAX_SZ/2) ;
tests/test-ftrmm.C:520:	size_t ldc  = N+random()%(_LB_MAX_SZ/2) ;
tests/test-ftrmm.C:544:	// G.random(alpha);
tests/test-ftrmm.C:545:	// G.random(beta);
tests/test-ftrmm.C:546:	alpha = (Element)Integer::random<false>(2);
tests/test-ftrmm.C:547:	if (abs(alpha) > 1.5 ) G.random(alpha);
tests/test-ftrmm.C:549:	beta  = Integer::random<false>(2);
tests/test-ftrmm.C:550:	if (abs(beta) >1.5 ) G.random(beta);
tests/test-ftrmm.C:566:	for (size_t i = 0 ; i < rowA*lda ; ++i) G.random( *(A+i) ) ;
tests/test-ftrmm.C:567:	for (size_t i = 0 ; i < rowB*ldb ; ++i) G.random( *(B+i) ) ;
tests/test-ftrmm.C:568:	for (size_t i = 0 ; i < rowC*ldc ; ++i) G.random( *(C+i) ) ;
tests/test-one-invariant-factor.C:38:#include "linbox/randiter/random-prime.h"
tests/test-one-invariant-factor.C:44:#include "linbox/blackbox/random-matrix.h"
tests/test-modular.C:81:		{ 't', "-t T", "Number of trials for the random iterator test.", TYPE_INT, &trials },
tests/test-modular.C:82:		{ 'c', "-c C", "Number of categories for the random iterator test.", TYPE_INT, &categories },
tests/test-modular.C:83:		{ 'H', "-H H", "History level for random iterator test.", TYPE_INT, &hist_level },
tests/test-blackbox.h:68: * randomly chosen u and v. Check whether the results are equal. In theory, this
tests/test-blackbox.h:75: * iterations - Number of random vectors to which to apply matrix
tests/test-blackbox.h:196:		r.random (alpha);
tests/test-blackbox.h:370:	//r.random(x);
tests/test-isposdef.C:59:	// iterations since there is randomness in the alg (though none in this test).
tests/test-smith-form-binary.C:35:#include "linbox/randiter/random-prime.h"
tests/test-smith-form-binary.C:41:#include "linbox/blackbox/random-matrix.h"
tests/test-plain-domain.C:1114:/* Test 11: black box multiply by I on the left, test on random vectors
tests/test-plain-domain.C:1168:/* Test 12: black box multiply by I on the right, test on random vectors
tests/test-plain-domain.C:1256:	// Create a random row permutation
tests/test-plain-domain.C:1261:			row1 = (unsigned)(MT.randomInt () % M.rowdim ());
tests/test-plain-domain.C:1262:			row2 = (unsigned)(MT.randomInt () % M.rowdim ());
tests/test-plain-domain.C:1299:	// Create a random column permutation
tests/test-plain-domain.C:1304:			col1 = (unsigned)(MT.randomInt () % M.coldim ());
tests/test-plain-domain.C:1305:			col2 = (unsigned)(MT.randomInt () % M.coldim ());
tests/test-plain-domain.C:1532:	Diagonal<Field> A1b (F, n, true); // random, nonsingular
tests/test-solveCRA.pc:868:extern long int random (void) ;
tests/test-solveCRA.pc:871:extern void srandom (unsigned int __seed) ;
tests/test-solveCRA.pc:890:struct random_data
tests/test-solveCRA.pc:901:extern int random_r (struct random_data * __buf,
tests/test-solveCRA.pc:904:extern int srandom_r (unsigned int __seed, struct random_data *__buf)
tests/test-solveCRA.pc:909:   struct random_data * __buf)
tests/test-solveCRA.pc:913:         struct random_data * __buf)
tests/test-solveCRA.pc:4275:  struct random_access_iterator_tag : public bidirectional_iterator_tag { };
tests/test-solveCRA.pc:4308:      typedef random_access_iterator_tag iterator_category;
tests/test-solveCRA.pc:4319:      typedef random_access_iterator_tag iterator_category;
tests/test-solveCRA.pc:4404:               random_access_iterator_tag)
tests/test-solveCRA.pc:4451:              random_access_iterator_tag)
tests/test-solveCRA.pc:5570:    struct __copy_move<false, false, random_access_iterator_tag>
tests/test-solveCRA.pc:5588:    struct __copy_move<_IsMove, true, random_access_iterator_tag>
tests/test-solveCRA.pc:5691:    struct __copy_move_backward<false, false, random_access_iterator_tag>
tests/test-solveCRA.pc:5705:    struct __copy_move_backward<_IsMove, true, random_access_iterator_tag>
tests/test-solveCRA.pc:5913:    struct __lc_rai<random_access_iterator_tag, random_access_iterator_tag>
tests/test-solveCRA.pc:24187:    random_shuffle(_RAIter, _RAIter);
tests/test-solveCRA.pc:24191:    random_shuffle(_RAIter, _RAIter,
tests/test-solveCRA.pc:24914:       _Predicate __pred, random_access_iterator_tag)
tests/test-solveCRA.pc:25079:     std::random_access_iterator_tag)
tests/test-solveCRA.pc:25509:       random_access_iterator_tag)
tests/test-solveCRA.pc:25659:      random_access_iterator_tag)
tests/test-solveCRA.pc:27503:    random_shuffle(_RandomAccessIterator __first, _RandomAccessIterator __last)
tests/test-solveCRA.pc:27523:    random_shuffle(_RandomAccessIterator __first, _RandomAccessIterator __last,
tests/test-solveCRA.pc:28464: unsigned long __gmp_urandomb_ui (gmp_randstate_t, unsigned long);
tests/test-solveCRA.pc:28467: unsigned long __gmp_urandomm_ui (gmp_randstate_t, unsigned long);
tests/test-solveCRA.pc:28876: void __gmpz_random (mpz_ptr, mp_size_t);
tests/test-solveCRA.pc:28879: void __gmpz_random2 (mpz_ptr, mp_size_t);
tests/test-solveCRA.pc:28894: void __gmpz_rrandomb (mpz_ptr, gmp_randstate_t, mp_bitcnt_t);
tests/test-solveCRA.pc:28994: void __gmpz_urandomb (mpz_ptr, gmp_randstate_t, mp_bitcnt_t);
tests/test-solveCRA.pc:28997: void __gmpz_urandomm (mpz_ptr, gmp_randstate_t, mpz_srcptr);
tests/test-solveCRA.pc:29263: void __gmpf_random2 (mpf_ptr, mp_size_t, mp_exp_t);
tests/test-solveCRA.pc:29326: void __gmpf_urandomb (mpf_t, gmp_randstate_t, mp_bitcnt_t);
tests/test-solveCRA.pc:29420: void __gmpn_random (mp_ptr, mp_size_t);
tests/test-solveCRA.pc:29423: void __gmpn_random2 (mp_ptr, mp_size_t);
tests/test-solveCRA.pc:30834:  { __gmpz_urandomb(z, s, l); }
tests/test-solveCRA.pc:30836:  { __gmpz_urandomm(z, s, w); }
tests/test-solveCRA.pc:30838:  { __gmpf_urandomb(f, s, prec); }
tests/test-solveCRA.pc:32114:class __gmp_urandomb_value { };
tests/test-solveCRA.pc:32115:class __gmp_urandomm_value { };
tests/test-solveCRA.pc:32118:class __gmp_expr<mpz_t, __gmp_urandomb_value>
tests/test-solveCRA.pc:32130:class __gmp_expr<mpz_t, __gmp_urandomm_value>
tests/test-solveCRA.pc:32143:class __gmp_expr<mpf_t, __gmp_urandomb_value>
tests/test-solveCRA.pc:32215:  __gmp_expr<mpz_t, __gmp_urandomb_value> get_z_bits(mp_bitcnt_t l)
tests/test-solveCRA.pc:32216:  { return __gmp_expr<mpz_t, __gmp_urandomb_value>(state, l); }
tests/test-solveCRA.pc:32217:  __gmp_expr<mpz_t, __gmp_urandomb_value> get_z_bits(const mpz_class &z)
tests/test-solveCRA.pc:32221:  __gmp_expr<mpz_t, __gmp_urandomm_value> get_z_range(const mpz_class &z)
tests/test-solveCRA.pc:32222:  { return __gmp_expr<mpz_t, __gmp_urandomm_value>(state, z); }
tests/test-solveCRA.pc:32224:  __gmp_expr<mpf_t, __gmp_urandomb_value> get_f(mp_bitcnt_t prec = 0)
tests/test-solveCRA.pc:32225:  { return __gmp_expr<mpf_t, __gmp_urandomb_value>(state, prec); }
tests/test-solveCRA.pc:33477:  : public std::iterator<std::random_access_iterator_tag, bool>
tests/test-solveCRA.pc:39374:  static inline Integer& random_lessthan (Integer& r, const Integer & m);
tests/test-solveCRA.pc:39375:  static inline Integer& random_lessthan (Integer& r, const Integer & m) ;
tests/test-solveCRA.pc:39377:  static inline Integer& random_lessthan_2exp (Integer& r, const uint64_t & m);
tests/test-solveCRA.pc:39379:  static inline Integer& random_lessthan_2exp (Integer& r, const uint64_t & m) ;
tests/test-solveCRA.pc:39381:  static inline Integer random_lessthan_2exp (const uint64_t & m);
tests/test-solveCRA.pc:39382:  static inline Integer random_lessthan_2exp (const uint64_t & m) ;
tests/test-solveCRA.pc:39384:  static inline Integer& random_lessthan (Integer& r, const uint64_t & m) ;
tests/test-solveCRA.pc:39386:  static inline Integer& random_lessthan (Integer& r, const uint64_t & m) ;
tests/test-solveCRA.pc:39388:  static inline Integer random_lessthan (const T & m);
tests/test-solveCRA.pc:39390:  static inline Integer random_lessthan (const T & m) ;
tests/test-solveCRA.pc:39395:  static inline Integer& random_exact_2exp (Integer& r, const uint64_t & m) ;
tests/test-solveCRA.pc:39396:  static inline Integer& random_exact_2exp (Integer& r, const uint64_t & m);
tests/test-solveCRA.pc:39400:  static inline Integer& random_exact (Integer& r, const Integer & s) ;
tests/test-solveCRA.pc:39401:  static inline Integer& random_exact (Integer& r, const Integer & s) ;
tests/test-solveCRA.pc:39404:  static inline Integer& random_exact (Integer& r, const uint64_t & m) ;
tests/test-solveCRA.pc:39405:  static inline Integer& random_exact (Integer& r, const uint64_t & m) ;
tests/test-solveCRA.pc:39407:  static inline Integer& random_exact (Integer& r, const T & m) ;
tests/test-solveCRA.pc:39409:  static inline Integer& random_exact (Integer& r, const T & m) ;
tests/test-solveCRA.pc:39411:  static inline Integer random_exact (const T & s) ;
tests/test-solveCRA.pc:39413:  static inline Integer random_exact (const T & s) ;
tests/test-solveCRA.pc:39416:  static inline Integer& random_between (Integer& r, const Integer& m, const Integer&M) ;
tests/test-solveCRA.pc:39417:  static inline Integer random_between (const Integer& m, const Integer &M) ;
tests/test-solveCRA.pc:39418:  static inline Integer& random_between_2exp (Integer& r, const uint64_t& m,
tests/test-solveCRA.pc:39420:  static inline Integer& random_between (Integer& r, const uint64_t& m,
tests/test-solveCRA.pc:39422:  static inline Integer random_between_2exp (const uint64_t & m,
tests/test-solveCRA.pc:39424:  static inline Integer random_between (const uint64_t & m,
tests/test-solveCRA.pc:39427:  static inline Integer random_between (const R & m, const R & M) ;
tests/test-solveCRA.pc:39429:  static inline Integer & random_between (Integer &r, const R & m, const R & M);
tests/test-solveCRA.pc:39434:  static inline Integer& random (Integer& r, const T & m) ;
tests/test-solveCRA.pc:39436:  static inline Integer& random (Integer& r, const T & m) ;
tests/test-solveCRA.pc:39438:  static inline Integer random(const T & sz) ;
tests/test-solveCRA.pc:39440:  static inline Integer random(const T & sz) ;
tests/test-solveCRA.pc:39442:  static inline Integer random();
tests/test-solveCRA.pc:39443:  static inline Integer random();
tests/test-solveCRA.pc:39445:  static inline Integer nonzerorandom(const T & sz) ;
tests/test-solveCRA.pc:39447:  static inline Integer& nonzerorandom (Integer& r, const T& size) ;
tests/test-solveCRA.pc:39449:  static inline Integer nonzerorandom(const T & sz) ;
tests/test-solveCRA.pc:39451:  static inline Integer& nonzerorandom (Integer& r, const T& size) ;
tests/test-solveCRA.pc:39452:  static inline Integer nonzerorandom() ;
tests/test-solveCRA.pc:39870:# 1 "/home/zhg/soft/builds/include/givaro/givrandom.h" 1
tests/test-solveCRA.pc:39871:# 22 "/home/zhg/soft/builds/include/givaro/givrandom.h"
tests/test-solveCRA.pc:39921:# 23 "/home/zhg/soft/builds/include/givaro/givrandom.h" 2
tests/test-solveCRA.pc:40029:# 27 "/home/zhg/soft/builds/include/givaro/givrandom.h" 2
tests/test-solveCRA.pc:40356:# 28 "/home/zhg/soft/builds/include/givaro/givrandom.h" 2
tests/test-solveCRA.pc:40358:# 28 "/home/zhg/soft/builds/include/givaro/givrandom.h"
tests/test-solveCRA.pc:40370:        typedef GivRandom random_generator;
tests/test-solveCRA.pc:40411:# 90 "/home/zhg/soft/builds/include/givaro/givrandom.h"
tests/test-solveCRA.pc:40460:  if (Integer::random(1U)) return true;
tests/test-solveCRA.pc:40465: Integer& Integer::random_lessthan (Integer& r, const Integer & m)
tests/test-solveCRA.pc:40477: Integer& Integer::random_lessthan (Integer& r, const Integer & m)
tests/test-solveCRA.pc:40479:  return random_lessthan<true>(r,m);
tests/test-solveCRA.pc:40483: Integer& Integer::random_lessthan_2exp (Integer& r, const uint64_t & m)
tests/test-solveCRA.pc:40497: Integer Integer::random_lessthan_2exp (const uint64_t & m)
tests/test-solveCRA.pc:40500:  random_lessthan_2exp<ALWAYSPOSITIVE>(r,m);
tests/test-solveCRA.pc:40506: Integer& Integer::random_lessthan (Integer& r, const uint64_t & m)
tests/test-solveCRA.pc:40508:  return Integer::random_lessthan_2exp<ALWAYSPOSITIVE>(r,m);
tests/test-solveCRA.pc:40512: Integer Integer::random_lessthan (const T & m)
tests/test-solveCRA.pc:40515:  return Integer::random_lessthan<ALWAYSPOSITIVE>(res,(typename Signed_Trait<T>::unsigned_type)m);
tests/test-solveCRA.pc:40518: Integer& Integer::random_lessthan_2exp (Integer& r, const uint64_t & m)
tests/test-solveCRA.pc:40520:  return random_lessthan_2exp<true>(r,m);
tests/test-solveCRA.pc:40523: Integer Integer::random_lessthan_2exp (const uint64_t & m)
tests/test-solveCRA.pc:40525:  return random_lessthan_2exp<true>(m);
tests/test-solveCRA.pc:40528: Integer& Integer::random_lessthan (Integer& r, const uint64_t & m)
tests/test-solveCRA.pc:40530:  return random_lessthan<true>(r,m);
tests/test-solveCRA.pc:40534: Integer Integer::random_lessthan (const T & m)
tests/test-solveCRA.pc:40536:  return random_lessthan<true>(m);
tests/test-solveCRA.pc:40540: Integer& Integer::random_exact (Integer& r, const Integer & s)
tests/test-solveCRA.pc:40543:  Integer::random_exact_2exp<ALWAYSPOSITIVE>(r,t);
tests/test-solveCRA.pc:40546: Integer& Integer::random_exact (Integer& r, const uint64_t & m)
tests/test-solveCRA.pc:40548:  return Integer::random_exact<true>(r,m);
tests/test-solveCRA.pc:40550: Integer& Integer::random_exact (Integer& r, const Integer & s)
tests/test-solveCRA.pc:40552:  return Integer::random_exact<true>(r,s);
tests/test-solveCRA.pc:40555: Integer& Integer::random_exact (Integer& r, const T & m)
tests/test-solveCRA.pc:40557:  return Integer::random_exact<ALWAYSPOSITIVE>(r,static_cast<uint64_t>(m));
tests/test-solveCRA.pc:40560: Integer& Integer::random_exact (Integer& r, const T & m)
tests/test-solveCRA.pc:40562:  return Integer::random_exact(r,static_cast<uint64_t>(m));
tests/test-solveCRA.pc:40566: Integer Integer::random_exact (const T & s)
tests/test-solveCRA.pc:40568:  return Integer::random_exact<true>(s) ;
tests/test-solveCRA.pc:40572: Integer& Integer::random_exact_2exp (Integer& r, const uint64_t & m)
tests/test-solveCRA.pc:40574:  if (m) random_lessthan_2exp<true>(r,m-1_ui64);
tests/test-solveCRA.pc:40584: Integer& Integer::random_exact_2exp (Integer& r, const uint64_t & m)
tests/test-solveCRA.pc:40586:  return Integer::random_exact_2exp<true>(r,m);
tests/test-solveCRA.pc:40590: Integer& Integer::random_exact (Integer& r, const uint64_t & m)
tests/test-solveCRA.pc:40592:  return Integer::random_exact_2exp<ALWAYSPOSITIVE>(r,m) ;
tests/test-solveCRA.pc:40596: Integer Integer::random_exact (const T & s)
tests/test-solveCRA.pc:40599:  return random_exact<ALWAYSPOSITIVE>(res,s);
tests/test-solveCRA.pc:40606: Integer& Integer::random_between (Integer& r, const Integer& m, const Integer&M)
tests/test-solveCRA.pc:40613:  random_lessthan(r,Integer(M-m));
tests/test-solveCRA.pc:40618: Integer Integer::random_between (const Integer& m, const Integer &M)
tests/test-solveCRA.pc:40621:  return random_between(r,m,M);
tests/test-solveCRA.pc:40626: Integer Integer::random_between (const R & m, const R & M)
tests/test-solveCRA.pc:40628:  return Integer::random_between(static_cast<uint64_t>(m),
tests/test-solveCRA.pc:40632: Integer & Integer::random_between (Integer &r, const R & m, const R & M)
tests/test-solveCRA.pc:40634:  return Integer::random_between(r,static_cast<uint64_t>(m),
tests/test-solveCRA.pc:40643: Integer& Integer::random_between_2exp (Integer& r, const uint64_t& m, const uint64_t &M)
tests/test-solveCRA.pc:40650:  r = nonzerorandom((uint64_t)M-m);
tests/test-solveCRA.pc:40651:  Integer r1 = random_lessthan_2exp(m);
tests/test-solveCRA.pc:40657: Integer Integer::random_between_2exp (const uint64_t & m, const uint64_t &M)
tests/test-solveCRA.pc:40660:  return random_between_2exp(r,m,M);
tests/test-solveCRA.pc:40664: Integer Integer::random_between (const uint64_t & m, const uint64_t &M)
tests/test-solveCRA.pc:40666:  return random_between_2exp(m,M) ;
tests/test-solveCRA.pc:40670: Integer& Integer::random_between (Integer& r, const uint64_t& m, const uint64_t &M)
tests/test-solveCRA.pc:40672:  return random_between_2exp(r,m,M);
tests/test-solveCRA.pc:40680: Integer& Integer::random (Integer& r, const T & m)
tests/test-solveCRA.pc:40682:  return Integer::random_lessthan<ALWAYSPOSITIVE>(r, (typename Signed_Trait<T>::unsigned_type) m) ;
tests/test-solveCRA.pc:40687: Integer Integer::random(const T & sz)
tests/test-solveCRA.pc:40689:  return Integer::random_lessthan<ALWAYSPOSITIVE,T>(sz);
tests/test-solveCRA.pc:40692: Integer Integer::random()
tests/test-solveCRA.pc:40694:  return Integer::random(sizeof(mp_limb_t)*8) ;
tests/test-solveCRA.pc:40697: Integer Integer::random()
tests/test-solveCRA.pc:40699:  Integer rez = Integer::random(sizeof(mp_limb_t)*8) ;
tests/test-solveCRA.pc:40705: Integer& Integer::random (Integer& r, const T & m)
tests/test-solveCRA.pc:40707:  return Integer::random<true,T>(r,m);
tests/test-solveCRA.pc:40711: Integer Integer::random(const T & sz)
tests/test-solveCRA.pc:40713:  return Integer::random<true>(sz);
tests/test-solveCRA.pc:40721: Integer Integer::nonzerorandom(const T & sz)
tests/test-solveCRA.pc:40724:  while(isZero(Integer::random<ALWAYSPOSITIVE,T>(r, sz) )) {} ;
tests/test-solveCRA.pc:40731: Integer& Integer::nonzerorandom (Integer& r, const T& size)
tests/test-solveCRA.pc:40733:  while (isZero(Integer::random<ALWAYSPOSITIVE,T>(r,size))) {} ;
tests/test-solveCRA.pc:40738: Integer Integer::nonzerorandom(const T & sz)
tests/test-solveCRA.pc:40740:  return Integer::nonzerorandom<true>(sz);
tests/test-solveCRA.pc:40743: Integer& Integer::nonzerorandom (Integer& r, const T& size)
tests/test-solveCRA.pc:40745:  return Integer::nonzerorandom<true>(r,size);
tests/test-solveCRA.pc:40747: Integer Integer::nonzerorandom()
tests/test-solveCRA.pc:40749:  Integer rez = Integer::nonzerorandom(sizeof(mp_limb_t)*8) ;
tests/test-solveCRA.pc:40932:     return ring().random (_givrand, elt);
tests/test-solveCRA.pc:40934:      Element& random(Element& elt) const
tests/test-solveCRA.pc:40943:      Element random() const
tests/test-solveCRA.pc:41010:            return ring().random(_givrand, elt);
tests/test-solveCRA.pc:41013:        Element& random(Element& elt) const
tests/test-solveCRA.pc:41025:        Element random() const
tests/test-solveCRA.pc:41061:      Element& random (Element& a) const
tests/test-solveCRA.pc:41069:      Element random () const
tests/test-solveCRA.pc:41096:      do _r.random(a); while ( ring().isZero(a));
tests/test-solveCRA.pc:41099:    Element& random(Element &a) const
tests/test-solveCRA.pc:41108:    Element random() const
tests/test-solveCRA.pc:41121:# 1 "/home/zhg/soft/builds/include/givaro/random-integer.h" 1
tests/test-solveCRA.pc:41122:# 12 "/home/zhg/soft/builds/include/givaro/random-integer.h"
tests/test-solveCRA.pc:41124:# 13 "/home/zhg/soft/builds/include/givaro/random-integer.h" 2
tests/test-solveCRA.pc:41135:# 35 "/home/zhg/soft/builds/include/givaro/random-integer.h"
tests/test-solveCRA.pc:41203:  const Integer_Type & randomInteger() const
tests/test-solveCRA.pc:41208:  Integer_Type & random (Integer_Type & a) const
tests/test-solveCRA.pc:41214:            return this->random(a);
tests/test-solveCRA.pc:41218:            Element a; this->random(a); return a;
tests/test-solveCRA.pc:41220:        Element random () const {
tests/test-solveCRA.pc:41252:   return Givaro::Integer::random_exact<_Unsigned>(a,_bits);
tests/test-solveCRA.pc:41255:   return Givaro::Integer::random_lessthan<_Unsigned>(a,_bits);
tests/test-solveCRA.pc:41727:  template< class MyRandIter > Rep& random(MyRandIter&, Rep& r, long s = 1) const
tests/test-solveCRA.pc:41729:   return Integer::random(r,s);
tests/test-solveCRA.pc:41731:  template< class MyRandIter > Rep& random(MyRandIter&, Rep& r, const Rep& b) const
tests/test-solveCRA.pc:41733:   return Integer::random(r,b);
tests/test-solveCRA.pc:41735:  template< class MyRandIter > Rep& nonzerorandom(MyRandIter&, Rep& r, long s = 1) const
tests/test-solveCRA.pc:41737:   return Integer::nonzerorandom(r,s);
tests/test-solveCRA.pc:41739:  template< class MyRandIter > Rep& nonzerorandom (MyRandIter&,Rep& r, const Rep& b) const
tests/test-solveCRA.pc:41741:   return Integer::nonzerorandom(r,b);
tests/test-solveCRA.pc:42461:  template< class Random > Element& random(Random& g, Element& r) const
tests/test-solveCRA.pc:42463:  template< class Random > Element& nonzerorandom(Random& g, Element& a) const
tests/test-solveCRA.pc:42831:        template< class Random > Element& random(Random& g, Element& r) const
tests/test-solveCRA.pc:42833:        template< class Random > Element& nonzerorandom(Random& g, Element& a) const
tests/test-solveCRA.pc:43137:        template< class Random > Element& random(Random& g, Element& r) const
tests/test-solveCRA.pc:43139:        template< class Random > Element& nonzerorandom(Random& g, Element& a) const
tests/test-solveCRA.pc:43165:            Givaro::Integer::random_lessthan(elt,_ring.residu());
tests/test-solveCRA.pc:43170:        Element& random(Element& elt)
tests/test-solveCRA.pc:43179:        Element random()
tests/test-solveCRA.pc:43455:        template< class Random > Element& random(Random& g, Element& r) const
tests/test-solveCRA.pc:43457:        template< class Random > Element& nonzerorandom(Random& g, Element& a) const
tests/test-solveCRA.pc:43785:        template< class Random > Element& random(Random& g, Element& r) const
tests/test-solveCRA.pc:43787:        template< class Random > Element& nonzerorandom(Random& g, Element& a) const
tests/test-solveCRA.pc:45952:# 1 "/home/zhg/soft/builds/include/recint/rurandom.h" 1
tests/test-solveCRA.pc:45953:# 41 "/home/zhg/soft/builds/include/recint/rurandom.h"
tests/test-solveCRA.pc:45954:# 1 "/usr/include/c++/5/random" 1 3
tests/test-solveCRA.pc:45955:# 32 "/usr/include/c++/5/random" 3
tests/test-solveCRA.pc:45957:# 33 "/usr/include/c++/5/random" 3
tests/test-solveCRA.pc:45958:# 42 "/home/zhg/soft/builds/include/recint/rurandom.h" 2
tests/test-solveCRA.pc:46373:        template< class Random > Element& random(Random& g, Element& r) const
tests/test-solveCRA.pc:46375:        template< class Random > Element& nonzerorandom(Random& g, Element& a) const
tests/test-solveCRA.pc:46376:        { while (this->isZero(random(g, a))) { } return a; }
tests/test-solveCRA.pc:47187:        template< class Random > Element& random(const Random& g, Element& r) const
tests/test-solveCRA.pc:47189:        template< class Random > Element& nonzerorandom(const Random& g, Element& a) const
tests/test-solveCRA.pc:51107:      typedef std::random_access_iterator_tag iterator_category;
tests/test-solveCRA.pc:56602:  virtual Element &random (Element &a) = 0;
tests/test-solveCRA.pc:56867:  ElementAbstract &random (ElementAbstract &a)
tests/test-solveCRA.pc:56872:   _randIter.random(static_cast<ElementEnvelope<Field>&> (a)._elem );
tests/test-solveCRA.pc:57552:  Element &random (Element &a) const
tests/test-solveCRA.pc:57554:   _randIter_ptr->random (*a._elem_ptr);
tests/test-solveCRA.pc:58476:  Vector& random(Vector& v)
tests/test-solveCRA.pc:58481:   for (iterator p = v.begin(); p != v.end(); ++p) r.random(*p);
tests/test-solveCRA.pc:61780:  typedef random_access_iterator_tag iterator_category;
tests/test-solveCRA.pc:61790:  typedef random_access_iterator_tag iterator_category;
tests/test-solveCRA.pc:62070: class BitVector::const_iterator : public std::iterator <std::random_access_iterator_tag, bool> {
tests/test-solveCRA.pc:62837:    template< class MyRandIter > Rep& random(MyRandIter& g, Rep& r, int64_t s = 1) const { return r=Rational(Integer::random(s), Integer::nonzerorandom(s)); }
tests/test-solveCRA.pc:62838:    template< class MyRandIter > Rep& random(MyRandIter& g, Rep& r, const Rep& b) const { Integer rnum,rden; Integer::random(rnum,b.nume()); Integer::nonzerorandom(rden,b.deno()); return r=Rational(rnum,rden); }
tests/test-solveCRA.pc:62839:    template< class MyRandIter > Rep& nonzerorandom(MyRandIter& g, Rep& r, int64_t s = 1) const { return r=Rational(Integer::nonzerorandom(s), Integer::nonzerorandom(s)); }
tests/test-solveCRA.pc:62840:    template< class MyRandIter > Rep& nonzerorandom (MyRandIter& g,Rep& r, const Rep& b) const { Integer rnum,rden; Integer::nonzerorandom(rnum,b.nume()); Integer::nonzerorandom(rden,b.deno()); return r=Rational(rnum,rden); }
tests/test-solveCRA.pc:63001: template< class Random > Element& random(Random& g, Element& r) const
tests/test-solveCRA.pc:63003: template< class Random > Element& nonzerorandom(Random& g, Element& a) const
tests/test-solveCRA.pc:63399: template< class Random > Element& random(Random& g, Element& r) const
tests/test-solveCRA.pc:63401: template< class Random > Element& nonzerorandom(Random& g, Element& a) const
tests/test-solveCRA.pc:63807:        template< class Random > Element& random(Random& g, Element& r) const
tests/test-solveCRA.pc:63809:        template< class Random > Element& nonzerorandom(Random& g, Element& a) const
tests/test-solveCRA.pc:64215:        template< class Random > Element& random(Random& g, Element& r) const
tests/test-solveCRA.pc:64217:        template< class Random > Element& nonzerorandom(Random& g, Element& a) const
tests/test-solveCRA.pc:65863:        template< class RandomIterator > Rep& random(RandomIterator& g, Rep& r) const;
tests/test-solveCRA.pc:65865:        template< class RandomIterator > Rep& random(RandomIterator& g, Rep& r, uint64_t s) const ;
tests/test-solveCRA.pc:65867:        template< class RandomIterator > Rep& random(RandomIterator& g, Rep& r, Degree s) const ;
tests/test-solveCRA.pc:65870:        template< class RandomIterator > Rep& random(RandomIterator& g, Rep& r, const Rep& b) const;
tests/test-solveCRA.pc:65872:        template< class RandomIterator > Rep& nonzerorandom(RandomIterator& g, Rep& r) const;
tests/test-solveCRA.pc:65873:        template< class RandomIterator > Rep& nonzerorandom(RandomIterator& g, Rep& r, uint64_t s) const;
tests/test-solveCRA.pc:65874:        template< class RandomIterator > Rep& nonzerorandom(RandomIterator& g, Rep& r, Degree s) const ;
tests/test-solveCRA.pc:65875:        template< class RandomIterator > Rep& nonzerorandom(RandomIterator& g, Rep& r, const Rep& b) const;
tests/test-solveCRA.pc:66347: inline typename Poly1Dom<Domain,Dense>::Rep& Poly1Dom<Domain,Dense>::random(RandomIterator& g, Rep& r) const
tests/test-solveCRA.pc:66349:  return random(g, r,Degree(0));
tests/test-solveCRA.pc:66354: inline typename Poly1Dom<Domain,Dense>::Rep& Poly1Dom<Domain,Dense>::random(RandomIterator& g, Rep& r, uint64_t s) const
tests/test-solveCRA.pc:66356:  return random(g, r,Degree(s-1));
tests/test-solveCRA.pc:66362: inline typename Poly1Dom<Domain,Dense>::Rep& Poly1Dom<Domain,Dense>::random(RandomIterator& g, typename Poly1Dom<Domain,Dense>::Rep& r, Degree d) const
tests/test-solveCRA.pc:66365:  _domain.nonzerorandom(g, r[(size_t)d.value()]);
tests/test-solveCRA.pc:66367:                    _domain.random(g,r[(size_t)i]);
tests/test-solveCRA.pc:66372: inline typename Poly1Dom<Domain,Dense>::Rep& Poly1Dom<Domain,Dense>::random(RandomIterator& g, Rep& r, const Rep& b) const
tests/test-solveCRA.pc:66374:  return random(g, r,b.size());
tests/test-solveCRA.pc:66379: inline typename Poly1Dom<Domain,Dense>::Rep& Poly1Dom<Domain,Dense>::nonzerorandom(RandomIterator& g, Rep& r) const
tests/test-solveCRA.pc:66381:  return random(g, r);
tests/test-solveCRA.pc:66386: inline typename Poly1Dom<Domain,Dense>::Rep& Poly1Dom<Domain,Dense>::nonzerorandom(RandomIterator& g, Rep& r, uint64_t s) const
tests/test-solveCRA.pc:66388:  return random(g, r,s);
tests/test-solveCRA.pc:66392: inline typename Poly1Dom<Domain,Dense>::Rep& Poly1Dom<Domain,Dense>::nonzerorandom(RandomIterator& g, Rep& r, Degree d) const
tests/test-solveCRA.pc:66394:  return random(g, r,d);
tests/test-solveCRA.pc:66398: inline typename Poly1Dom<Domain,Dense>::Rep& Poly1Dom<Domain,Dense>::nonzerorandom(RandomIterator& g, Rep& r, const Rep& b) const
tests/test-solveCRA.pc:66400:  return random(g, r,b);
tests/test-solveCRA.pc:68177:    random(g,a,n);
tests/test-solveCRA.pc:68198:    random(g,A,n);
tests/test-solveCRA.pc:68236:  typedef MyRandIter random_generator;
tests/test-solveCRA.pc:68560:  this->random(gen, y, n);
tests/test-solveCRA.pc:68787:    this->random(gen,r,n);
tests/test-solveCRA.pc:69020:  typedef RandomIterator random_generator;
tests/test-solveCRA.pc:69157:  Element& random_irreducible (Element& P, Degree n) const ;
tests/test-solveCRA.pc:69159:  Element& creux_random_irreducible (Element& P, Degree n) const ;
tests/test-solveCRA.pc:69175:  Rep& random_prim_root(Rep& P, Rep& R, Degree n) const ;
tests/test-solveCRA.pc:69178:  Rep& give_random_prim_root(Rep& R, const Rep& F) const ;
tests/test-solveCRA.pc:69203:  bool find_irred_randomial(Element &R, Degree n, Residue MOD) const;
tests/test-solveCRA.pc:69204:  bool find_irred_randomial(Element &R, Degree n, bool MOD) const;
tests/test-solveCRA.pc:69206:  bool find_irred_randomial(Element &R, Degree n, Residue MOD, Element IXE) const;
tests/test-solveCRA.pc:69207:  bool find_irred_randomial(Element &R, Degree n, bool MOD, Element IXE) const;
tests/test-solveCRA.pc:69209:  bool find_irred_randomial2(Element &R, Degree n, Residue MOD, Element IXE) const;
tests/test-solveCRA.pc:69210:  bool find_irred_randomial2(Element &R, Degree n, bool MOD, Element IXE) const;
tests/test-solveCRA.pc:69239:            this->gcd(G1, G, this->random(_g, G2, dG-1) );
tests/test-solveCRA.pc:69288:            this->gcd(G1, G, this->random(_g, tmp, d));
tests/test-solveCRA.pc:70004:    this->random(this->_g, A, p);
tests/test-solveCRA.pc:70051:    this->nonzerorandom(this->_g, alea, p);
tests/test-solveCRA.pc:70074:    this->nonzerorandom(this->_g, alea, p);
tests/test-solveCRA.pc:70660: inline bool Poly1FactorDom<Domain,Tag, RandomIterator>::find_irred_randomial (Element& R, Degree n, Residue MOD) const
tests/test-solveCRA.pc:70667:   this->random( (RandomIterator&)_g, R, n);
tests/test-solveCRA.pc:70686: inline bool Poly1FactorDom<Domain,Tag, RandomIterator>::find_irred_randomial (Element& R, Degree n, bool MOD) const
tests/test-solveCRA.pc:70693:   this->random( (RandomIterator&)_g, R, n);
tests/test-solveCRA.pc:70710: inline bool Poly1FactorDom<Domain,Tag, RandomIterator>::find_irred_randomial (Element& R, Degree n, Residue MOD, Element IXE) const
tests/test-solveCRA.pc:70716:   this->random( (RandomIterator&)_g, R, n);
tests/test-solveCRA.pc:70735: inline bool Poly1FactorDom<Domain,Tag, RandomIterator>::find_irred_randomial (Element& R, Degree n, bool MOD, Element IXE) const
tests/test-solveCRA.pc:70742:   this->random( (RandomIterator&)_g, R, n);
tests/test-solveCRA.pc:70759: inline bool Poly1FactorDom<Domain,Tag, RandomIterator>::find_irred_randomial2 (Element& R, Degree n, Residue MOD, Element IXE) const
tests/test-solveCRA.pc:70765:   this->random( (RandomIterator&)_g, R, n);
tests/test-solveCRA.pc:70784: inline bool Poly1FactorDom<Domain,Tag, RandomIterator>::find_irred_randomial2 (Element& R, Degree n, bool MOD, Element IXE) const
tests/test-solveCRA.pc:70790:   this->random( (RandomIterator&)_g, R, n);
tests/test-solveCRA.pc:70806: inline typename Poly1FactorDom<Domain,Tag, RandomIterator>::Element& Poly1FactorDom<Domain,Tag, RandomIterator>::creux_random_irreducible (Element& R, Degree n) const
tests/test-solveCRA.pc:70836:  if (find_irred_randomial(R,n,MOD))
tests/test-solveCRA.pc:70839:   throw "could not find a random polynomial" ;
tests/test-solveCRA.pc:70844: inline typename Poly1FactorDom<Domain,Tag, RandomIterator>::Element& Poly1FactorDom<Domain,Tag, RandomIterator>::random_irreducible (Element& R, Degree n) const
tests/test-solveCRA.pc:70851:  if (find_irred_randomial(R,n,MOD))
tests/test-solveCRA.pc:70854:   throw "could not find a random polynomial" ;
tests/test-solveCRA.pc:70896:  if (find_irred_randomial(R,n,MOD,IXE))
tests/test-solveCRA.pc:70899:   throw "could not find a random polynomial" ;
tests/test-solveCRA.pc:70936:  if (find_irred_randomial2(R,n,MOD,IXE))
tests/test-solveCRA.pc:70939:   throw "could not find a random polynomial" ;
tests/test-solveCRA.pc:71076:   this->random( (RandomIterator&)_g, R, n);
tests/test-solveCRA.pc:71088: inline typename Poly1FactorDom<Domain,Tag, RandomIterator>::Rep& Poly1FactorDom<Domain,Tag, RandomIterator>::give_random_prim_root(Rep& R, const Rep& F) const
tests/test-solveCRA.pc:71096:   this->random( (RandomIterator&)_g, R, n);
tests/test-solveCRA.pc:71108: inline typename Poly1FactorDom<Domain,Tag, RandomIterator>::Rep& Poly1FactorDom<Domain,Tag, RandomIterator>::random_prim_root(Rep& P, Rep& R, Degree n) const
tests/test-solveCRA.pc:71113:  return give_prim_root(R, random_irreducible(P,n));
tests/test-solveCRA.pc:71386: template<class RandIter> Rep& random(RandIter& g, Rep& r) const ;
tests/test-solveCRA.pc:71387: template<class RandIter> Rep& random(RandIter& g, Rep& r, int64_t s) const ;
tests/test-solveCRA.pc:71388: template<class RandIter> Rep& random(RandIter& g, Rep& r, const Rep& b) const ;
tests/test-solveCRA.pc:71389: template<class RandIter> Rep& nonzerorandom(RandIter& g, Rep& r) const ;
tests/test-solveCRA.pc:71390: template<class RandIter> Rep& nonzerorandom(RandIter& g, Rep& r, int64_t s) const ;
tests/test-solveCRA.pc:71391: template<class RandIter> Rep& nonzerorandom(RandIter& g, Rep& r, const Rep& b) const ;
tests/test-solveCRA.pc:72258:    inline typename GFqDom<TT>::Rep& GFqDom<TT>::nonzerorandom(randIter& g, Rep& a) const
tests/test-solveCRA.pc:72265:    inline typename GFqDom<TT>::Rep& GFqDom<TT>::random(randIter& g, Rep& a) const
tests/test-solveCRA.pc:72272:    inline typename GFqDom<TT>::Rep& GFqDom<TT>::random(randIter& g, Rep& r, int64_t s) const
tests/test-solveCRA.pc:72274:        return random(g,r);
tests/test-solveCRA.pc:72279:    inline typename GFqDom<TT>::Rep& GFqDom<TT>::random(randIter& g, Rep& r, const Rep& b) const
tests/test-solveCRA.pc:72281:        return random(g,r);
tests/test-solveCRA.pc:72285:    inline typename GFqDom<TT>::Rep& GFqDom<TT>::nonzerorandom(randIter& g, Rep& r, int64_t s) const
tests/test-solveCRA.pc:72287:        return nonzerorandom(g,r);
tests/test-solveCRA.pc:72291:    inline typename GFqDom<TT>::Rep& GFqDom<TT>::nonzerorandom(randIter& g, Rep& r, const Rep& b) const
tests/test-solveCRA.pc:72293:        return nonzerorandom(g,r);
tests/test-solveCRA.pc:76890:  uint32_t randomInt ();
tests/test-solveCRA.pc:76891:  uint32_t randomInt () const
tests/test-solveCRA.pc:76892:  { return const_cast<MersenneTwister&>(*this).randomInt();}
tests/test-solveCRA.pc:76895:  uint32_t randomIntRange (uint32_t start, uint32_t end);
tests/test-solveCRA.pc:76896:  uint32_t randomIntRange (uint32_t start, uint32_t end) const
tests/test-solveCRA.pc:76897:  { return const_cast<MersenneTwister&>(*this).randomIntRange(start,end); }
tests/test-solveCRA.pc:76900:  double randomDouble ();
tests/test-solveCRA.pc:76901:  double randomDouble () const
tests/test-solveCRA.pc:76902:  { return const_cast<MersenneTwister&>(*this).randomDouble(); }
tests/test-solveCRA.pc:76905:  double randomDoubleRange (double start, double end)
tests/test-solveCRA.pc:76906:  { return randomDouble () * (end - start) + start; }
tests/test-solveCRA.pc:76907:  double randomDoubleRange (double start, double end) const
tests/test-solveCRA.pc:76908:  { return const_cast<MersenneTwister&>(*this).randomDoubleRange(start,end); }
tests/test-solveCRA.pc:76964:  bool &random (bool &a) const
tests/test-solveCRA.pc:76966:   return a = MT.randomIntRange (0, 2);
tests/test-solveCRA.pc:76975:  BitVector::reference random (BitVector::reference a) const
tests/test-solveCRA.pc:76976:  { return a = MT.randomIntRange (0, 2); }
tests/test-solveCRA.pc:76978:  std::vector<bool>::reference random (std::vector<bool>::reference a) const
tests/test-solveCRA.pc:76979:  { return a = MT.randomIntRange (0, 2); }
tests/test-solveCRA.pc:76987:  ElementAbstract &random (ElementAbstract &a) const
tests/test-solveCRA.pc:76991:   random (tmp);
tests/test-solveCRA.pc:76996:  uint32_t& random (uint32_t& a) const
tests/test-solveCRA.pc:76997:  { return a = MT.randomInt(); }
tests/test-solveCRA.pc:77014: struct MTrandomInt {
tests/test-solveCRA.pc:77018:   return MT.randomInt();
tests/test-solveCRA.pc:77023: struct MTrandomInt<64> {
tests/test-solveCRA.pc:77027:   uint64_t tmp = MT.randomInt();
tests/test-solveCRA.pc:77029:   return tmp += MT.randomInt();
tests/test-solveCRA.pc:79709:  VD.random(x);
tests/test-solveCRA.pc:81893:    G.random(*(X+i));
tests/test-solveCRA.pc:81898:    G.random(*(X+i*incX));
tests/test-solveCRA.pc:82879:        rmint<K, MG_INACTIVE>& random();
tests/test-solveCRA.pc:83907:# 1 "/home/zhg/soft/builds/include/recint/rmrandom.h" 1
tests/test-solveCRA.pc:83908:# 43 "/home/zhg/soft/builds/include/recint/rmrandom.h"
tests/test-solveCRA.pc:84789:# 1 "/home/zhg/soft/builds/include/recint/rrandom.h" 1
tests/test-solveCRA.pc:84790:# 48 "/home/zhg/soft/builds/include/recint/rrandom.h"
tests/test-solveCRA.pc:85013:        rmint<K, MG_ACTIVE>& random();
tests/test-solveCRA.pc:85028:# 44 "/home/zhg/soft/builds/include/recint/rmrandom.h" 2
tests/test-solveCRA.pc:85029:# 52 "/home/zhg/soft/builds/include/recint/rmrandom.h"
tests/test-solveCRA.pc:85049:    inline rmint<K, MG_INACTIVE>& rmint<K, MG_INACTIVE>::random()
tests/test-solveCRA.pc:85056:    inline rmint<K, MG_ACTIVE>& rmint<K, MG_ACTIVE>::random()
tests/test-solveCRA.pc:92567:            G.random(v[j]);
tests/test-solveCRA.pc:105117:  template< class Random > Element& random(const Random& g, Element& r) const { return init(r, g()); }
tests/test-solveCRA.pc:105118:  template< class Random > Element& nonzerorandom(const Random& g, Element& a) const {
tests/test-solveCRA.pc:105748:     integer::random_exact_2exp(prime, _pbits-1);
tests/test-solveCRA.pc:105778:    integer::random_exact_2exp(prime, _pbits-1);
tests/test-solveCRA.pc:105937:     integer::random_exact_2exp(prime, _pbits-1);
tests/test-solveCRA.pc:105962:    integer::random_exact_2exp(prime, _pbits-1);
tests/test-solveCRA.pc:106063:        typename RNS::Element& random(typename RNS::Element& elt) const {
tests/test-solveCRA.pc:106066:                iter.random( *coefficient );
tests/test-solveCRA.pc:106073:            return this->random(elt);
tests/test-solveCRA.pc:106080:        typename RNS::Element random() const {
tests/test-solveCRA.pc:107025:   typename RNS::Element& random(typename RNS::Element& elt) const {
tests/test-solveCRA.pc:107028:    integer::random_exact<true>(tmp,_F._p);
tests/test-solveCRA.pc:118918:            G.random(lambda);
tests/test-solveCRA.pc:123537:# 1 "/home/zhg/soft/builds/include/fflas-ffpack/utils/fflas_randommatrix.h" 1
tests/test-solveCRA.pc:123538:# 44 "/home/zhg/soft/builds/include/fflas-ffpack/utils/fflas_randommatrix.h"
tests/test-solveCRA.pc:123540:# 56 "/home/zhg/soft/builds/include/fflas-ffpack/utils/fflas_randommatrix.h"
tests/test-solveCRA.pc:123548:                    if (!F.isZero(G.random (A[i*lda+j])))
tests/test-solveCRA.pc:123552:# 77 "/home/zhg/soft/builds/include/fflas-ffpack/utils/fflas_randommatrix.h"
tests/test-solveCRA.pc:123560:# 95 "/home/zhg/soft/builds/include/fflas-ffpack/utils/fflas_randommatrix.h"
tests/test-solveCRA.pc:123566:                G.random (A[i*lda+j]);
tests/test-solveCRA.pc:123569:# 113 "/home/zhg/soft/builds/include/fflas-ffpack/utils/fflas_randommatrix.h"
tests/test-solveCRA.pc:123576:# 131 "/home/zhg/soft/builds/include/fflas-ffpack/utils/fflas_randommatrix.h"
tests/test-solveCRA.pc:123587:                    G.random (A[i*lda+j]);
tests/test-solveCRA.pc:123592:                    G.random (A[i*lda+j]);
tests/test-solveCRA.pc:123603:                    nzG.random (A[i*(lda+1)]);
tests/test-solveCRA.pc:123608:# 172 "/home/zhg/soft/builds/include/fflas-ffpack/utils/fflas_randommatrix.h"
tests/test-solveCRA.pc:123629:# 201 "/home/zhg/soft/builds/include/fflas-ffpack/utils/fflas_randommatrix.h"
tests/test-solveCRA.pc:123649:# 231 "/home/zhg/soft/builds/include/fflas-ffpack/utils/fflas_randommatrix.h"
tests/test-solveCRA.pc:123695:# 287 "/home/zhg/soft/builds/include/fflas-ffpack/utils/fflas_randommatrix.h"
tests/test-solveCRA.pc:123802:# 407 "/home/zhg/soft/builds/include/fflas-ffpack/utils/fflas_randommatrix.h"
tests/test-solveCRA.pc:123820:            nzG.random (L [i*N+j]);
tests/test-solveCRA.pc:123822:                G.random (L [l*N+j]);
tests/test-solveCRA.pc:123840:# 457 "/home/zhg/soft/builds/include/fflas-ffpack/utils/fflas_randommatrix.h"
tests/test-solveCRA.pc:123849:# 478 "/home/zhg/soft/builds/include/fflas-ffpack/utils/fflas_randommatrix.h"
tests/test-solveCRA.pc:123874:# 514 "/home/zhg/soft/builds/include/fflas-ffpack/utils/fflas_randommatrix.h"
tests/test-solveCRA.pc:123883:# 535 "/home/zhg/soft/builds/include/fflas-ffpack/utils/fflas_randommatrix.h"
tests/test-solveCRA.pc:123897:# 560 "/home/zhg/soft/builds/include/fflas-ffpack/utils/fflas_randommatrix.h"
tests/test-solveCRA.pc:123905:# 579 "/home/zhg/soft/builds/include/fflas-ffpack/utils/fflas_randommatrix.h"
tests/test-solveCRA.pc:123919:# 603 "/home/zhg/soft/builds/include/fflas-ffpack/utils/fflas_randommatrix.h"
tests/test-solveCRA.pc:123927:# 620 "/home/zhg/soft/builds/include/fflas-ffpack/utils/fflas_randommatrix.h"
tests/test-solveCRA.pc:123935:# 636 "/home/zhg/soft/builds/include/fflas-ffpack/utils/fflas_randommatrix.h"
tests/test-solveCRA.pc:124462:  nzg.random (*(K + i*ldk +i));
tests/test-solveCRA.pc:125130:    g.random (*Ui);
tests/test-solveCRA.pc:126512:            g.random(*(X + i * incX));
tests/test-solveCRA.pc:126553:            g.random(*(X + i * incX));
tests/test-solveCRA.pc:126990:    _r.random (*i);
tests/test-solveCRA.pc:127457:    val = MT.randomDouble ();
tests/test-solveCRA.pc:127460:     _r.random (*i);
tests/test-solveCRA.pc:127528:    val = MT.randomDouble ();
tests/test-solveCRA.pc:127538:    _r.random (x);
tests/test-solveCRA.pc:127603:    _r.random (x);
tests/test-solveCRA.pc:127604:    while (!_field.isZero (v[idx = MT.randomIntRange (0, (uint32_t)_n)])) ;
tests/test-solveCRA.pc:127665:    val = MT.randomDouble ();
tests/test-solveCRA.pc:127675:    _r.random (x);
tests/test-solveCRA.pc:127972:    *i = MTrandomInt<64>()(MT);
tests/test-solveCRA.pc:128058:   val = (double) MT.randomDouble ();
tests/test-solveCRA.pc:128591:  _pD.creux_random_irreducible( _irred, (int64_t)_extension_order );
tests/test-solveCRA.pc:128609:                    _pD.creux_random_irreducible( _irred, eo);
tests/test-solveCRA.pc:128611:                    _pD.random_irreducible( _irred, eo);
tests/test-solveCRA.pc:128629:                        _pD.creux_random_irreducible( _irred, (int64_t) _extension_order);
tests/test-solveCRA.pc:128631:                        _pD.random_irreducible( _irred, (int64_t) _extension_order);
tests/test-solveCRA.pc:128823: template<class RandIter> Element& random(RandIter& g, Element& r) const
tests/test-solveCRA.pc:128825:         return _pD.random(g,r,Degree((int64_t)_exponent-1));
tests/test-solveCRA.pc:128827: template<class RandIter> Element& random(RandIter& g, Element& r, int64_t s) const
tests/test-solveCRA.pc:128829:         return _pD.random(g,r,(s>=_exponent?_exponent-1:s));
tests/test-solveCRA.pc:128831: template<class RandIter> Element& random(RandIter& g, Element& r, const Element& b) const
tests/test-solveCRA.pc:128833:        return _pD.random(g,r,b.size());
tests/test-solveCRA.pc:128835: template<class RandIter> Element& nonzerorandom(RandIter& g, Element& r) const
tests/test-solveCRA.pc:128837:         return _pD.nonzerorandom(g,r,Degree((int64_t)_exponent-1));
tests/test-solveCRA.pc:128839: template<class RandIter> Element& nonzerorandom(RandIter& g, Element& r, int64_t s) const
tests/test-solveCRA.pc:128841:         return _pD.nonzerorandom(g,r,(s>=_exponent?_exponent-1:s));
tests/test-solveCRA.pc:128843: template<class RandIter> Element& nonzerorandom(RandIter& g, Element& r, const Element& b) const
tests/test-solveCRA.pc:128845:        return _pD.nonzerorandom(g,r,b.size());
tests/test-solveCRA.pc:128965: Element& random(Element& elt) const
tests/test-solveCRA.pc:128984:  return this->random(elt);
tests/test-solveCRA.pc:128995:  return this->random(*x);
tests/test-solveCRA.pc:129959:  void random()
tests/test-solveCRA.pc:129964:    setEntry(i, r.random(x));
tests/test-solveCRA.pc:129968:  void random( RandIter r)
tests/test-solveCRA.pc:129972:    setEntry(i, r.random(x));
tests/test-solveCRA.pc:134161:  void random()
tests/test-solveCRA.pc:134164:   B.random();
tests/test-solveCRA.pc:134168:  void random(const Rand&)
tests/test-solveCRA.pc:134170:   return random();
tests/test-solveCRA.pc:134435:  void random();
tests/test-solveCRA.pc:134438:  void random(const T&)
tests/test-solveCRA.pc:134440:   return random() ;
tests/test-solveCRA.pc:134666: void BlasMatrix<Givaro::ZRing<Integer>, Vector<Givaro::ZRing<Integer>>::Dense >::random<size_t>(const size_t & b)
tests/test-solveCRA.pc:134673:    R.random(refEntry(i,j));
tests/test-solveCRA.pc:136329: void BlasSubmatrix<_Matrix>::random()
tests/test-solveCRA.pc:136335:    setEntry(i,j,r.random(temp));
tests/test-solveCRA.pc:142289:  Self_t& random()
tests/test-solveCRA.pc:142294:     setEntry(i, j, r.random(x));
tests/test-solveCRA.pc:142371:  using Father_t::random;
tests/test-solveCRA.pc:151207: void randomSim(Index nnz, int seed = 0);
tests/test-solveCRA.pc:151210: void randomEquiv(Index nnz, int seed = 0);
tests/test-solveCRA.pc:151265: static Element& nonzerorandom(const Field& F, typename Field::RandIter& r,Element& e);
tests/test-solveCRA.pc:151625:void SparseMatrix<Field_,SparseMatrixFormat::SMM>::randomSim(Index nz, int seed)
tests/test-solveCRA.pc:151638:  nonzerorandom(field(),r,a);
tests/test-solveCRA.pc:151639:  i = ri.randomIntRange(0, rowdim()); j = ri.randomIntRange(0, coldim());
tests/test-solveCRA.pc:151651:void SparseMatrix<Field_,SparseMatrixFormat::SMM>::randomEquiv(Index nz, int seed)
tests/test-solveCRA.pc:151665:  nonzerorandom(field(),r,a);
tests/test-solveCRA.pc:151666:  i = ri.randomIntRange(0, rowdim()); j = ri.randomIntRange(0, coldim());
tests/test-solveCRA.pc:151813:                 ri.random(d);
tests/test-solveCRA.pc:151841:                nonzerorandom(mat.field(),ri,d);
tests/test-solveCRA.pc:151872:         nonzerorandom(mat.field(),r,d);
tests/test-solveCRA.pc:151876:        mat.randomEquiv(approxNNZ,seed);
tests/test-solveCRA.pc:151914:SparseMatrix<Field_,SparseMatrixFormat::SMM>::nonzerorandom(const Field_& F,typename Field_::RandIter&r,typename Field_::Element& e)
tests/test-solveCRA.pc:151917:  r.random(e);
tests/test-solveCRA.pc:154683:# 1 "../linbox/randiter/random-prime.h" 1
tests/test-solveCRA.pc:154684:# 41 "../linbox/randiter/random-prime.h"
tests/test-solveCRA.pc:154708:# 75 "../linbox/randiter/random-prime.h"
tests/test-solveCRA.pc:154772:        integer::random_exact_2exp(_prime,_bits);
tests/test-solveCRA.pc:154786:            integer::random_exact_2exp(_prime,_bits);
tests/test-solveCRA.pc:154795:# 171 "../linbox/randiter/random-prime.h"
tests/test-solveCRA.pc:154857:# 241 "../linbox/randiter/random-prime.h"
tests/test-solveCRA.pc:154891:        integer::random_exact_2exp(_prime,_bits);
tests/test-solveCRA.pc:154913:            integer::random_exact_2exp(_prime,_bits);
tests/test-solveCRA.pc:157427: Matrix X(Xb); X.random();
tests/test-solveCRA.pc:157443: Matrix X(Xb); X.random();
tests/test-solveCRA.pc:157529:  void random(unsigned int seed=(unsigned int)time(
tests/test-solveCRA.pc:157540:    size_t j = i + r.randomInt()%(n-i);
tests/test-solveCRA.pc:157907:   generator.random( *it );
tests/test-solveCRA.pc:160468:            generator.random( *it );
tests/test-solveCRA.pc:160729:    g.random (u[(size_t)i]);
tests/test-solveCRA.pc:160803:    g.random (this->u[(size_t)i]);
tests/test-solveCRA.pc:160806:    g.random (this->w[(size_t)i]);
tests/test-solveCRA.pc:162661:  { iter.random(v_); }
tests/test-solveCRA.pc:167029:  Element &random (Element &a) const
tests/test-solveCRA.pc:167130:  ElementAbstract &random (ElementAbstract &a) const
tests/test-solveCRA.pc:167134:   random (tmp);
tests/test-solveCRA.pc:168142:  void random();
tests/test-solveCRA.pc:168143:  void randomNonsingular();
tests/test-solveCRA.pc:168312:   Nrow.random();
tests/test-solveCRA.pc:168325:   Ncol.random();
tests/test-solveCRA.pc:168542:   randomNonsingular();
tests/test-solveCRA.pc:168544:   random();
tests/test-solveCRA.pc:168559:  random();
tests/test-solveCRA.pc:168564: inline void Diagonal<_Field, VectorCategories::DenseVectorTag>::random()
tests/test-solveCRA.pc:168569:   r.random(*i);
tests/test-solveCRA.pc:168574: inline void Diagonal<_Field, VectorCategories::DenseVectorTag>::randomNonsingular()
tests/test-solveCRA.pc:168579:   while (field().isZero(r.random(*i))) ;
tests/test-solveCRA.pc:170192:  { typename Field::Element a; return CekstvSwitch<Field> (_r.random (a)); }
tests/test-solveCRA.pc:171531:    do iter.random (d1[i]); while (F.isZero (d1[i]));
tests/test-solveCRA.pc:171561:     do iter.random (d1[i]); while (F.isZero (d1[i]));
tests/test-solveCRA.pc:171598:     do iter.random (d1[i]); while (F.isZero (d1[i]));
tests/test-solveCRA.pc:171657:    do iter.random (d1[i]); while (F.isZero (d1[i]));
tests/test-solveCRA.pc:171660:    do iter.random (d2[i]); while (F.isZero (d2[i]));
tests/test-solveCRA.pc:171706:     do iter.random (d1[i]); while (F.isZero (d1[i]));
tests/test-solveCRA.pc:171709:     do iter.random (d2[i]); while (F.isZero (d2[i]));
tests/test-solveCRA.pc:171754:     do iter.random (d1[i]); while (F.isZero (d1[i]));
tests/test-solveCRA.pc:171757:     do iter.random (d2[i]); while (F.isZero (d2[i]));
tests/test-solveCRA.pc:172895:    randiter.random(A);
tests/test-solveCRA.pc:172943:    randiter.random(A);
tests/test-solveCRA.pc:173333:          bool makeMinDenomCert, bool randomSolution,
tests/test-solveCRA.pc:173845:  std::vector<double>& random(std::vector<double> &x) const
tests/test-solveCRA.pc:173848:    _randiter[i]->random(x[i]);
tests/test-solveCRA.pc:173863:# 1 "../linbox/randiter/multimod-randomprime.h" 1
tests/test-solveCRA.pc:173864:# 37 "../linbox/randiter/multimod-randomprime.h"
tests/test-solveCRA.pc:173895:  inline Prime_Type randomPrime() const
tests/test-solveCRA.pc:173902:     integer::random(tmp[i],_bits-1);
tests/test-solveCRA.pc:173914:  inline Prime_Type randomPrime (Prime_Type& p) const
tests/test-solveCRA.pc:173919:     integer::random(p[i],_bits-1);
tests/test-solveCRA.pc:175361:                G.random(*iter_U);
tests/test-solveCRA.pc:175365:                G.random(*iter_V);
tests/test-solveCRA.pc:177083:# 1 "../linbox/randiter/random-fftprime.h" 1
tests/test-solveCRA.pc:177084:# 33 "../linbox/randiter/random-fftprime.h"
tests/test-solveCRA.pc:177111:  inline Prime_Type randomPrime (size_t b) const
tests/test-solveCRA.pc:177114:   randomPrime(tmp,b);
tests/test-solveCRA.pc:177123:  inline Prime_Type randomPrime (Prime_Type& t, uint64_t b) const
tests/test-solveCRA.pc:177132:     integer::random(t,cbits);
tests/test-solveCRA.pc:177163:     integer::random(t,cbits);
tests/test-solveCRA.pc:177233:# 197 "../linbox/randiter/random-fftprime.h"
tests/test-solveCRA.pc:180399:    throw PreconditionFailed (__func__, 301, "Bad random Blocks, abort\n");
tests/test-solveCRA.pc:182212:     _rand.random(UU.refEntry(i,j));
tests/test-solveCRA.pc:182217:     _rand.random(V.refEntry(i,j));
tests/test-solveCRA.pc:182235:    _rand.random(UAp.refEntry(0,i));
tests/test-solveCRA.pc:183878:   typename Field::RandIter random(*F);
tests/test-solveCRA.pc:183879:   BlackboxContainer<Field,SparseMatrix<Field> > Sequence(Ap,*F,random);
tests/test-solveCRA.pc:183892:   prime = _genprime.randomPrime();
tests/test-solveCRA.pc:183998:   typename Field::RandIter random(*F);
tests/test-solveCRA.pc:183999:   BlackboxContainer<Field,FPrecondMatrix> Sequence(PApQ,*F,random);
tests/test-solveCRA.pc:184004:   prime = _genprime.randomPrime();
tests/test-solveCRA.pc:184483:               bool randomSolution,
tests/test-solveCRA.pc:184617:   if ((appearsInconsistent && level > SL_MONTECARLO) || randomSolution == false) {
tests/test-solveCRA.pc:184714:   if (!randomSolution) {
tests/test-solveCRA.pc:184836:   if (!randomSolution) {
tests/test-solveCRA.pc:184873:     if (randomSolution) {delete P; delete B;}
tests/test-solveCRA.pc:184987:   if (randomSolution) {delete P;}
tests/test-solveCRA.pc:185020:    G.random(diag[i]);
tests/test-solveCRA.pc:185038:    G.random(V.refEntry(i,j));
tests/test-solveCRA.pc:185041:   G.random(U.refEntry(0,i));
tests/test-solveCRA.pc:185426:  SolverReturnStatus randomSolve(Vector1& x, Integer& den, const IMatrix& A, const Vector2& b, const int maxPrimes = 5,
tests/test-solveCRA.pc:185455: SolverReturnStatus DiophantineSolver<QSolver>::randomSolve
tests/test-solveCRA.pc:187893:                                                        _rand.random(V.refEntry(i,j));
tests/test-solveCRA.pc:187897:                                                        _rand.random(UA.refEntry(i,j));
tests/test-solveCRA.pc:189352:     do iter.random (diag[i]); while (F.isZero (diag[i]));
tests/test-solveCRA.pc:189404:     do iter.random (diag[i]); while (F.isZero (diag[i]));
tests/test-solveCRA.pc:190156:                                        *b_p = _gen.random();
tests/test-solveCRA.pc:190160:                                        *b_p = _gen.random();
tests/test-solveCRA.pc:190779:   U.random();
tests/test-solveCRA.pc:190780:   W.random();
tests/test-solveCRA.pc:190946:   U.random();
tests/test-solveCRA.pc:190947:   V.random();
tests/test-solveCRA.pc:190973:     iter.random(*evalit);
tests/test-solveCRA.pc:191088:   U.random();
tests/test-solveCRA.pc:191089:   V.random();
tests/test-solveCRA.pc:191115:     do iter.random(*evalit); while(field().isZero(*evalit));
tests/test-solveCRA.pc:191247:        commentator().start ("Sparse Elimination Solve In Place with random solution", "sesolvein");
tests/test-solveCRA.pc:192322:# 1 "../linbox/matrix/random-matrix.h" 1
tests/test-solveCRA.pc:192323:# 46 "../linbox/matrix/random-matrix.h"
tests/test-solveCRA.pc:192417:# 47 "../linbox/matrix/random-matrix.h" 2
tests/test-solveCRA.pc:192479:  Matrix & random(Matrix & A) ;
tests/test-solveCRA.pc:192485:  Matrix& randomFullRank(Matrix& A);
tests/test-solveCRA.pc:192494:  Matrix & randomRank(Matrix & A, int rank);
tests/test-solveCRA.pc:192495:# 133 "../linbox/matrix/random-matrix.h"
tests/test-solveCRA.pc:192497:  Matrix & randomRank(Matrix & A, int rank
tests/test-solveCRA.pc:192501:  Matrix & randomRank(Matrix & A, int rank
tests/test-solveCRA.pc:192503:# 154 "../linbox/matrix/random-matrix.h"
tests/test-solveCRA.pc:192510:# 1 "../linbox/matrix/random-matrix.inl" 1
tests/test-solveCRA.pc:192511:# 33 "../linbox/matrix/random-matrix.inl"
tests/test-solveCRA.pc:192520:  random_lu_rank(const Field & F,
tests/test-solveCRA.pc:192557:     R.random( L.refEntry( i,j ) );
tests/test-solveCRA.pc:192560:    Rnz.random( L.refEntry( i,i ) );
tests/test-solveCRA.pc:192571:     R.random( U.refEntry( i,j ) );
tests/test-solveCRA.pc:192573:    Rnz.random( U.refEntry( i,i ) );
tests/test-solveCRA.pc:192587:# 116 "../linbox/matrix/random-matrix.inl"
tests/test-solveCRA.pc:192589:# 125 "../linbox/matrix/random-matrix.inl"
tests/test-solveCRA.pc:192601:  random_lu_rank(const Ring & ZZ,
tests/test-solveCRA.pc:192635:     S_.random( L.refEntry( i,j ) );
tests/test-solveCRA.pc:192638:    U_.random( L.refEntry( i,i ) );
tests/test-solveCRA.pc:192649:     T_.random( U.refEntry( i,j ) );
tests/test-solveCRA.pc:192651:    U_.random( U.refEntry( i,i ) );
tests/test-solveCRA.pc:192679:# 280 "../linbox/matrix/random-matrix.inl"
tests/test-solveCRA.pc:192682:  random_rankupdate( Field & F
tests/test-solveCRA.pc:192697:   RandMatGen.random(D) ;
tests/test-solveCRA.pc:192700:   RandMatGen.random(G) ;
tests/test-solveCRA.pc:192704:# 321 "../linbox/matrix/random-matrix.inl"
tests/test-solveCRA.pc:192713: RandomDenseMatrix<Randiter, Field>::random( Matrix & A)
tests/test-solveCRA.pc:192718:    R_.random(d);
tests/test-solveCRA.pc:192727: RandomDenseMatrix<Randiter, Field>::randomFullRank(Matrix &A)
tests/test-solveCRA.pc:192734:   random(A);
tests/test-solveCRA.pc:192738:# 369 "../linbox/matrix/random-matrix.inl"
tests/test-solveCRA.pc:192742: RandomDenseMatrix<Randiter, Field>::randomRank(
tests/test-solveCRA.pc:192748:  return randomRank(A,rank,RankBuilder::LU_());
tests/test-solveCRA.pc:192754: RandomDenseMatrix<Randiter, Field>::randomRank(
tests/test-solveCRA.pc:192760:  Protected::random_lu_rank( F_,R_,A,rank,
tests/test-solveCRA.pc:192770: RandomDenseMatrix<Randiter, Field>::randomRank(
tests/test-solveCRA.pc:192776:  return Protected::random_rankupdate(F_,R_,A,rank,
tests/test-solveCRA.pc:192796:# 161 "../linbox/matrix/random-matrix.h" 2
tests/test-solveCRA.pc:192832:  RDM.randomFullRank(Mat);
tests/test-solveCRA.pc:192842:  Vec.random(RI);
tests/test-solveCRA.pc:192906:    { 'i', "-i I", "Set the number of times to do the random unit tests.", TYPE_INT, &niter },
tests/test-solveCRA.pc:192908:    { 'q', "-q Q", "Set negative value for random input or positive value to always generate the same input.", TYPE_INT, &q },
tests/Makefile:218:	test-random-matrix$(EXEEXT) test-rat-charpoly$(EXEEXT) \
tests/Makefile:638:am_test_random_matrix_OBJECTS = test-random-matrix.$(OBJEXT)
tests/Makefile:639:test_random_matrix_OBJECTS = $(am_test_random_matrix_OBJECTS)
tests/Makefile:640:test_random_matrix_LDADD = $(LDADD)
tests/Makefile:641:test_random_matrix_DEPENDENCIES = $(am__DEPENDENCIES_1) \
tests/Makefile:922:	$(test_random_matrix_SOURCES) $(test_rank_Int_SOURCES) \
tests/Makefile:988:	$(test_random_matrix_SOURCES) $(test_rank_Int_SOURCES) \
tests/Makefile:1575:	test-random-matrix			\
tests/Makefile:1722:test_random_matrix_SOURCES = test-random-matrix.C
tests/Makefile:2116:test-random-matrix$(EXEEXT): $(test_random_matrix_OBJECTS) $(test_random_matrix_DEPENDENCIES) $(EXTRA_test_random_matrix_DEPENDENCIES) 
tests/Makefile:2117:	@rm -f test-random-matrix$(EXEEXT)
tests/Makefile:2118:	$(AM_V_CXXLD)$(CXXLINK) $(test_random_matrix_OBJECTS) $(test_random_matrix_LDADD) $(LIBS)
tests/Makefile:2345:include ./$(DEPDIR)/test-random-matrix.Po
tests/test-givaro-zpzuns.C:67:		{ 't', "-t T", "Number of trials for the random iterator test.", TYPE_INT, &trials },
tests/test-givaro-zpzuns.C:68:		{ 'c', "-c C", "Number of categories for the random iterator test.", TYPE_INT, &categories },
tests/test-givaro-zpzuns.C:69:		{ 'H', "-H H", "History level for random iterator test.", TYPE_INT, &hist_level },
tests/test-fibb.C:53:check NSR in NS (no check of randomness) and NSB 
tests/test-fibb.C:96:	X.random();
tests/test-fibb.C:119:	// no check of randomness of cols of Y
tests/test-fibb.C:147:	X.random();
tests/test-fibb.C:168:	 	X.write(report << "X: random " << std::endl, Tag::FileFormat::Plain) << std::endl;
tests/test-fibb.C:228:	Diagonal<Field> D1(F, n); // random nonsing
tests/test-fibb.C:247:	Permutation<Field> P2(F, n, n); P2.random(); 
tests/test-fibb.C:250:	pass = pass and testFibb(P2, "P2 random perm", F.zero, n); // random perm
tests/test-fibb.C:265:	//M.random();
tests/test-poly-smith-form.h:14:#include "linbox/matrix/random-matrix.h"
tests/benchmark-fields.C:85:	r.random( a ); r.random( b ); r.random( c );
tests/benchmark-fields.C:88:		r.random( dv1[(size_t)i] );
tests/benchmark-fields.C:89:		r.random( dv2[(size_t)i] );
tests/benchmark-fields.C:95:	// initialize and fill array of random elements.
tests/benchmark-fields.C:100:		do { r.random( elements[(size_t)i] ); }
tests/benchmark-fields.C:104:	// initialize random vector streams
tests/benchmark-fields.C:264:		// random code to prevent optimization of the loop
tests/test-cradomain.C:38:#include "linbox/randiter/random-prime.h"
tests/test-cradomain.C:75:			Integer::random<false>(*it, s);
tests/test-rational-solver.C:35:#include "linbox/randiter/random-prime.h"
tests/test-solveCRA.C:43:#include "linbox/matrix/random-matrix.h"
tests/test-solveCRA.C:79:  RDM.randomFullRank(Mat);
tests/test-solveCRA.C:89:  Vec.random(RI);
tests/test-solveCRA.C:139:    int seed=1; // This value should be other than 0 if not the generated input will always be random
tests/test-solveCRA.C:151:    { 'i', "-i I", "Set the number of times to do the random unit tests.", TYPE_INT,     &niter },
tests/test-solveCRA.C:153:    { 'q', "-q Q", "Set negative value for random input or positive value to always generate the same input.", TYPE_INT,     &q },
tests/test-dif.C:58:/* Test 1: Application of zero matrix onto random vectors
tests/test-dif.C:60: * Construct a random diagonal matrix, then construct
tests/test-dif.C:61: * the difference of the matrix and itself. Apply to random vectors and check that
tests/test-dif.C:144: * Compute a random diagonal matrix and use the transpose test in test-generic.h
tests/test-dif.C:149: * iterations - Number of random vectors to which to apply matrix
tests/test-dif.C:160:	commentator().start ("Testing random transpose", "testRandomTranspose", iterations);
tests/test-dif.C:166:		r.random (d[i]);
tests/test-ffpack.C:102:			Gn.random(*(S+i*n+i));
tests/test-ffpack.C:104:				G.random(*(S+i*n+j));
tests/test-ffpack.C:113:				G.random(*(L+i*n+j));
tests/test-ffpack.C:114:			Gn.random(*(L+i*n+i));
tests/test-ffpack.C:166:		G.random(d);
tests/test-ffpack.C:181:				G.random(*(S+i*n+j));
tests/test-ffpack.C:188:				G.random(*(L+i*n+j));
tests/test-ffpack.C:247:		// Create B a random matrix of rank n/2
tests/test-ffpack.C:253:					Gn.random (*(B+i*m+j));
tests/test-ffpack.C:258:		// Create C a random matrix of rank n/2
tests/test-ffpack.C:264:					Gn.random (*(C+i*n+j));
tests/test-ffpack.C:397:		G.random(tmp);
tests/test-ffpack.C:506:		G.random(tmp);
tests/test-ffpack.C:568:		// with nonzero random diagonal's element
tests/test-ffpack.C:572:			Gn.random(*(S+i*(n+1)));
tests/test-ffpack.C:574:				G.random(*(S+i*n+j));
tests/test-ffpack.C:581:				G.random(*(L+i*n+j));
tests/test-ffpack.C:662:			G.random(tmp);
tests/test-ffpack.C:663:			if ( Z2.isZero(G2.random(tmp2) ) )
tests/test-ffpack.C:670:		// with nonzero random diagonal's element
tests/test-ffpack.C:673:				G.random(*(A+i*n+j));
tests/test-matpoly-mult.C:43:#include <linbox/randiter/random-prime.h>
tests/test-matpoly-mult.C:44:#include <linbox/randiter/random-fftprime.h>
tests/test-matpoly-mult.C:62:void randomVect (Rand& r, Vect& v) {
tests/test-matpoly-mult.C:65:		r.random(v[i]); 
tests/test-matpoly-mult.C:69:void randomMat (Rand& r, Mat& m) {
tests/test-matpoly-mult.C:72:			r.random(m.refEntry(i,j));
tests/test-matpoly-mult.C:77:void randomMatPol(Rand& r,  PolynomialMatrix<PMType::matfirst,PMStorage::plain,Field>& A){
tests/test-matpoly-mult.C:79:		randomMat(r, A[i]);       	
tests/test-matpoly-mult.C:83:void randomMatPol(Rand& r,  PolynomialMatrix<PMType::polfirst,PMStorage::plain,Field>& A){
tests/test-matpoly-mult.C:85:		randomVect(r, A(i));
tests/test-matpoly-mult.C:112:	// Generate random matrix of polynomial
tests/test-matpoly-mult.C:113:	randomMatPol(Gen,A);
tests/test-matpoly-mult.C:114:	randomMatPol(Gen,B);
tests/test-matpoly-mult.C:126:	// Generate random matrix of polynomial
tests/test-matpoly-mult.C:127:	randomMatPol(Gen,A);
tests/test-matpoly-mult.C:128:	randomMatPol(Gen,C);
tests/test-matpoly-mult.C:144:	// Generate random matrix of polynomial
tests/test-matpoly-mult.C:145:	randomMatPol(Gen,A);
tests/test-matpoly-mult.C:146:	randomMatPol(Gen,C);
tests/test-matpoly-mult.C:164:	// Generate random matrix of polynomial
tests/test-matpoly-mult.C:165:	randomMatPol(Gen,A);
tests/test-matpoly-mult.C:166:	randomMatPol(Gen,C);
tests/test-matpoly-mult.C:204:		integer p = Rd.randomPrime(integer(d).bitsize()+1);
tests/test-matpoly-mult.C:249:		{ 's', "-s s", "Set the random seed to a specific value", TYPE_INT, &seed},
tests/test-modular-int.C:97:		{ 't', "-t T", "Number of trials for the random iterator test.", TYPE_INT, &trials },
tests/test-modular-int.C:98:		{ 'c', "-c C", "Number of categories for the random iterator test.", TYPE_INT, &categories },
tests/test-modular-int.C:99:		{ 'H', "-H H", "History level for random iterator test.", TYPE_INT, &hist_level },
tests/test-triplesbb.C:114:	X.random(); Z.random();
tests/test-givaro-zpz.C:69:		{ 't', "-t T", "Number of trials for the random iterator test.", TYPE_INT, &trials },
tests/test-givaro-zpz.C:70:		{ 'c', "-c C", "Number of categories for the random iterator test.", TYPE_INT, &categories },
tests/test-givaro-zpz.C:71:		{ 'H', "-H H", "History level for random iterator test.", TYPE_INT, &hist_level },
tests/test-invariant-factors.C:80:		{ 's', "-s S", "Number of nonzeros in random triangular preconditioner", TYPE_INT, &s},
tests/test-toom-cook.C:39:#include "linbox/matrix/random-matrix.h"
tests/test-toom-cook.C:239:		RandomDenseMatrix<Randiter,GFpe> randomizer(GF,R) ;
tests/test-toom-cook.C:240:		randomizer.random(A);
tests/test-toom-cook.C:242:		randomizer.random(B);
tests/test-toom-cook.C:301:		A.random((unsigned)b);
tests/test-toom-cook.C:302:		B.random((unsigned)b);
tests/test-toom-cook.C:378:		x.random(ri);
tests/test-minpoly.C:203: * Generates a random sparse matrix with K nonzero elements per row and computes
tests/test-minpoly.C:204: * its minimal polynomial. Then computes random vectors and applies the
tests/test-minpoly.C:210: * numVectors - Number of random vectors to which to apply the minimal polynomial
tests/test-minpoly.C:226:        commentator().start ("Testing sparse random minpoly", "testRandomMinpoly", (unsigned int)iterations);
tests/test-minpoly.C:358:		typename Field::RandIter G(*F, b, seed); //random generator over F
tests/test-minpoly.C:359:		typename Field::NonZeroRandIter NzG(G); //non-zero random generator over F
tests/test-minpoly.C:432:		{ 'v', "-v V", "Use V test vectors for the random minpoly tests.", TYPE_INT,     &numVectors },
tests/test-minpoly.C:433:		{ 'k', "-k K", "K nonzero Elements per row in sparse random apply test.", TYPE_INT,     &k },
tests/test-minpoly.C:434:		{ 's', "-s seed", "set seed for the random generator.", TYPE_INT, &seed },
tests/test-blackbox-block-container.C:206:			rand.random(U.refEntry(i,j));
tests/test-blackbox-block-container.C:217:			rand.random(V.refEntry(i,j));
tests/test-blas-matrix.C:49:	A.random();
tests/test-sparse-map-map.C:158:		ss << "Testing randomSim() with n=" << n << " b=" << b;
tests/test-sparse-map-map.C:181:		M.randomSim(2*n);
tests/test-sparse-map-map.C:222:	commentator().start("Testing randomSim()");
tests/test-modular-balanced-double.C:57:		{ 't', "-t T", "Number of trials for the random iterator test.", TYPE_INT, &trials },
tests/test-modular-balanced-double.C:58:		{ 'c', "-c C", "Number of categories for the random iterator test.", TYPE_INT, &categories },
tests/test-modular-balanced-double.C:59:		{ 'H', "-H H", "History level for random iterator test.", TYPE_INT, &hist_level },
tests/test-last-invariant-factor.C:37:#include "linbox/randiter/random-prime.h"
tests/test-last-invariant-factor.C:42:#include "linbox/blackbox/random-matrix.h"
Binary file tests/test-solveCRA matches
tests/test-echelon-form.C:100:		r = (unsigned int)(random() % mn);
tests/test-echelon-form.C:103:			S.setEntry(i,i,Gn.random(tmp));
tests/test-echelon-form.C:105:				S.setEntry(i,j,G.random(tmp));
tests/test-echelon-form.C:113:				L.setEntry(i,j,G.random(tmp));
tests/test-echelon-form.C:114:			L.setEntry(i,i,Gn.random(tmp));
tests/test-echelon-form.C:185:		// Create B a random matrix of rank n/2
tests/test-echelon-form.C:189:				  B.setEntry(i,j,G.random(tmp));
tests/test-echelon-form.C:193:		// Create C a random matrix of rank n/2
tests/test-echelon-form.C:197:					C.setEntry(i,j,G.random(tmp));
tests/test-mpi-comm.C:35:#include "linbox/blackbox/random-matrix.h"
tests/test-mpi-comm.C:36:#include "linbox/matrix/random-matrix.h"
tests/test-mpi-comm.C:77:    RDM.random(A);
tests/test-mpi-comm.C:85:    B.random(RI);
tests/test-mpi-comm.C:148:    // Generating random data for matrice and vector
tests/test-mpi-comm.C:187:                       {'s', "-s SEED", "Seed used for randomness.", TYPE_INT, &seed},
tests/test-matrix-utils.h:29: * @bug put in \c matrix/random-matrix.h
tests/test-matrix-utils.h:57:/** @brief gives a random number such that \f$0 \leq RIII < s\f$.
tests/test-matrix-utils.h:61: * @param [out] RIII random integer in the interval  \f$[[0, s-1]]\f$.
tests/test-matrix-utils.h:68:	 *	srandom( (unsigned) time(NULL) );
tests/test-matrix-utils.h:70:	 *	srandom ( seed );
tests/test-matrix-utils.h:79: * Creates a random Lapack style Permutation \p P of size \p len.
tests/test-matrix-utils.h:160: * Builds a \p m x \p n random matrix of rank \p rank over field \p F.
tests/test-matrix-utils.h:173:	//                srandom( (unsigned) time(NULL)  ) ; // on met une nouvelle graine.
tests/test-matrix-utils.h:180:	// Create B a random invertible matrix (m x m format)
tests/test-matrix-utils.h:186:		Gn.random(*(B+j*m+j));
tests/test-matrix-utils.h:188:			G.random (*(B+i*m+j));
tests/test-matrix-utils.h:190:	// Create C a random matrix of rank \p ( m x n format)
tests/test-matrix-utils.h:196:			Gn.random (*(C+i*n+j));
tests/test-matrix-utils.h:202:	// create P a random permutation of size \p n
tests/test-matrix-utils.h:205:	// create Q a random permutation of size \p m
tests/test-matrix-utils.h:224: * Builds a \p m x \p m random matrix of determinant \p det over field \p F.
tests/test-matrix-utils.h:241:	//srandom( (unsigned) time(NULL) ) ; // on met une nouvelle graine.
tests/test-matrix-utils.h:243:	// create Q a random permutation of size \p m
tests/test-matrix-utils.h:251:	// Create B a random invertible matrix (m x m format) of determinant \p det
tests/test-matrix-utils.h:255:		Gn.random(*(B+j*m+j) );
tests/test-matrix-utils.h:257:			G.random (*(B+i*m+j));
tests/test-matrix-utils.h:275:	// Create C a random matrix of rank \p ( m x m format)
tests/test-matrix-utils.h:284:			G.random (*(C+i*m+j));
tests/test-matrix-utils.h:288:	// create P a random permutation of size \p m
tests/test-sparse.C:155:		while (S1.field().isZero(r.random(x)));
tests/test-transpose.C:89:	VD.random(x);
tests/test-transpose.C:96:	VD.random(y);
tests/.deps/test-Mat2Gen.Po:146: /usr/include/c++/5/bits/stl_construct.h /usr/include/c++/5/random \
tests/.deps/test-Mat2Gen.Po:147: /usr/include/c++/5/bits/random.h /usr/include/c++/5/vector \
tests/.deps/test-Mat2Gen.Po:152: /usr/include/x86_64-linux-gnu/c++/5/bits/opt_random.h \
tests/.deps/test-Mat2Gen.Po:206: /usr/include/c++/5/bits/random.tcc /usr/include/c++/5/numeric \
tests/.deps/test-Mat2Gen.Po:226: /home/zhg/soft/builds/include/givaro/givrandom.h \
tests/.deps/test-Mat2Gen.Po:235: /home/zhg/soft/builds/include/givaro/random-integer.h \
tests/.deps/test-Mat2Gen.Po:283: /home/zhg/soft/builds/include/recint/rurandom.h \
tests/.deps/test-Mat2Gen.Po:429: /home/zhg/soft/builds/include/recint/rmrandom.h \
tests/.deps/test-Mat2Gen.Po:438: /home/zhg/soft/builds/include/recint/rrandom.h \
tests/.deps/test-Mat2Gen.Po:593: /home/zhg/soft/builds/include/fflas-ffpack/utils/fflas_randommatrix.h \
tests/.deps/test-Mat2Gen.Po:736: ../linbox/algorithms/minpoly-integer.h ../linbox/randiter/random-prime.h \
tests/.deps/test-Mat2Gen.Po:760: ../linbox/randiter/multimod-randomprime.h \
tests/.deps/test-Mat2Gen.Po:782: ../linbox/randiter/random-fftprime.h ../linbox/algorithms/echelon-form.h \
tests/.deps/test-Mat2Gen.Po:1191:/usr/include/c++/5/random:
tests/.deps/test-Mat2Gen.Po:1193:/usr/include/c++/5/bits/random.h:
tests/.deps/test-Mat2Gen.Po:1207:/usr/include/x86_64-linux-gnu/c++/5/bits/opt_random.h:
tests/.deps/test-Mat2Gen.Po:1315:/usr/include/c++/5/bits/random.tcc:
tests/.deps/test-Mat2Gen.Po:1363:/home/zhg/soft/builds/include/givaro/givrandom.h:
tests/.deps/test-Mat2Gen.Po:1381:/home/zhg/soft/builds/include/givaro/random-integer.h:
tests/.deps/test-Mat2Gen.Po:1477:/home/zhg/soft/builds/include/recint/rurandom.h:
tests/.deps/test-Mat2Gen.Po:1847:/home/zhg/soft/builds/include/recint/rmrandom.h:
tests/.deps/test-Mat2Gen.Po:1867:/home/zhg/soft/builds/include/recint/rrandom.h:
tests/.deps/test-Mat2Gen.Po:2181:/home/zhg/soft/builds/include/fflas-ffpack/utils/fflas_randommatrix.h:
tests/.deps/test-Mat2Gen.Po:2521:../linbox/randiter/random-prime.h:
tests/.deps/test-Mat2Gen.Po:2589:../linbox/randiter/multimod-randomprime.h:
tests/.deps/test-Mat2Gen.Po:2639:../linbox/randiter/random-fftprime.h:
tests/.deps/test-MatGen.Po:146: /usr/include/c++/5/bits/stl_construct.h /usr/include/c++/5/random \
tests/.deps/test-MatGen.Po:147: /usr/include/c++/5/bits/random.h /usr/include/c++/5/vector \
tests/.deps/test-MatGen.Po:152: /usr/include/x86_64-linux-gnu/c++/5/bits/opt_random.h \
tests/.deps/test-MatGen.Po:206: /usr/include/c++/5/bits/random.tcc /usr/include/c++/5/numeric \
tests/.deps/test-MatGen.Po:227: /home/zhg/soft/builds/include/givaro/givrandom.h \
tests/.deps/test-MatGen.Po:234: /home/zhg/soft/builds/include/givaro/random-integer.h \
tests/.deps/test-MatGen.Po:281: /home/zhg/soft/builds/include/recint/rurandom.h \
tests/.deps/test-MatGen.Po:438: /home/zhg/soft/builds/include/recint/rmrandom.h \
tests/.deps/test-MatGen.Po:447: /home/zhg/soft/builds/include/recint/rrandom.h \
tests/.deps/test-MatGen.Po:626: /home/zhg/soft/builds/include/fflas-ffpack/utils/fflas_randommatrix.h \
tests/.deps/test-MatGen.Po:760: ../linbox/randiter/random-prime.h ../linbox/algorithms/cra-domain-omp.h \
tests/.deps/test-MatGen.Po:785: ../linbox/randiter/multimod-randomprime.h \
tests/.deps/test-MatGen.Po:807: ../linbox/randiter/random-fftprime.h ../linbox/algorithms/echelon-form.h \
tests/.deps/test-MatGen.Po:833: ../linbox/matrix/random-matrix.h \
tests/.deps/test-MatGen.Po:835: ../linbox/matrix/random-matrix.inl
tests/.deps/test-MatGen.Po:1219:/usr/include/c++/5/random:
tests/.deps/test-MatGen.Po:1221:/usr/include/c++/5/bits/random.h:
tests/.deps/test-MatGen.Po:1235:/usr/include/x86_64-linux-gnu/c++/5/bits/opt_random.h:
tests/.deps/test-MatGen.Po:1343:/usr/include/c++/5/bits/random.tcc:
tests/.deps/test-MatGen.Po:1393:/home/zhg/soft/builds/include/givaro/givrandom.h:
tests/.deps/test-MatGen.Po:1407:/home/zhg/soft/builds/include/givaro/random-integer.h:
tests/.deps/test-MatGen.Po:1501:/home/zhg/soft/builds/include/recint/rurandom.h:
tests/.deps/test-MatGen.Po:1893:/home/zhg/soft/builds/include/recint/rmrandom.h:
tests/.deps/test-MatGen.Po:1913:/home/zhg/soft/builds/include/recint/rrandom.h:
tests/.deps/test-MatGen.Po:2275:/home/zhg/soft/builds/include/fflas-ffpack/utils/fflas_randommatrix.h:
tests/.deps/test-MatGen.Po:2599:../linbox/randiter/random-prime.h:
tests/.deps/test-MatGen.Po:2671:../linbox/randiter/multimod-randomprime.h:
tests/.deps/test-MatGen.Po:2721:../linbox/randiter/random-fftprime.h:
tests/.deps/test-MatGen.Po:2785:../linbox/matrix/random-matrix.h:
tests/.deps/test-MatGen.Po:2789:../linbox/matrix/random-matrix.inl:
tests/.deps/test-solveCRA.Po:146: /usr/include/c++/5/bits/stl_construct.h /usr/include/c++/5/random \
tests/.deps/test-solveCRA.Po:147: /usr/include/c++/5/bits/random.h /usr/include/c++/5/vector \
tests/.deps/test-solveCRA.Po:152: /usr/include/x86_64-linux-gnu/c++/5/bits/opt_random.h \
tests/.deps/test-solveCRA.Po:206: /usr/include/c++/5/bits/random.tcc /usr/include/c++/5/numeric \
tests/.deps/test-solveCRA.Po:227: /home/zhg/soft/builds/include/givaro/givrandom.h \
tests/.deps/test-solveCRA.Po:234: /home/zhg/soft/builds/include/givaro/random-integer.h \
tests/.deps/test-solveCRA.Po:281: /home/zhg/soft/builds/include/recint/rurandom.h \
tests/.deps/test-solveCRA.Po:438: /home/zhg/soft/builds/include/recint/rmrandom.h \
tests/.deps/test-solveCRA.Po:447: /home/zhg/soft/builds/include/recint/rrandom.h \
tests/.deps/test-solveCRA.Po:626: /home/zhg/soft/builds/include/fflas-ffpack/utils/fflas_randommatrix.h \
tests/.deps/test-solveCRA.Po:760: ../linbox/randiter/random-prime.h ../linbox/algorithms/cra-domain-omp.h \
tests/.deps/test-solveCRA.Po:785: ../linbox/randiter/multimod-randomprime.h \
tests/.deps/test-solveCRA.Po:807: ../linbox/randiter/random-fftprime.h ../linbox/algorithms/echelon-form.h \
tests/.deps/test-solveCRA.Po:833: ../linbox/matrix/random-matrix.h \
tests/.deps/test-solveCRA.Po:835: ../linbox/matrix/random-matrix.inl
tests/.deps/test-solveCRA.Po:1219:/usr/include/c++/5/random:
tests/.deps/test-solveCRA.Po:1221:/usr/include/c++/5/bits/random.h:
tests/.deps/test-solveCRA.Po:1235:/usr/include/x86_64-linux-gnu/c++/5/bits/opt_random.h:
tests/.deps/test-solveCRA.Po:1343:/usr/include/c++/5/bits/random.tcc:
tests/.deps/test-solveCRA.Po:1393:/home/zhg/soft/builds/include/givaro/givrandom.h:
tests/.deps/test-solveCRA.Po:1407:/home/zhg/soft/builds/include/givaro/random-integer.h:
tests/.deps/test-solveCRA.Po:1501:/home/zhg/soft/builds/include/recint/rurandom.h:
tests/.deps/test-solveCRA.Po:1893:/home/zhg/soft/builds/include/recint/rmrandom.h:
tests/.deps/test-solveCRA.Po:1913:/home/zhg/soft/builds/include/recint/rrandom.h:
tests/.deps/test-solveCRA.Po:2275:/home/zhg/soft/builds/include/fflas-ffpack/utils/fflas_randommatrix.h:
tests/.deps/test-solveCRA.Po:2599:../linbox/randiter/random-prime.h:
tests/.deps/test-solveCRA.Po:2671:../linbox/randiter/multimod-randomprime.h:
tests/.deps/test-solveCRA.Po:2721:../linbox/randiter/random-fftprime.h:
tests/.deps/test-solveCRA.Po:2785:../linbox/matrix/random-matrix.h:
tests/.deps/test-solveCRA.Po:2789:../linbox/matrix/random-matrix.inl:
tests/test-submatrix.C:48:/* Test 1: Application of submatrices onto random vectors
tests/test-submatrix.C:51: * grid. Apply submatrices of the result onto random vectors and check equality
tests/test-submatrix.C:57: * N - Number of random vectors to which to apply
tests/test-submatrix.C:70:	commentator().start ("Testing random apply", "testRandomApply", iterations);
tests/test-submatrix.C:95:					r.random (x);
tests/test-submatrix.C:149: * Construct a random dense matrix and a submatrix thereof. Call testLinearity
tests/test-submatrix.C:155: * N - Number of random vectors to which to apply
tests/test-submatrix.C:166:	commentator().start ("Testing random linearity", "testRandomLinearity", v1_stream.size ());
tests/test-submatrix.C:184: * Construct a random dense matrix and a submatrix thereof. Call testLinearity
tests/test-submatrix.C:190: * N - Number of random vectors to which to apply
tests/test-submatrix.C:201:	commentator().start ("Testing random transpose", "testRandomTranspose", v1_stream.size ());
tests/Makefile.am:158:	test-random-matrix			\
tests/Makefile.am:329:test_random_matrix_SOURCES =            test-random-matrix.C
tests/test-ntl-sylvester.C:111:		pdata[i] = NTL::random_ZZ_p() ;
tests/test-ntl-sylvester.C:114:	pdata[0] = NTL::random_ZZ_p() ;
tests/test-ntl-sylvester.C:121:		qdata[i] = NTL::random_ZZ_p() ;
tests/test-ntl-sylvester.C:125:	qdata[0] = NTL::random_ZZ_p() ;
tests/test-ntl-sylvester.C:144:	report << "A random col vector:\npx:=[" << std::endl;
tests/test-ntl-sylvester.C:147:		idata[i] = NTL::random_ZZ_p() ;
tests/test-modular-short.C:78:		{ 't', "-t T", "Number of trials for the random iterator test.", TYPE_INT, &trials },
tests/test-modular-short.C:79:		{ 'c', "-c C", "Number of categories for the random iterator test.", TYPE_INT, &categories },
tests/test-modular-short.C:80:		{ 'H', "-H H", "History level for random iterator test.", TYPE_INT, &hist_level },
tests/test-randiter-nonzero.C:53:/* Test 1: Nonzero random elements
tests/test-randiter-nonzero.C:55: * Construct a sequence of random elements from the nonzero random iterator and
tests/test-randiter-nonzero.C:69:	commentator().start ("Testing nonzero random elements", "testNonzeroRandom", iterations);
tests/test-randiter-nonzero.C:82:		rp.random (x);
tests/test-randiter-nonzero.C:122:	commentator().start("Nonzero random iterator test suite", "Givaro::GeneralRingNonZeroRandIter");
tests/test-randiter-nonzero.C:129:	commentator().stop("Nonzero random iterator test suite");
tests/test-moore-penrose.C:52:/* Build a random sparse n x m matrix of rank r with a nonsingular leading principal minor */
tests/test-moore-penrose.C:80:		rnd.random (x);
tests/test-moore-penrose.C:115:/* Test 1: Application of identity onto random vectors
tests/test-moore-penrose.C:119: * of this to random vectors and check the correctness of the results.
tests/test-moore-penrose.C:125: * stream - Stream for random vectors to apply
tests/test-moore-penrose.C:201:/* Test 2: Application of random matrix onto random vectors
tests/test-moore-penrose.C:203: * Construct a random sparse rank-r matrix with a nonsingular leading principal
tests/test-moore-penrose.C:204: * minor. Apply the Moore-Penrose inverse of this to random vectors and check
tests/test-moore-penrose.C:213: * stream - Stream for random vectors to apply
tests/test-moore-penrose.C:231:	commentator().start ("Testing random apply", "testRandomApply1", iterations);
tests/test-moore-penrose.C:255:		commentator().start ("Building requisite random sparse matrix");
tests/test-moore-penrose.C:288:			// Get a random element of N(A^T) and add it to w
tests/test-moore-penrose.C:348:		{ 'k', "-k K", "Apply random Moore-Penrose to K vectors.", TYPE_INT,     &k },
tests/test-smith-form.h:61:		case 3: // random followed by 202,0.  Random part is largely 1's.
tests/test-smith-form.h:109:	// make A = UDL for random unimodular L,U
tests/test-solve-nonsingular.C:36:#include "linbox/randiter/random-prime.h"
tests/test-solve-nonsingular.C:73:#include "matrix/randommat.h"
tests/test-solve-nonsingular.C:74:#include "matrix/randomans.h"
tests/test-solve-nonsingular.C:122:		//  random RHSs
tests/test-solve-nonsingular.C:124:		//case random:
tests/test-solve-nonsingular.C:151:		case rand_near_sing: randomAns(R, D, n, n); break;
tests/test-solve-nonsingular.C:160:			randomMat(R, D, n, (size_t)k); break;
tests/test-solve-nonsingular.C:161:			//  modified for steffy's random model
tests/test-solve-nonsingular.C:163:			randomMat(R, D, n, n);
tests/test-solve-nonsingular.C:192:			//randomMat(R, D, n, n);
tests/test-dense.C:59: * whether the output of its application to a series of random vectors is equal
tests/test-dense.C:64: * iterations - Number of random vectors to which to apply identity inverse
tests/test-dense.C:102:			r.random (v[(size_t)j]);
tests/test-dense.C:136: * Computes a random Vandermonde matrix and applies it to a series of random
tests/test-dense.C:137: * vectors. The random vectors contain the coefficients of polynomials over the
tests/test-dense.C:146: * iterations - Number of random diagonal matrices to construct
tests/test-dense.C:147: * N - Number of random vectors to which to apply random Vandermonde matrix
tests/test-dense.C:183:				r.random (x[(size_t)j]);
tests/test-dense.C:210:				r.random (v[(size_t)k]);
tests/test-dense.C:247: * Construct a random dense matrix and a submatrix thereof. Call testLinearity
tests/test-dense.C:253: * N - Number of random vectors to which to apply
tests/test-dense.C:264:	commentator().start ("Testing random linearity", "testRandomLinearity", v1_stream.size ());
tests/test-dense.C:281: * Construct a random dense matrix and a submatrix thereof. Call testLinearity
tests/test-dense.C:287: * N - Number of random vectors to which to apply
tests/test-dense.C:298:	commentator().start ("Testing random transpose", "testRandomTranspose", v1_stream.size ());
tests/test-modular-balanced-float.C:58:		{ 't', "-t T", "Number of trials for the random iterator test.", TYPE_INT, &trials },
tests/test-modular-balanced-float.C:59:		{ 'c', "-c C", "Number of categories for the random iterator test.", TYPE_INT, &categories },
tests/test-modular-balanced-float.C:60:		{ 'H', "-H H", "History level for random iterator test.", TYPE_INT, &hist_level },
tests/test-quad-matrix.C:92:	// random 3 per row matrix
tests/test-dense-zero-one.C:105:	// Set the entries in a block to random field elements.
tests/test-dense-zero-one.C:106:	void random( Block& B) {
tests/test-dense-zero-one.C:110:				r.random(*place);
tests/test-dense-zero-one.C:128:	MD.random(B); MD.random(C);
tests/test-dense-zero-one.C:157:	MD.random(B); MD.random(D);
tests/test-dense-zero-one.C:163:		r.random(x);
tests/test-dense-zero-one.C:208:	MD.random(B); MD.random(D);
tests/test-dense-zero-one.C:246:	MD.random(B);
tests/test-dense-zero-one.C:255:	Block D(m,m); MD.random(D);
tests/test-dense-zero-one.C:279:	MD.random(B);
tests/test-rat-solve.C:55: * Constructs a random nonsingular diagonal rational matrix D and a random right-hand
tests/test-rat-solve.C:112: * Constructs a random nonsingular diagonal rational matrix D and a random right-hand
tests/test-rat-solve.C:143:			//integer::nonzerorandom(tmp_n, 2*(i + 1) );
tests/test-rat-solve.C:144:			//integer::nonzerorandom(tmp_d, 2*(i + 1) );
tests/test-rat-solve.C:145:			//integer::random(tmp_bn, 2*(i + 1));
tests/test-rat-solve.C:146:			//integer::nonzerorandom(tmp_bd, 2*(i +1) );
tests/test-hom.C:63:		{ 't', "-t T", "Number of trials for the random iterator test.", TYPE_INT, &trials },
tests/test-hom.C:64:		{ 'c', "-c C", "Number of categories for the random iterator test.", TYPE_INT, &categories },
tests/test-hom.C:65:		{ 'H', "-H H", "History level for random iterator test.", TYPE_INT, &hist_level },
tests/test-modular-byte.C:73:		{ 't', "-t T", "Number of trials for the random iterator test.", TYPE_INT, &trials },
tests/test-modular-byte.C:74:		{ 'c', "-c C", "Number of categories for the random iterator test.", TYPE_INT, &categories },
tests/test-modular-byte.C:75:		{ 'H', "-H H", "History level for random iterator test.", TYPE_INT, &hist_level },
tests/test-rational-reconstruction-base.C:55:#include "linbox/randiter/random-prime.h"
tests/test-rational-reconstruction-base.C:61:/* Test: Rational reconstruction of random fraction using rational-cra2.h
tests/test-rational-reconstruction-base.C:63: * Constructs a random pair of numerator/denominator
tests/test-rational-reconstruction-base.C:89:	commentator().start ("Testing rational reconstruction on random fractions", "testRandFrac", (unsigned int)iterations);
tests/test-rational-reconstruction-base.C:101:		integer::nonzerorandom(num, n);
tests/test-rational-reconstruction-base.C:102:		integer::nonzerorandom(den, d);
tests/test-ntl-toeplitz.C:100:	report << "The random vector is:" << std::endl;
tests/test-ntl-toeplitz.C:102:		tdata[i] = NTL::random_ZZ_p() ;
tests/test-ntl-toeplitz.C:113:	report << "A random col vector:\t" << std::endl;
tests/test-ntl-toeplitz.C:115:		idata[i] = NTL::random_ZZ_p() ;
tests/test-serialization.C:31:#include "linbox/matrix/random-matrix.h"
tests/test-serialization.C:43:    uint64_t randomOffset = rand() % 100;
tests/test-serialization.C:44:    std::vector<uint8_t> bytes(randomOffset);
tests/test-serialization.C:51:    auto bytesRead = unserialize(output, bytes, randomOffset);
tests/test-serialization.C:155:    // Fill denseMatrix with random values!
tests/test-serialization.C:158:    RandMat.random(denseMatrix);
tests/test-serialization.C:193:    Argument as[] = {{'q', "-q Q", "Set the field characteristic (-1 for random).", TYPE_INTEGER, &q},
tests/test-serialization.C:194:                     {'s', "-s seed", "Set seed for the random generator", TYPE_UINT64, &seed},
tests/test-modular-balanced-int.C:99:		{ 't', "-t T", "Number of trials for the random iterator test.", TYPE_INT, &trials },
tests/test-modular-balanced-int.C:100:		{ 'c', "-c C", "Number of categories for the random iterator test.", TYPE_INT, &categories },
tests/test-modular-balanced-int.C:101:		{ 'H', "-H H", "History level for random iterator test.", TYPE_INT, &hist_level },
tests/test-order-basis.C:3:#include "linbox/randiter/random-fftprime.h"
tests/test-order-basis.C:4:#include "linbox/randiter/random-prime.h"
tests/test-order-basis.C:78:	// set the Serie at random
tests/test-order-basis.C:82:				Gen.random(Serie.ref(i,j,k));
tests/test-order-basis.C:128:		integer p = Rd.randomPrime(integer(d).bitsize()+1);		
tests/test-order-basis.C:184:		{ 's', "-s s", "Set the random seed to a specific value", TYPE_INT, &seed},
tests/test-ntl-hankel.C:99:	report << "The random vector is:" << std::endl;
tests/test-ntl-hankel.C:101:		tdata[i] = NTL::random_ZZ_p() ;
tests/test-ntl-hankel.C:114:	report << "A random col vector:\t" << std::endl;
tests/test-ntl-hankel.C:116:		idata[i] = NTL::random_ZZ_p() ;
tests/test-rat-charpoly.C:55: * Constructs a random diagonal rational matrix D
tests/test-field.h:214:        r.random(a);
tests/test-field.h:386:	 * Negates random elements and checks that they are true negatives
tests/test-field.h:408:			r.random (a);
tests/test-field.h:437:	 * Inverts random elements and checks that they are true inverses
tests/test-field.h:461:			do r.random (a); while (F.isZero (a));
tests/test-field.h:488:	 * Given random field elements 'a', 'b', and 'c', checks that
tests/test-field.h:516:			r.random (a);
tests/test-field.h:517:			r.random (b);
tests/test-field.h:518:			r.random (c);
tests/test-field.h:562:	 * Given random field elements 'a', 'b', checks that
tests/test-field.h:590:			r.random (a);
tests/test-field.h:591:			r.random (b);
tests/test-field.h:637:	 * Given random field elements 'a', 'b', and 'c', checks that
tests/test-field.h:660:			r.random (a);
tests/test-field.h:661:			r.random (b);
tests/test-field.h:662:			r.random (c);
tests/test-field.h:707:	 * Generates a random field element 'a' and raises it through repeated
tests/test-field.h:733://			do z.random (a); while (F.areEqual (a, F.one) && --no_bad_loop);
tests/test-field.h:787:	 * Take random field elements and add them p times, where p is the
tests/test-field.h:817:			r.random (a);
tests/test-field.h:845:	 * Generates two random field elements 'a' and 'b', and checks whether
tests/test-field.h:880:			r.random (a);
tests/test-field.h:881:			r.random (b);
tests/test-field.h:928:	 * Generates random elements 'a' and 'b' and performs all basic arithmetic
tests/test-field.h:954:			r.random (a);
tests/test-field.h:955:			r.random (b);
tests/test-field.h:1034:			r.random (a); r.random (b);
tests/test-field.h:1157:	 * Generates random elements 'a', 'x', and 'y' and checks that a * x + y is the
tests/test-field.h:1180:			r.random (a);
tests/test-field.h:1181:			r.random (x);
tests/test-field.h:1182:			r.random (y);
tests/test-field.h:1214:	 * In a loop, generates random element 'a', and fails
tests/test-field.h:1233:			r.random (a);
tests/test-field.h:1311:	r.random(a); r.random(b);
tests/test-field.h:1338:	 * Test that the random iterator over the given field works
tests/test-field.h:1382:			F.convert(ix, iter.random (x));
tests/test-field.h:1492: * Test that the random iterator over the given field works.
tests/test-smith-form-iliopoulos.C:39:#include "linbox/randiter/random-prime.h"
tests/test-smith-form-iliopoulos.C:66:	/* random unimodular
tests/test-smith-form-iliopoulos.C:67:	BMD.randomNonsingular(U);
tests/test-smith-form-iliopoulos.C:68:	BMD.randomNonsingular(V);
tests/test-smith-form-iliopoulos.C:112:	// L and U are random unit triangular.
tests/Makefile.in:218:	test-random-matrix$(EXEEXT) test-rat-charpoly$(EXEEXT) \
tests/Makefile.in:638:am_test_random_matrix_OBJECTS = test-random-matrix.$(OBJEXT)
tests/Makefile.in:639:test_random_matrix_OBJECTS = $(am_test_random_matrix_OBJECTS)
tests/Makefile.in:640:test_random_matrix_LDADD = $(LDADD)
tests/Makefile.in:641:test_random_matrix_DEPENDENCIES = $(am__DEPENDENCIES_1) \
tests/Makefile.in:922:	$(test_random_matrix_SOURCES) $(test_rank_Int_SOURCES) \
tests/Makefile.in:988:	$(test_random_matrix_SOURCES) $(test_rank_Int_SOURCES) \
tests/Makefile.in:1575:	test-random-matrix			\
tests/Makefile.in:1722:test_random_matrix_SOURCES = test-random-matrix.C
tests/Makefile.in:2116:test-random-matrix$(EXEEXT): $(test_random_matrix_OBJECTS) $(test_random_matrix_DEPENDENCIES) $(EXTRA_test_random_matrix_DEPENDENCIES) 
tests/Makefile.in:2117:	@rm -f test-random-matrix$(EXEEXT)
tests/Makefile.in:2118:	$(AM_V_CXXLD)$(CXXLINK) $(test_random_matrix_OBJECTS) $(test_random_matrix_LDADD) $(LIBS)
tests/Makefile.in:2345:@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/test-random-matrix.Po@am__quote@
tests/test-inverse.C:60: * that that inverse is itself the identity operator by applying it to random
tests/test-inverse.C:65: * iterations - Number of random vectors to which to apply identity inverse
tests/test-inverse.C:136: * each to random vectors and checks that the results are equal.
tests/test-inverse.C:140: * iterations - Number of random diagonal matrices to construct
tests/test-inverse.C:204: * Computes a random Vandermonde matrix and its inverse. This inverse is a
tests/test-inverse.C:213: * iterations - Number of random diagonal matrices to construct
tests/test-inverse.C:214: * N - Number of random vectors to which to apply random Vandermonde matrix
tests/test-inverse.C:316: * Constructs a random nonsingular diagonal matrix and its inverse, and extracts
tests/test-inverse.C:322: * iterations - Number of random diagonal matrices to construct
tests/test-inverse.C:401: * Compute the inverse of a random dense matrix and apply its transpose to
tests/test-inverse.C:402: * random vectors
tests/test-inverse.C:406: * iterations - Number of random vectors to which to apply matrix
tests/test-inverse.C:417:	commentator().start ("Testing random transpose", "testRandomTranspose", stream1.m ());
tests/test-inverse.C:428:			r.random (x);
tests/test-det.C:57: * Construct a random diagonal matrix with distinct entries and see that its
tests/test-det.C:93:                do r.random (d[j]); while (F.isZero (d[j]));
tests/test-det.C:149: * Construct a random diagonal matrix with nondistinct entries and see that its
tests/test-det.C:182:            do r.random (d[j]); while (F.isZero (d[j]));
tests/test-det.C:241: * Construct a random diagonal matrix with one zero entry
tests/test-det.C:270:            r.random (d[j]);
tests/test-det.C:319: * Construct a random nonsingular diagonal sparse matrix and compute its
tests/test-det.C:344:            integer::nonzerorandom (tmp, 20*i + 1);
tests/test-det.C:397: * Construct a random nonsingular diagonal sparse matrix and compute its
tests/test-det.C:422:            integer::nonzerorandom (tmp, 20*i + 1);
tests/test-det.C:480: * Construct a random nonsingular diagonal sparse matrix and compute its
tests/test-det.C:507:            integer::nonzerorandom (tmp_n, 20*i + 1);
tests/test-det.C:508:            integer::nonzerorandom (tmp_d, 20*i + 1);
tests/test-rank.h:70:/* Test 3: Rank of a random sparse matrix
tests/test-rank.h:72: * Constructs a random sparse matrix and computes its rank using Gaussian
tests/test-solve.C:61: * that that inverse is itself the identity operator by applying it to random
tests/test-solve.C:154: * Constructs a random nonsingular diagonal matrix D and a random right-hand
tests/test-solve.C:266: * Constructs a random diagonal matrix D of rank r and a random right-hand
tests/test-solve.C:390: * Constructs a random diagonal matrix D of rank r and a random right-hand
tests/test-solve.C:510: * Constructs a random diagonal matrix D of rank r and a random right-hand
tests/test-solve.C:628:/* Test 6: Test solution of random system
tests/test-solve.C:639:	str << "Testing random solve (" << text << ")";
tests/test-vector-domain.h:47: * Construct two random vectors and compute their dot product
tests/test-vector-domain.h:135: * Construct two random vectors x and y and a random element a and compute (x +
tests/test-vector-domain.h:177:		do r.random (a); while (F.isZero (a));
tests/test-vector-domain.h:237: * Construct two random vectors x and y and a random element a and compute (x -
tests/test-vector-domain.h:279:		do r.random (a); while (F.isZero (a));
tests/test-vector-domain.h:339: * Construct two random vectors x and y and a random element a and compute (x +
tests/test-vector-domain.h:379:		do r.random (a); while (F.isZero (a));
tests/test-vector-domain.h:421: * Constructs a random vector and copies it to another vector. Then checks equality.
tests/test-qlup.C:29: * @brief  tests LQUP decomposition, solve, and nullspace of a random sparse matrice.
tests/test-qlup.C:30: * @test tests LQUP decomposition, solve, and nullspace of a random sparse matrice.
tests/test-qlup.C:57:/* Test 1: LQUP decomposition of a random sparse matrix
tests/test-qlup.C:59: * Constructs a random sparse matrix and computes its QLUP decomposition
tests/test-qlup.C:90:			generator.random (*it);
tests/test-qlup.C:159:/* Test 2: LQUP solve of a random sparse matrix and a random dense vector
tests/test-qlup.C:161: * Constructs a random sparse matrix and computes its QLUP decomposition
tests/test-qlup.C:180:	// GF2::Element randomsolve;
tests/test-qlup.C:195:			generator.random (*it);
tests/test-qlup.C:206:		GD.solvein(x, A, v /*, bitgenerator .random(randomsolve) */ );
tests/test-qlup.C:207:		// report << "Random solving: " << randomsolve << std::endl;
tests/test-qlup.C:244:/* Test 2: LQUP nullspacebasis of a random sparse matrix
tests/test-qlup.C:246: * Constructs a random sparse matrix and computes its QLUP decomposition
tests/test-qlup.C:288:			generator.random (*it);
tests/test-hadamard-bound.C:24:#include "linbox/matrix/random-matrix.h"
tests/test-hadamard-bound.C:48:    RDM.randomFullRank(A);
tests/test-hadamard-bound.C:77:        b.random(randIter);
tests/test-hadamard-bound.C:117:                              {'s', "-s", "Seed for randomness.", TYPE_INT, &seed},
tests/test-ispossemidef.C:69:	// several iterations since there is randomness in the alg (though none in this test)
tests/test-matrix-domain.h:90:		random: void setRandom(Matrix & I, opt args)
tests/test-matrix-domain.h:131:		Vector& random(Vector& v)
tests/test-matrix-domain.h:163:	A.random(); B.random();
tests/test-local-smith-form-sparseelim.C:59:/** @brief Test 1: Invariant factors of random sparse matrices.
tests/test-local-smith-form-sparseelim.C:61: * Construct a random matrix with random RPM 
tests/test-local-smith-form-sparseelim.C:62: *           and random local Smith form.
tests/test-local-smith-form-sparseelim.C:180:	commentator().start ("Random sparse matrix with random RPM", "RSMRRPM");
tests/test-local-smith-form-sparseelim.C:216:                G.random (L.refEntry(l,j));
tests/test-local-smith-form-sparseelim.C:228:            if (nonzero(gen)<density) G.random ( U.refEntry(i,j) );
tests/test-local-smith-form-sparseelim.C:259:        // This is just to generate the random test via fgemm_mp
tests/test-local-smith-form-sparseelim.C:286:		{ 'd', "-d d", "Density of random sparse matrices.", TYPE_DOUBLE, &d },
tests/test-local-smith-form-sparseelim.C:322:            Integer::random(iq,std::max(q,Integer(131071)));
tests/test-smith-form-adaptive.C:39:#include "linbox/randiter/random-prime.h"
tests/test-charpoly.C:210: * Generates a random sparse matrix with K nonzero elements per row and computes
tests/test-charpoly.C:211: * its characteristic polynomial. Then computes random vectors and applies the
tests/test-charpoly.C:217: * numVectors - Number of random vectors to which to apply the characteristic polynomial
tests/test-charpoly.C:231:	LinBox::commentator().start ("Testing sparse random charpoly", "testRandomCharpoly", 1);
tests/test-charpoly.C:293:		{ 'v', "-v V", "Use V test vectors for the random charpoly tests.",      TYPE_INT,     &numVectors },
tests/test-charpoly.C:294:		{ 'k', "-k K", "K nonzero Elements per row in sparse random apply test.", TYPE_INT,     &k },
tests/matrix/randommat.h:41:Matrix& randomMat(const Ring& R, Matrix& Mat, size_t n, size_t epr){
tests/matrix/randommat.h:63:			//  choose random location for value
tests/matrix/Makefile:344:	 randomans.h\
tests/matrix/Makefile:345:   	 randommat.h
tests/matrix/randomans.h:1://  randomans.h  - Random Almost NonSingular matrix
tests/matrix/randomans.h:36:Matrix& randomAns(const Ring& R, Matrix& Mat, size_t n, size_t epr){
tests/matrix/randomans.h:58:			//  choose random location for value
tests/matrix/randomans.h:90:	//  add one to random value
tests/matrix/Makefile.am:29:	 randomans.h\
tests/matrix/Makefile.am:30:   	 randommat.h
tests/matrix/Makefile.in:344:	 randomans.h\
tests/matrix/Makefile.in:345:   	 randommat.h
tests/test-frobenius.C:74:	for ( size_t i=0; i < pdeg; ++i) r.random(plist[0][i]);
tests/test-frobenius.C:79:	for ( size_t i=0; i < pdeg; ++i) r.random(plist[1][i]);
tests/test-frobenius.C:84:	for ( size_t i=0; i < pdeg; ++i) r.random(plist[2][i]);
tests/test-image-field.C:63:		{ 't', "-t T", "Number of trials for the random iterator test.", TYPE_INT, &trials },
tests/test-image-field.C:64:		{ 'c', "-c C", "Number of categories for the random iterator test.", TYPE_INT, &categories },
tests/test-image-field.C:65:		{ 'H', "-H H", "History level for random iterator test.", TYPE_INT, &hist_level },
tests/test-blas-domain.C:67:#include "linbox/matrix/random-matrix.h"
tests/test-blas-domain.C:261:		// Create 3 random n*n matrices
tests/test-blas-domain.C:262:		A.random();
tests/test-blas-domain.C:263:		B.random();
tests/test-blas-domain.C:264:		C.random();
tests/test-blas-domain.C:266:		// Create 2 random vectors
tests/test-blas-domain.C:268:			G.random(x[i]);
tests/test-blas-domain.C:269:			G.random(y[i]);
tests/test-blas-domain.C:272:		// create 2 random element
tests/test-blas-domain.C:273:		G.random(alpha);
tests/test-blas-domain.C:274:		G.random(beta);
tests/test-blas-domain.C:346:	Integer p = Integer::random_between(10,12) ;
tests/test-blas-domain.C:454:		Arand.random<IMatrix>(A);
tests/test-blas-domain.C:455:		Brand.random<IMatrix>(B);
tests/test-blas-domain.C:456:		Crand.random<IMatrix>(C);
tests/test-blas-domain.C:460:				A.setEntry(i,j,Integer::random());
tests/test-blas-domain.C:461:				B.setEntry(i,j,Integer::random());
tests/test-blas-domain.C:462:				C.setEntry(i,j,Integer::random());
tests/test-blas-domain.C:481:		a = Integer::random<false>(ll) ; b = 1 ;
tests/test-blas-domain.C:483:		a =Integer::random<false>(ll) ; b = -1 ;
tests/test-blas-domain.C:485:		a =  1 ; b = Integer::random<false>(ll) ;
tests/test-blas-domain.C:487:		a = -1 ; b = Integer::random<false>(ll) ;
tests/test-blas-domain.C:489:		a = 0 ; b = Integer::random<false>(ll) ;
tests/test-blas-domain.C:491:		a = Integer::random<false>(ll) ; b = 0 ;
tests/test-blas-domain.C:493:		a = Integer::random<false>(ll) ; b = Integer::random<false>(ll) ;
tests/test-blas-domain.C:531:	// random A,B
tests/test-blas-domain.C:532:	RandMat.random(A);
tests/test-blas-domain.C:533:	RandMat.random(B);
tests/test-blas-domain.C:534:	RandMat.random(C);
tests/test-blas-domain.C:544:	// random alpha, beta
tests/test-blas-domain.C:546:	do {R.random(alpha);} while (F.isZero(alpha)); // nonzerorandom
tests/test-blas-domain.C:549:	R.random(beta);
tests/test-blas-domain.C:614:	// random A,B
tests/test-blas-domain.C:615:	RandMat.random(A);
tests/test-blas-domain.C:616:	RandMat.random(B);
tests/test-blas-domain.C:734:		r = (unsigned int)((size_t)random() % n);
tests/test-blas-domain.C:737:			S.setEntry(i,i,Gn.random(tmp));
tests/test-blas-domain.C:739:				S.setEntry(i,j,G.random(tmp));
tests/test-blas-domain.C:747:				L.setEntry(i,j,G.random(tmp));
tests/test-blas-domain.C:748:			L.setEntry(i,i,Gn.random(tmp));
tests/test-blas-domain.C:797:		G.random(d);
tests/test-blas-domain.C:806:				S.setEntry(i,j,G.random(tmp));
tests/test-blas-domain.C:813:				L.setEntry(i,j,G.random(tmp));
tests/test-blas-domain.C:871:		// with nonzero random diagonal's element
tests/test-blas-domain.C:873:			S.setEntry(i,i,Gn.random(tmp));
tests/test-blas-domain.C:875:				S.setEntry(i,j,G.random(tmp));
tests/test-blas-domain.C:882:				L.setEntry(i,j,G.random(tmp));
tests/test-blas-domain.C:955:		// Create B a random matrix
tests/test-blas-domain.C:958:				B.setEntry(i,j,G.random(tmp));
tests/test-blas-domain.C:960:		//create random vector b
tests/test-blas-domain.C:962:			F.init(b[i],G.random(tmp));
tests/test-blas-domain.C:964:		// Create Au a random full rank upper triangular matrix
tests/test-blas-domain.C:966:			Au.setEntry(i,i,Gn.random(tmp));
tests/test-blas-domain.C:968:				Au.setEntry(i,j,G.random(tmp));
tests/test-blas-domain.C:971:		// Create Al a random full rank lower triangular matrix
tests/test-blas-domain.C:974:				Al.setEntry(i,j,G.random(tmp));
tests/test-blas-domain.C:975:			Al.setEntry(i,i,Gn.random(tmp));
tests/test-blas-domain.C:1064:		// Create B a random matrix
tests/test-blas-domain.C:1067:				B.setEntry(i,j,G.random(tmp));
tests/test-blas-domain.C:1069:		//create a random vector b
tests/test-blas-domain.C:1071:			F.init(b[i],G.random(tmp));
tests/test-blas-domain.C:1075:		// with nonzero random diagonal's element
tests/test-blas-domain.C:1077:			S.setEntry(i,i,Gn.random(tmp));
tests/test-blas-domain.C:1079:				S.setEntry(i,j,G.random(tmp));
tests/test-blas-domain.C:1086:				L.setEntry(i,j,G.random(tmp));
tests/test-blas-domain.C:1179:			// G.random(tmp);
tests/test-blas-domain.C:1180:			// if ( Z2.isZero(G2.random(tmp2) ) )
tests/test-blas-domain.C:1181:				// P[i] = i + ( (size_t) random() % (m-i) );
tests/test-blas-domain.C:1192:		// Create A a random matrix
tests/test-blas-domain.C:1195:				A.setEntry(i,j,Gn.random(tmp));
tests/test-blas-domain.C:1196:		// Create a a random vector
tests/test-blas-domain.C:1198:			F.assign(a[i],Gn.random(tmp));
tests/test-blas-domain.C:1296:		// Create B a random matrix
tests/test-blas-domain.C:1299:				B.setEntry(i,j,G.random(tmp));
tests/test-blas-domain.C:1314:		// Create B a random matrix
tests/test-blas-domain.C:1317:				B.setEntry(i,j,G.random(tmp));
tests/test-blas-domain.C:1333:		// Create B a random matrix
tests/test-blas-domain.C:1336:				B.setEntry(i,j,G.random(tmp));
tests/test-blas-domain.C:1352:		// Create B a random matrix
tests/test-blas-domain.C:1355:				B.setEntry(i,j,G.random(tmp));
tests/test-blas-domain.C:1371:		// Create B a random matrix
tests/test-blas-domain.C:1374:				B.setEntry(i,j,G.random(tmp));
tests/test-blas-domain.C:1389:		// Create B a random matrix
tests/test-blas-domain.C:1392:				B.setEntry(i,j,G.random(tmp));
tests/test-blas-domain.C:1408:		// Create B a random matrix
tests/test-blas-domain.C:1411:				B.setEntry(i,j,G.random(tmp));
tests/test-blas-domain.C:1427:		// Create B a random matrix
tests/test-blas-domain.C:1430:				B.setEntry(i,j,G.random(tmp));
tests/test-blas-domain.C:1479:		// Create B a random matrix of rank n/2
tests/test-blas-domain.C:1483:				  B.setEntry(i,j,G.random(tmp));
tests/test-blas-domain.C:1487:		// Create C a random matrix of rank n/2
tests/test-blas-domain.C:1491:					C.setEntry(i,j,G.random(tmp));
tests/test-blas-domain.C:1591:		G.random(tmp);
tests/test-blas-domain.C:1682:		G.random(tmp);
tests/test-mg-block-lanczos.C:55:/* Test 1: Test solution of random system
tests/test-mg-block-lanczos.C:66:	commentator().start ("Testing random solve (Block Lanczos)", "testRandomSolve", y_stream.size ());
tests/test-mg-block-lanczos.C:128:/* Test 2: Test sampling of nullspace of random system
tests/test-weak-popov-form.C:15:#include "linbox/matrix/random-matrix.h"
tests/test-toeplitz-det.C:43:#include "linbox/randiter/random-prime.h"
tests/test-toeplitz-det.C:75:	report << "\tUsing random primes and square matrices of size 2 to " << N_BOUND << endl;
tests/test-toeplitz-det.C:89:		randit.random(temp);
tests/test-random-matrix.C:4:#include "linbox/matrix/random-matrix.h"
tests/test-random-matrix.C:22:	RDM.randomFullRank(M);
tests/test-block-wiedemann.C:57:/* Tests nonsingular solving for a random right-hand side.
tests/test-block-wiedemann.C:60: * Blackbox - nonsingular matrix (rhs will be a random vector).
tests/test-block-wiedemann.C:107:                { 's', "-s N", "Set the seed for randomness", TYPE_INT, &seed },
tests/test-block-wiedemann.C:121:        Field::RandIter G(F, 0, seed); //random generator over F
tests/test-block-wiedemann.C:122:        Field::NonZeroRandIter NzG(G); //non-zero random generator over F 
tests/test-block-wiedemann.C:138:	Diagonal <Field> D (d); // random nonsingular diagonal
linbox/solutions/det.h:234:					do iter.random (diag[i]); while (F.isZero (diag[i]));
linbox/solutions/det.h:292:					do iter.random (diag[i]); while (F.isZero (diag[i]));
linbox/solutions/det.h:532:#include "linbox/randiter/random-prime.h"
linbox/solutions/valence.h:103:#include "linbox/randiter/random-prime.h"
linbox/solutions/charpoly.h:33:#include "linbox/randiter/random-prime.h"
linbox/solutions/charpoly.h:60:	  is of degree d, this random access container has size d+1, the 0-th
linbox/solutions/rank.h:30:#include "linbox/randiter/random-prime.h"
linbox/solutions/minpoly.h:73:	 * of degree d, this random access container has size d+1, the 0-th entry is
linbox/solutions/minpoly.h:191:#include "linbox/randiter/random-prime.h"
linbox/solutions/solutions.doxy:33:  <li><code>solve(x, A, b[, method[, status]])</code> get x such that Ax = b, random solution if sigular and consistent, x = 0 if inconsistent (also inconsistency is indicated in the status).
linbox/solutions/solutions.doxy:35:  These include symmetry, nonsingularity, and that an arbitrary solution is acceptable rather than a random sample.</li>
linbox/solutions/solutions.doxy:124:  apply's (apply and applyTranspose give same result on a random vector x).
linbox/solutions/solutions.doxy:144:  - Standard Wiedemann mod a random wordsize prime if the field/ring is Q/Z
linbox/solutions/solutions.doxy:149:  - blas lu mod a random wordsize prime if the field/ring is Q/Z
linbox/solutions/solutions.doxy:186:minpoly is probabilistic, whether by blackbox or elim methods (random vector, Keller-Gehrig)
linbox/solutions/solve.h:81:         * matrix A, if the system is consistent, a random solution is returned
linbox/solutions/solve.h:173:        commentator().start ("Sparse Elimination Solve In Place with random solution", "sesolvein");
linbox/solutions/solve.h:746:#include "linbox/randiter/random-prime.h"
linbox/solutions/rank.inl:135:				do iter.random (d1[i]); while (F.isZero (d1[i]));
linbox/solutions/rank.inl:174:					do iter.random (d1[i]); while (F.isZero (d1[i]));
linbox/solutions/rank.inl:182:					do iter.random (d1[i]); while (F.isZero (d1[i]));
linbox/solutions/rank.inl:215:					do iter.random (d1[i]); while (F.isZero (d1[i]));
linbox/solutions/rank.inl:266:				do iter.random (d1[i]); while (F.isZero (d1[i]));
linbox/solutions/rank.inl:269:				do iter.random (d2[i]); while (F.isZero (d2[i]));
linbox/solutions/rank.inl:311:					do iter.random (d1[i]); while (F.isZero (d1[i]));
linbox/solutions/rank.inl:314:					do iter.random (d2[i]); while (F.isZero (d2[i]));
linbox/solutions/rank.inl:355:					do iter.random (d1[i]); while (F.isZero (d1[i]));
linbox/solutions/rank.inl:358:					do iter.random (d2[i]); while (F.isZero (d2[i]));
linbox/solutions/methods.h:105:		 * PARTIAL_DIAGONAL - Use AD, where D is a random nonsingular diagonal
linbox/solutions/methods.h:107:		 * PARTIAL_DIAGONAL_SYMMETRIZE - Use A^T D A, where D is a random
linbox/solutions/methods.h:109:		 * FULL_DIAGONAL - Use D_1 A^T D_2 A D_1, where D_1 and D_2 are random
linbox/solutions/methods.h:706:		 * randomized algorithms Wiedemann and Lanczos); default is true
linbox/archetypes.doxy:28:  random iterators, and vectors.
linbox/archetypes.doxy:43:  Archetypes exist for fields, field elements, random iterators, vectors,
linbox/archetypes.doxy:67:- Random iterator archetype.  %LinBox fields (and rings) provide a random iterator
linbox/archetypes.doxy:68:	type.  Objects of this type can be used to generate elements at random.  \c
linbox/archetypes.doxy:89:- Random Iterator archetypes. \subpage randomIGA.  \subpage randomFEGW
linbox/ring/envelope.h:75:		 * a wrapped ring random iterator generator.
linbox/ring/local-pir-modular.h:129:        using Parent_t:: random;
linbox/ring/local-pir-modular.h:130:        using Parent_t:: nonzerorandom;
linbox/ring/ntl/ntl-gf2e.h:229:		Element& random (Element& x) const
linbox/ring/ntl/ntl-gf2e.h:231:                NTL::random(x);
linbox/ring/ntl/ntl-zz_pe.h:422:		NTL::ZZ_pE& random (NTL::ZZ_pE& x) const
linbox/ring/ntl/ntl-zz_pe.h:424:			NTL::random(x);
linbox/ring/ntl/ntl-rr.h:300:			std::cout << "created random generator with size " << _size
linbox/ring/ntl/ntl-rr.h:304:			// Seed random number generator
linbox/ring/ntl/ntl-rr.h:314:		 * This returns a random field element from the information supplied
linbox/ring/ntl/ntl-rr.h:316:		 * This generator uses the built-in C++ random number generator instead of
linbox/ring/ntl/ntl-rr.h:317:		 * NTL's random function because the NTL function does not allow as much
linbox/ring/ntl/ntl-rr.h:321:		 * @return random field element
linbox/ring/ntl/ntl-rr.h:323:		Element& random(Element &elt) const
linbox/ring/ntl/ntl-rr.h:325:			// NTL::random(elt);
linbox/ring/ntl/ntl-rr.h:326:			// Create new random elements
linbox/ring/ntl/ntl-rr.h:335:			std::cout << "random double = " << temp << "    random Element = " << elt << std::endl;
linbox/ring/ntl/ntl-lzz_px.h:605:		Element& random (Element& x) const
linbox/ring/ntl/ntl-lzz_px.h:607:			NTL::random(x, 1);
linbox/ring/ntl/ntl-lzz_px.h:611:		Element& random(Element &x, size_t d) const {
linbox/ring/ntl/ntl-lzz_px.h:612:			NTL::random(x, d + 1);
linbox/ring/ntl/ntl-lzz_px.h:616:		Element& randomIrreducible(Element &x, size_t d) const {
linbox/ring/ntl/ntl-zz_p.h:474:	/// Constructor for random field element generator
linbox/ring/ntl/ntl-zz_p.h:495:			std::cout << "created random generator with size " << _size
linbox/ring/ntl/ntl-zz_p.h:499:			// Seed random number generator
linbox/ring/ntl/ntl-zz_p.h:517:		NTL::ZZ_p& random(NTL::ZZ_p& x) const
linbox/ring/ntl/ntl-zz_p.h:520:				return x = NTL::random_ZZ_p();
linbox/ring/ntl/ntl-lzz_p.h:339:            /// Constructor for random field element generator
linbox/ring/ntl/ntl-lzz_p.h:354:                std::cout << "created random generator with size " << _size
linbox/ring/ntl/ntl-lzz_p.h:358:                    // Seed random number generator
linbox/ring/ntl/ntl-lzz_p.h:367:		NTL::zz_p& random(NTL::zz_p& x) const
linbox/ring/ntl/ntl-lzz_p.h:370:                    return x = NTL::random_zz_p();
linbox/ring/ntl/ntl-lzz_pex.h:553:		Element& random (Element& x) const
linbox/ring/ntl/ntl-lzz_pex.h:555:                NTL::random(x, 1);
linbox/ring/ntl/ntl-lzz_pe.h:165:		Element& random (Element& x) const
linbox/ring/ntl/ntl-lzz_pe.h:167:                NTL::random(x);
linbox/ring/ntl/ntl-lzz_pe.h:419:		Element& random (Element& x) const
linbox/ring/ntl/ntl-lzz_pe.h:421:                NTL::random(x);
linbox/ring/archetype.h:101:		 * random element generator to which
linbox/ring/archetype.h:142:		 * encapsulated element and random element generator.
linbox/ring/archetype.h:144:		 * Creates new copies of ring, element, and random iterator generator
linbox/ring/archetype.h:150:		 *                        encapsulated random iterator generator
linbox/ring/archetype.h:165:		 * encapsulated element and random element generator if needed.
linbox/algorithms/cra-early-multip.h:116:			//   then only, try a random linear combination.
linbox/algorithms/cra-early-multip.h:135:			//   then only, try a random linear combination.
linbox/algorithms/cra-early-multip.h:159:			  then only, try a random linear combination.
linbox/algorithms/cra-early-multip.h:174:			  then only, try a random linear combination.
linbox/algorithms/block-massey-domain.h:301:				throw PreconditionFailed (__func__, __LINE__, "Bad random Blocks, abort\n");
linbox/algorithms/cra-domain-omp.h:45:#include "linbox/randiter/random-prime.h"
linbox/algorithms/wiedemann.h:23: *    findRandomSolution - Find a random solution to a singular preconditioned
linbox/algorithms/wiedemann.h:221:	 * solving with Wiedemann's algorithm. It includes the random solution and
linbox/algorithms/wiedemann.h:222:	 * random nullspace element of Kaltofen and Saunders (1991), as well as the
linbox/algorithms/wiedemann.h:244:		/*! Constructor with a random iterator.
linbox/algorithms/wiedemann.h:249:		 * @param r Random iterator to use for randomization
linbox/algorithms/wiedemann.h:262:		/*! Solve a system Ax=b, giving a random solution if the system is
linbox/algorithms/wiedemann.h:277:		 * This is a "Las Vegas" method, which makes use of randomization. It
linbox/algorithms/wiedemann.h:284:		 * @param useRandIter true if solveNonsingular should use a random
linbox/algorithms/wiedemann.h:311:		/*! Get a random solution to a singular system Ax=b of rank r with
linbox/algorithms/wiedemann.h:330:		/*! Get a random element of the right nullspace of A.
linbox/algorithms/polynomial-matrix/matpoly-mult-fft-recint.inl:30:#include "linbox/randiter/random-fftprime.h"
linbox/algorithms/polynomial-matrix/matpoly-mult-fft-recint.inl:31:#include "linbox/randiter/random-prime.h"
linbox/algorithms/polynomial-matrix/matpoly-mult-fft.h:34:#include <linbox/randiter/random-fftprime.h>
linbox/algorithms/polynomial-matrix/matpoly-mult-fft.h:35:#include <linbox/randiter/random-prime.h>
linbox/algorithms/polynomial-matrix/order-basis.h:82:                        Gen.random(U.ref(i,0,0));
linbox/algorithms/polynomial-matrix/matpoly-mult-fft-multiprecision.inl:31:#include "linbox/randiter/random-fftprime.h"
linbox/algorithms/polynomial-matrix/matpoly-mult-fft-multiprecision.inl:32:#include "linbox/randiter/random-prime.h"
linbox/algorithms/polynomial-matrix/matpoly-mult-fft-wordsize-three-primes.inl:33:#include "linbox/randiter/random-fftprime.h"
linbox/algorithms/matrix-blas3/mul-cra.inl:31:#include "givaro/random-integer.h"
linbox/algorithms/matrix-blas3/mul-cra.inl:32:#include "linbox/randiter/random-prime.h"
linbox/algorithms/rational-solver-adaptive.h:35:#include "linbox/randiter/random-prime.h"
Binary file linbox/algorithms/diophantine-solver.o matches
linbox/algorithms/blackbox-container.h:91:				g.random (this->u[(size_t)i]);
linbox/algorithms/blackbox-container.h:94:				g.random (this->w[(size_t)i]);
linbox/algorithms/frobenius-large.h:36:#include "linbox/matrix/random-matrix.h"
linbox/algorithms/frobenius-large.h:78:	void randomPolynomial(Polynomial &f, size_t d) const {
linbox/algorithms/frobenius-large.h:83:			_RI.random(c);
linbox/algorithms/frobenius-large.h:112:		randomPolynomial(u, n+k-3);
linbox/algorithms/frobenius-large.h:113:		randomPolynomial(v, n+k-3);
linbox/algorithms/rns.inl:59:				size_t p = genprimes.randomPrime() ;
linbox/algorithms/rns.inl:186:				size_t p = genprimes.randomPrime() ;
linbox/algorithms/diophantine-solver.h:43:	 * Methods solve, randomSolve just expose functions from underlying rational solver.
linbox/algorithms/diophantine-solver.h:93:		/** Find a random solution of the general linear system \c Ax=b over quotient field of a ring.
linbox/algorithms/diophantine-solver.h:108:		SolverReturnStatus randomSolve(Vector1& x, Integer& den, const IMatrix& A, const Vector2& b, const int maxPrimes = DEFAULT_MAXPRIMES,
linbox/algorithms/block-wiedemann.h:118:                                        // set V at random
linbox/algorithms/block-wiedemann.h:121:                                                        _rand.random(V.refEntry(i,j));
linbox/algorithms/block-wiedemann.h:125:                                                        _rand.random(UA.refEntry(i,j));
linbox/algorithms/lanczos.h:63:		/** @brief Constructor with a random iterator
linbox/algorithms/lanczos.h:67:		 * @param r Random iterator to use for randomization
linbox/algorithms/lanczos.h:77:		 * a random solution.
linbox/algorithms/lanczos.h:81:		 * random nonsingular diagonal matrices. If the matrix A is symmetric,
linbox/algorithms/lanczos.h:82:		 * this method preconditions the system with A D, where D is a random
linbox/algorithms/wiedemann.inl:17: *    findRandomSolution - Find a random solution to a singular preconditioned
linbox/algorithms/mg-block-lanczos.h:85:		/** Constructor with a random iterator
linbox/algorithms/mg-block-lanczos.h:89:		 * @param r Random iterator to use for randomization
linbox/algorithms/mg-block-lanczos.h:103:		 * a random solution.
linbox/algorithms/mg-block-lanczos.h:107:		 * random nonsingular diagonal matrices. If the matrix A is symmetric,
linbox/algorithms/mg-block-lanczos.h:108:		 * this method preconditions the system with A D, where D is a random
linbox/algorithms/lanczos.inl:280:		// Get a random vector _w[1]
linbox/algorithms/blackbox-block-container.h:96:		//  constructor of the sequence from a blackbox, a field and two blocks random projection
linbox/algorithms/blackbox-block-container.h:235:		//  constructor of the sequence from a blackbox, a field and two blocks random projection
linbox/algorithms/mg-block-lanczos.inl:371:			// Fill y with random data
linbox/algorithms/mg-block-lanczos.inl:552:		// Get a random fat vector _matV[0]
linbox/algorithms/mg-block-lanczos.inl:1291:	// Compute a random dense matrix and run compute_Winv_S on it. Check that the
linbox/algorithms/mg-block-lanczos.inl:1434:	// Compute a random nonsingular diagonal matrix and set an S vector so that
linbox/algorithms/mg-block-lanczos.inl:1465:	// Compute a random dense matrix and two random vectors, and check that <A^T x,
linbox/algorithms/coppersmith-invariant-factors.h:31:#include "linbox/matrix/random-matrix.h"
linbox/algorithms/coppersmith-invariant-factors.h:73:		RDM.random(U_);
linbox/algorithms/coppersmith-invariant-factors.h:74:		RDM.random(V_);
linbox/algorithms/coppersmith-invariant-factors.h:83:		RDM.random(U_);
linbox/algorithms/coppersmith-invariant-factors.h:84:		RDM.random(V_);
linbox/algorithms/block-lanczos.inl:403:		// Get a random fat vector _matV[0]
linbox/algorithms/block-lanczos.inl:1101:	// Compute a random dense matrix and run compute_Winv_S on it. Check that the
linbox/algorithms/block-lanczos.inl:1244:	// Compute a random nonsingular diagonal matrix and set an S vector so that
linbox/algorithms/block-lanczos.inl:1275:	// Compute a random dense matrix and two random vectors, and check that <A^T x,
linbox/algorithms/poly-smith-form.h:253:				_RI.random(e, max_deg);
linbox/algorithms/poly-smith-form.h:287:				_RI.randomIrreducible(f, d++);
linbox/algorithms/vector-fraction.h:55:	//this could be replaced by a fancier version that combines elements linearly at random
linbox/algorithms/vector-fraction.h:63:	// this could be replaced by a fancier version that combines elements linearly at random
linbox/algorithms/vector-fraction.h:222:			// strategy: pick random values of A <= d(y_0)
linbox/algorithms/vector-fraction.h:226:			// TODO: I don't think this random iterator has high-quality low order bits, which are needed
linbox/algorithms/vector-fraction.h:228:				randiter.random(A);
linbox/algorithms/vector-fraction.h:276:			// strategy: pick random values of A <= lcm(d(denom), d(other.denom))
linbox/algorithms/vector-fraction.h:281:			// TODO: I don't think this random iterator has high-quality low order bits, which are needed
linbox/algorithms/vector-fraction.h:283:				randiter.random(A);
linbox/algorithms/double-det.h:35:#include "linbox/randiter/random-prime.h"
linbox/algorithms/varprec-cra-early-single.h:143:			//   then only, try a random linear combination.
linbox/algorithms/varprec-cra-early-single.h:172:			//   then only, try a random linear combination.
linbox/algorithms/last-invariant-factor.h:121:				// assign b to be a random vector
linbox/algorithms/last-invariant-factor.h:123:// 					* b_p = rand() % 268435456 - 134217728; // may need to change to use ring's random gen.
linbox/algorithms/last-invariant-factor.h:182:				// assign b to be a random vector
linbox/algorithms/last-invariant-factor.h:185:                                        *b_p = _gen.random();//(* b_p);
linbox/algorithms/last-invariant-factor.h:189:                                        *b_p = _gen.random();//(* b_p);
linbox/algorithms/last-invariant-factor.h:283:			// assign b to be a random vector
linbox/algorithms/last-invariant-factor.h:285:// 				* b_p = rand() % 268435456 - 134217728; // may need to change to use ring's random gen.
linbox/algorithms/bbsolve.h:66:	 * consistent and singular, it returns a random solution. Repeated
linbox/algorithms/bbsolve.h:142:	 * random solution. Repeated calls to this function can give a complete
linbox/algorithms/bbsolve.h:174:	 * random solution. Repeated calls to this function can give a complete
linbox/algorithms/bbsolve.h:207:	 * random solution. Repeated calls to this function can give a complete
linbox/algorithms/dense-nullspace.h:31: *	- (soon) a random vector within the nullspace of \p A
linbox/algorithms/dense-nullspace.h:32: * @todo random nullspace vector
linbox/algorithms/cia.h:32:#include "linbox/randiter/random-prime.h"
linbox/algorithms/frobenius-small.h:34:#include "linbox/matrix/random-matrix.h"
linbox/algorithms/frobenius-small.h:139:	void randomVector(Vector &v) const {
linbox/algorithms/frobenius-small.h:142:			_RI.random(e);
linbox/algorithms/frobenius-small.h:148:	void randomVec(
linbox/algorithms/frobenius-small.h:153:		randomVector(u);
linbox/algorithms/frobenius-small.h:185:		randomVector(u);
linbox/algorithms/frobenius-small.h:190:			randomVector(u);
linbox/algorithms/frobenius-small.h:391:				randomVec(u, basis_us, basis_vs);
linbox/algorithms/frobenius-small.h:392:				randomVec(v, basis_vs, basis_us);
linbox/algorithms/gauss/gauss-solve.inl:111:			generator.random( *it );
linbox/algorithms/gauss/gauss-solve-gf2.inl:100:            generator.random( *it );
linbox/algorithms/la-block-lanczos.h:72:		/** Constructor with a random iterator
linbox/algorithms/la-block-lanczos.h:76:		 * @param r Random iterator to use for randomization
linbox/algorithms/la-block-lanczos.h:94:		 * a random solution.
linbox/algorithms/block-lanczos.h:82:		/** Constructor with a random iterator.
linbox/algorithms/block-lanczos.h:86:		 * @param r Random iterator to use for randomization
linbox/algorithms/block-lanczos.h:98:		 * a random solution.
linbox/algorithms/block-lanczos.h:102:		 * random nonsingular diagonal matrices. If the matrix A is symmetric,
linbox/algorithms/block-lanczos.h:103:		 * this method preconditions the system with A D, where D is a random
linbox/algorithms/.deps/diophantine-solver.Plo:154: /usr/include/c++/5/random /usr/include/c++/5/bits/random.h \
linbox/algorithms/.deps/diophantine-solver.Plo:156: /usr/include/x86_64-linux-gnu/c++/5/bits/opt_random.h \
linbox/algorithms/.deps/diophantine-solver.Plo:209: /usr/include/c++/5/bits/random.tcc /usr/include/c++/5/numeric \
linbox/algorithms/.deps/diophantine-solver.Plo:241: /home/zhg/soft/builds/include/givaro/givrandom.h \
linbox/algorithms/.deps/diophantine-solver.Plo:267: /home/zhg/soft/builds/include/givaro/random-integer.h \
linbox/algorithms/.deps/diophantine-solver.Plo:299: /home/zhg/soft/builds/include/recint/rurandom.h \
linbox/algorithms/.deps/diophantine-solver.Plo:439: /home/zhg/soft/builds/include/recint/rmrandom.h \
linbox/algorithms/.deps/diophantine-solver.Plo:448: /home/zhg/soft/builds/include/recint/rrandom.h \
linbox/algorithms/.deps/diophantine-solver.Plo:627: /home/zhg/soft/builds/include/fflas-ffpack/utils/fflas_randommatrix.h \
linbox/algorithms/.deps/diophantine-solver.Plo:684: ../../linbox/randiter/multimod-randomprime.h \
linbox/algorithms/.deps/diophantine-solver.Plo:699: ../../linbox/randiter/random-fftprime.h \
linbox/algorithms/.deps/diophantine-solver.Plo:700: ../../linbox/randiter/random-prime.h \
linbox/algorithms/.deps/diophantine-solver.Plo:1153:/usr/include/c++/5/random:
linbox/algorithms/.deps/diophantine-solver.Plo:1155:/usr/include/c++/5/bits/random.h:
linbox/algorithms/.deps/diophantine-solver.Plo:1159:/usr/include/x86_64-linux-gnu/c++/5/bits/opt_random.h:
linbox/algorithms/.deps/diophantine-solver.Plo:1265:/usr/include/c++/5/bits/random.tcc:
linbox/algorithms/.deps/diophantine-solver.Plo:1347:/home/zhg/soft/builds/include/givaro/givrandom.h:
linbox/algorithms/.deps/diophantine-solver.Plo:1417:/home/zhg/soft/builds/include/givaro/random-integer.h:
linbox/algorithms/.deps/diophantine-solver.Plo:1481:/home/zhg/soft/builds/include/recint/rurandom.h:
linbox/algorithms/.deps/diophantine-solver.Plo:1797:/home/zhg/soft/builds/include/recint/rmrandom.h:
linbox/algorithms/.deps/diophantine-solver.Plo:1815:/home/zhg/soft/builds/include/recint/rrandom.h:
linbox/algorithms/.deps/diophantine-solver.Plo:2177:/home/zhg/soft/builds/include/fflas-ffpack/utils/fflas_randommatrix.h:
linbox/algorithms/.deps/diophantine-solver.Plo:2303:../../linbox/randiter/multimod-randomprime.h:
linbox/algorithms/.deps/diophantine-solver.Plo:2335:../../linbox/randiter/random-fftprime.h:
linbox/algorithms/.deps/diophantine-solver.Plo:2337:../../linbox/randiter/random-prime.h:
linbox/algorithms/smith-form-adaptive.inl:45:#include "linbox/blackbox/random-matrix.h"
linbox/algorithms/smith-form-adaptive.inl:403:		// compute the rank over a random prime field.
linbox/algorithms/smith-form-adaptive.inl:410:		report << "   Matrix rank over a random prime field: " << r << '\n';
linbox/algorithms/smith-form-adaptive.inl:524:		// compute the rank over a random prime field.
linbox/algorithms/smith-form-adaptive.inl:532:		report << "   Matrix rank over a random prime field: " << r << std::endl;
linbox/algorithms/hybrid-det.h:34:#include "linbox/randiter/random-prime.h"
linbox/algorithms/hybrid-det.h:39:#include "linbox/randiter/random-prime.h"
linbox/algorithms/hybrid-det.h:238:				genprime.randomPrime(p);
linbox/algorithms/hybrid-det.h:482:                genprime.randomPrime(p);
linbox/algorithms/hybrid-det.h:492:			genprime.randomPrime(p);
linbox/algorithms/hybrid-det.h:493:			while (cra.noncoprime(p)) genprime.randomPrime(p);
linbox/algorithms/hybrid-det.h:521:				genprime.randomPrime(p);
linbox/algorithms/hybrid-det.h:642:						genprime.randomPrime(p);
linbox/algorithms/hybrid-det.h:643:						while (cra3.noncoprime(p)) genprime.randomPrime(p);
linbox/algorithms/hybrid-det.h:660:					genprime.randomPrime(p);
linbox/algorithms/hybrid-det.h:661:					while (cra2.noncoprime(p)) genprime.randomPrime(p);
linbox/algorithms/hybrid-det.h:676:				genprime.randomPrime(p);
linbox/algorithms/hybrid-det.h:677:				while (cra2.noncoprime(p)) genprime.randomPrime(p);
linbox/algorithms/sigma-basis.h:771:				throw PreconditionFailed (__func__, __LINE__, "Bad random Blocks, abort\n");
linbox/algorithms/sigma-basis.h:994:				throw PreconditionFailed (__func__, __LINE__, "Bad random Blocks, abort\n");
linbox/algorithms/cra-mpi.h:43:#include "linbox/randiter/random-prime.h"
linbox/algorithms/bbcharpoly.h:49:#include "linbox/randiter/random-prime.h"
linbox/algorithms/bbcharpoly.h:490:					// Evaluation of P in random gamma
linbox/algorithms/bbcharpoly.h:494:						g.random(gamma);
Binary file linbox/algorithms/.libs/diophantine-solver.o matches
Binary file linbox/algorithms/.libs/libalgorithms.a matches
linbox/algorithms/lifting-container.h:755:					_rand.random(UU.refEntry(i,j));
linbox/algorithms/lifting-container.h:760:					_rand.random(V.refEntry(i,j));
linbox/algorithms/lifting-container.h:778:				_rand.random(UAp.refEntry(0,i));
linbox/algorithms/minpoly-integer.h:43:#include "linbox/randiter/random-prime.h"
linbox/algorithms/matpoly-mult.h:29:#include "linbox/randiter/random-fftprime.h"
linbox/algorithms/matpoly-mult.h:48:	// random seed
linbox/algorithms/signature.h:32:#include "linbox/randiter/random-prime.h"
linbox/algorithms/signature.h:149:                size_t r = (size_t)rank_random (M);
linbox/algorithms/signature.h:332:		static long rank_random (const Matrix& M)
linbox/algorithms/diophantine-solver.inl:60:	SolverReturnStatus DiophantineSolver<QSolver>::randomSolve
linbox/algorithms/matrix-rank.h:41:#include "linbox/randiter/random-prime.h"
linbox/algorithms/matrix-rank.h:59:		mutable _RandomPrime rp; //!< Holds the random prime for Monte-Carlo rank
linbox/algorithms/matrix-rank.h:63:		 * @param _rp random prime generator (default is template provided)
linbox/algorithms/matrix-rank.h:71:		/*!compute the integer matrix A by modulo a random prime, Monto-Carlo.
linbox/algorithms/matrix-rank.h:72:		 * This is the generic method (mapping to a random modular matrix).
linbox/algorithms/matrix-rank.h:96:		 * Computation done by mapping to a random modular matrix.
linbox/algorithms/matrix-rank.h:124:		 * Computation done by mapping to a random modular matrix.
linbox/algorithms/rational-solver.inl:164:			typename Field::RandIter random(*F);
linbox/algorithms/rational-solver.inl:165:			BlackboxContainer<Field,SparseMatrix<Field> > Sequence(Ap,*F,random);
linbox/algorithms/rational-solver.inl:178:			prime = _genprime.randomPrime();
linbox/algorithms/rational-solver.inl:256:			typename Field::RandIter random(*F);
linbox/algorithms/rational-solver.inl:257:			BlackboxContainer<Field,FPrecondMatrix> Sequence(PApQ,*F,random);
linbox/algorithms/rational-solver.inl:262:			prime = _genprime.randomPrime();
linbox/algorithms/rational-solver.inl:781:	// There used to be one for random and one for deterministic, but they have been merged to ease with
linbox/algorithms/rational-solver.inl:792:										     bool randomSolution,
linbox/algorithms/rational-solver.inl:800:		if (makeMinDenomCert && !randomSolution)
linbox/algorithms/rational-solver.inl:939:			if ((appearsInconsistent && level > SL_MONTECARLO) || randomSolution == false) {
linbox/algorithms/rational-solver.inl:1035:			BlasMatrix<Ring> *P = NULL, *B = NULL;   // -- only used in random case
linbox/algorithms/rational-solver.inl:1037:			if (!randomSolution) {
linbox/algorithms/rational-solver.inl:1093:					// compute P a n*r random matrix of entry in [0,1]
linbox/algorithms/rational-solver.inl:1183:			if (!randomSolution) {
linbox/algorithms/rational-solver.inl:1220:					if (randomSolution) {delete P; delete B;}
linbox/algorithms/rational-solver.inl:1236:			if (makeMinDenomCert && level >= SL_LASVEGAS)  // && randomSolution
linbox/algorithms/rational-solver.inl:1355:			if (randomSolution) {delete P;}
linbox/algorithms/rational-solver.inl:1389:		// precondition Ap  with a random diagonal Matrix
linbox/algorithms/rational-solver.inl:1395:				G.random(diag[i]);
linbox/algorithms/rational-solver.inl:1408:		// generate randomly U and V
linbox/algorithms/rational-solver.inl:1413:				G.random(V.refEntry(i,j));
linbox/algorithms/rational-solver.inl:1416:			G.random(U.refEntry(0,i));
linbox/algorithms/rational-solver.inl:1493:			// Choose a nonrandom solution with smallest entries:
linbox/algorithms/blackbox-container-base.h:161:				g.random (u[(size_t)i]);
linbox/algorithms/invariant-factors.h:34:#include "linbox/matrix/random-matrix.h"
linbox/algorithms/invariant-factors.h:94:		RDM.random(U);
linbox/algorithms/invariant-factors.h:95:		RDM.random(V);
linbox/algorithms/invariant-factors.h:118:		RDM.random(U);
linbox/algorithms/invariant-factors.h:119:		RDM.random(V);
linbox/algorithms/invariant-factors.h:271:	void randomNonzero(const Field &F, Element &elm) const {
linbox/algorithms/invariant-factors.h:274:			RI.random(elm);
linbox/algorithms/invariant-factors.h:279:	void randomTriangular(SparseMat &T, size_t s, bool upper, bool randomDiag = false) const {
linbox/algorithms/invariant-factors.h:284:			if (randomDiag) {
linbox/algorithms/invariant-factors.h:286:				randomNonzero(F, elm);
linbox/algorithms/invariant-factors.h:298:				randomNonzero(F, elm);
linbox/algorithms/invariant-factors.h:324:		randomTriangular(L, s, false, false);
linbox/algorithms/invariant-factors.h:325:		randomTriangular(U, s, true, false);
linbox/algorithms/la-block-lanczos.inl:153:		// Fill the remaining columns of _v0 with random data
linbox/algorithms/la-block-lanczos.inl:230:		// Fill y with random data
linbox/algorithms/la-block-lanczos.inl:237:		// Fill v0 with random data
linbox/algorithms/la-block-lanczos.inl:301:		// Fill v0 with random data
linbox/algorithms/la-block-lanczos.inl:390:		// Get a random fat vectors _blockV[0] and _blockU[0]
linbox/algorithms/rational-solver.h:127:	 * -  RandomPrime: generator of random primes
linbox/algorithms/rational-solver.h:138:		 *         giving a random solution if the system is singular and consistent,
linbox/algorithms/rational-solver.h:174:		 *         giving a random solution if the system is singular and consistent.
linbox/algorithms/rational-solver.h:654:		tInvertBP,        ttInvertBP,              //only done in random
linbox/algorithms/rational-solver.h:772:		/** Find a random solution of the general linear system  \c Ax=b over quotient field of a ring.
linbox/algorithms/rational-solver.h:792:		/** Big solving routine to perform random solving and certificate generation.
linbox/algorithms/rational-solver.h:799:		 * @param randomSolution  parameter to determine whether to randomize or not (since solveSingular calls this function as well)
linbox/algorithms/rational-solver.h:804:		 * When <code>(randomSolution == true && makeMinDenomCert == true)</code>,
linbox/algorithms/rational-solver.h:813:						    bool makeMinDenomCert, bool randomSolution,
linbox/algorithms/coppersmith.h:93:			//Pick random entries for U and W. W will become the last c-1 columns of V
linbox/algorithms/coppersmith.h:95:			U.random();
linbox/algorithms/coppersmith.h:96:			W.random();
linbox/algorithms/coppersmith.h:272:			//Pick random entries for U and W. W will become the last c-1 columns of V
linbox/algorithms/coppersmith.h:274:			U.random();
linbox/algorithms/coppersmith.h:275:			V.random();
linbox/algorithms/coppersmith.h:300:					//do iter.random(*evalit); while(field().isZero(*evalit));
linbox/algorithms/coppersmith.h:301:					iter.random(*evalit);
linbox/algorithms/coppersmith.h:410:			//Pick random entries for U and W. W will become the last c-1 columns of V
linbox/algorithms/coppersmith.h:412:			U.random();
linbox/algorithms/coppersmith.h:413:			V.random();
linbox/algorithms/coppersmith.h:439:					do iter.random(*evalit); while(field().isZero(*evalit));
linbox/algorithms/one-invariant-factor.h:31:#include "linbox/blackbox/random-matrix-traits.h"
linbox/algorithms/one-invariant-factor.h:64:		RandomMatrix randomMatrix;
linbox/algorithms/one-invariant-factor.h:75:				   const RandomMatrix& _randomMatrix = RandomMatrix(),
linbox/algorithms/one-invariant-factor.h:77:			r(_r), lif(_lif), compose(_compose), randomMatrix(_randomMatrix),
linbox/algorithms/one-invariant-factor.h:164:				randomMatrix.randomMatrix(U, r, A.rowdim(), A.coldim() - i);
linbox/algorithms/one-invariant-factor.h:166:				randomMatrix.randomMatrix(V, r, A.rowdim() - i, A.coldim());
linbox/algorithms/one-invariant-factor.h:183:				randomMatrix.randomMatrix(L, r, i, (int)A.rowdim());
linbox/algorithms/one-invariant-factor.h:185:				randomMatrix.randomMatrix(R, r, (int)A.coldim(), i);
linbox/algorithms/one-invariant-factor.h:249:				randomMatrix.randomMatrix(L, r, i, (int)A.rowdim());
linbox/algorithms/one-invariant-factor.h:250:				randomMatrix.randomMatrix(R, r, (int)A.coldim(), i);
linbox/algorithms/rational-cra-early-multip.h:79:			//   then only, try a random linear combination.
linbox/algorithms/rational-cra-early-multip.h:98:			//   then only, try a random linear combination.
linbox/algorithms/rational-cra-early-multip.h:111:			//   then only, try a random linear combination.
linbox/algorithms/rational-cra-early-multip.h:122:			//   then only, try a random linear combination.
linbox/algorithms/blackbox-block-container-base.h:237:                G.random(*iter_U);
linbox/algorithms/blackbox-block-container-base.h:241:                G.random(*iter_V);
linbox/algorithms/varprec-cra-early-multip.h:162:			//   then only, try a random linear combination.
linbox/algorithms/varprec-cra-early-multip.h:182:			//   then only, try a random linear combination.
linbox/algorithms/varprec-cra-early-multip.h:201:			//   then only, try a random linear combination.
Binary file linbox/.libs/liblinbox.so.0.0.0 matches
Binary file linbox/.libs/liblinbox.a matches
linbox/blackbox/random-matrix-traits.h:24:#ifndef __LINBOX_random_matrix_traits_H
linbox/blackbox/random-matrix-traits.h:25:#define __LINBOX_random_matrix_traits_H
linbox/blackbox/random-matrix-traits.h:37:#endif // __LINBOX_random_matrix_traits_H
linbox/blackbox/jit-matrix.h:152:	// Example: Generator to create psuedo-random entries
linbox/blackbox/jit-matrix.h:168:			return _r.random(e);
linbox/blackbox/csf.h:42:#include <cstdlib> // For randomness in randomized quicksort
linbox/blackbox/butterfly.inl:598:		{ typename Field::Element a; return CekstvSwitch<Field> (_r.random (a)); }
linbox/blackbox/Makefile:176:	polynomial.h quad-matrix.h random-matrix.h \
linbox/blackbox/Makefile:177:	random-matrix-traits.h rational-matrix-factory.h \
linbox/blackbox/Makefile:440:	random-matrix.h           \
linbox/blackbox/Makefile:441:	random-matrix-traits.h    \
linbox/blackbox/quad-matrix.h:59:	  Right now we implement only side-by-side blocks, which is done to improve cache performance.  This class works especially well on quite sparse matrices whose entries are rather randomly positioned.  The idea is that the vector to be multiplied by each block fits in cache.  It is being more or less randomly accessed, so cache misses are avoided for these random accesses.
linbox/blackbox/diagonal.h:124:		// construct random nonsingular n by n diagonal matrix.
linbox/blackbox/diagonal.h:151:		void random();
linbox/blackbox/diagonal.h:152:		void randomNonsingular();
linbox/blackbox/diagonal.h:336:			Nrow.random();
linbox/blackbox/diagonal.h:349:			Ncol.random();
linbox/blackbox/diagonal.h:575:	 * random Diagonal matrix.
linbox/blackbox/diagonal.h:588:			randomNonsingular();
linbox/blackbox/diagonal.h:590:			random();
linbox/blackbox/diagonal.h:593:	//! random diagonal matrix of size n
linbox/blackbox/diagonal.h:603:			iter.random(*i);
linbox/blackbox/diagonal.h:605:		random();
linbox/blackbox/diagonal.h:608:	/// creates a random Diagonal matrix
linbox/blackbox/diagonal.h:610:	inline void Diagonal<_Field, VectorCategories::DenseVectorTag>::random()
linbox/blackbox/diagonal.h:615:			r.random(*i);
linbox/blackbox/diagonal.h:618:	/// creates a random non singular Diagonal matrix
linbox/blackbox/diagonal.h:620:	inline void Diagonal<_Field, VectorCategories::DenseVectorTag>::randomNonsingular()
linbox/blackbox/diagonal.h:625:			while (field().isZero(r.random(*i))) ;
linbox/blackbox/zo.h:48:#include <cstdlib> // For randomness in randomized quicksort
linbox/blackbox/Makefile.am:61:	random-matrix.h           \
linbox/blackbox/Makefile.am:62:	random-matrix-traits.h    \
linbox/blackbox/random-matrix.h:27:#ifndef __LINBOX_blackbox_random_matrix_H
linbox/blackbox/random-matrix.h:28:#define __LINBOX_blackbox_random_matrix_H
linbox/blackbox/random-matrix.h:40:		/** Generates random matrices used in EGV and EGV+ algorithm.
linbox/blackbox/random-matrix.h:42:		 * [I, R] or [I, R]^t, where R is a random matrix.
linbox/blackbox/random-matrix.h:46:		static Blackbox*& randomMatrix (Blackbox* &, const Field& f,
linbox/blackbox/random-matrix.h:50:		// constructor a random dense matrix, whose entries are random
linbox/blackbox/random-matrix.h:52:		static BlasMatrix<Field>*& randomMatrix( BlasMatrix<Field>*& Ap,
linbox/blackbox/random-matrix.h:86:		// constructor a very special random sparse matrix
linbox/blackbox/random-matrix.h:87:		// [I, R] or [I, R]^t, where R is a sparse random matrix.
linbox/blackbox/random-matrix.h:89:		static SparseMatrix<Field>*& randomMatrix( SparseMatrix<Field>*& Ap,
linbox/blackbox/random-matrix.h:160:#endif //__LINBOX_blabbox_random_matrix_H
linbox/blackbox/apply.h:43:#include "linbox/randiter/multimod-randomprime.h"
linbox/blackbox/fibb.h:45:		Note that Y+Z is a random sample of the solution space after
linbox/blackbox/fibb.h:56:	/// N: AN = 0, each col random.
linbox/blackbox/fibb.h:59:	/// N: NA = 0, each row random.
linbox/blackbox/fibb.h:78:/// N: AN = 0, each col random.
linbox/blackbox/fibb.h:86:	Matrix X(Xb); X.random();
linbox/blackbox/fibb.h:94:/// N: NA = 0, each row random.
linbox/blackbox/fibb.h:102:	Matrix X(Xb); X.random();
linbox/blackbox/triangular-fibb.h:62:		void random() { rep_->random(); }
linbox/blackbox/triangular-fibb.h:64:		void random(size_t n)
linbox/blackbox/triangular-fibb.h:71:				size_t j = i + r.randomInt()%(n-i);
linbox/blackbox/frobenius.h:49:		 *    specified by vlist, generated from random polynomials
linbox/blackbox/zero-one.h:43:#include <cstdlib> // For randomness in randomized quicksort
linbox/blackbox/Makefile.in:176:	polynomial.h quad-matrix.h random-matrix.h \
linbox/blackbox/Makefile.in:177:	random-matrix-traits.h rational-matrix-factory.h \
linbox/blackbox/Makefile.in:440:	random-matrix.h           \
linbox/blackbox/Makefile.in:441:	random-matrix-traits.h    \
linbox/blackbox/companion.h:67:		 * \brief This constructs a random companion matrix.
linbox/blackbox/companion.h:69:		 * Builds n by n matrix from degree n monic poly with other coefficients random.
linbox/blackbox/companion.h:79:				r.random(*i); // we'll pretend p[n] == 1, ok?
linbox/blackbox/companion.h:91:		 * \brief This constructs a random companion matrix.
linbox/blackbox/companion.h:93:		 * Builds n by n matrix from degree n monic poly with other coefficients random.
linbox/blackbox/companion.h:103:				r.random(*i); // we'll pretend p[n] == 1, ok?
linbox/blackbox/butterfly.h:115:		 * than the elements themselves.  This includes any random
linbox/blackbox/butterfly.h:118:		 * to create new random elements or repeat a stored sequence
linbox/blackbox/fibb-product.h:57:	/// N: AN = 0, each col random.
linbox/blackbox/fibb-product.h:59:	/// N: NA = 0, each row random.
linbox/blackbox/fibb-product.h:243:	R.random();
linbox/blackbox/fibb-product.h:253:	R.random();
linbox/blackbox/scalar-matrix.h:129:		/** Constructor from a random element.
linbox/blackbox/scalar-matrix.h:136:		{ iter.random(v_); }
linbox/blackbox/permutation.h:113:		//void random(size_t n)
linbox/blackbox/permutation.h:114:		void random(unsigned int seed=(unsigned int)time(NULL))
linbox/blackbox/permutation.h:121:				size_t j = i + r.randomInt()%(n-i);
linbox/blackbox/blackbox.doxy:50:  functionality to generate random instances of the class.
linbox/vector/slicedpolynomialvector/SlicedPolynomialVector.h:50:		/*! Allocates a vector of new zero vectors of size 0 (shaped and ready). Irreducible polynomial is chosen randomly.
linbox/vector/slicedpolynomialvector/SlicedPolynomialVector.h:54:		/*Allocates a vector of new vectors of size m (shaped and ready). Irreducible polynomial is chosen randomly.
linbox/vector/random.h:33:#ifndef __LINBOX_vector_random_H
linbox/vector/random.h:34:#define __LINBOX_vector_random_H
linbox/vector/random.h:44:	 * This templated function takes a field and a random field element
linbox/vector/random.h:45:	 * generator and returns a vector of random field elements.
linbox/vector/random.h:55:	 * @return	v	vector of random field elements
linbox/vector/random.h:64:	randomVector(Field& F, size_t n, typename Field::RandIter& r)
linbox/vector/random.h:67:		randomVector<Field, Vector>(
linbox/vector/random.h:76:	 * This templated function takes a field and a random field element
linbox/vector/random.h:77:	 * generator and returns a vector of random field elements.
linbox/vector/random.h:81:	 * @return	v	vector of random field elements
linbox/vector/random.h:90:	randomVector(
linbox/vector/random.h:98:		cout << "Called dense random vector" << endl;
linbox/vector/random.h:105:			r.random(*iter);
linbox/vector/random.h:109:	} // randomVector(F, r, VectorCategories::DenseVectorTag& tag)
linbox/vector/random.h:112:	 * This templated function takes a field and a random field element
linbox/vector/random.h:113:	 * generator and returns a vector of random field elements.
linbox/vector/random.h:117:	 * @return	v	vector of random field elements
linbox/vector/random.h:126:	randomVector(
linbox/vector/random.h:134:		cout << "Called sparse sequence random vector" << endl
linbox/vector/random.h:144:			r.random(iter->second);
linbox/vector/random.h:154:	} // randomVector(F, r, VectorCategories::SparseSequenceVectorTag& tag)
linbox/vector/random.h:157:	 * This templated function takes a field and a random field element
linbox/vector/random.h:158:	 * generator and returns a vector of random field elements.
linbox/vector/random.h:162:	 * @return	v	vector of random field elements
linbox/vector/random.h:171:	randomVector(
linbox/vector/random.h:179:		cout << "Called sparse associative random vector" << endl
linbox/vector/random.h:188:			r.random(temp);
linbox/vector/random.h:199:	} // randomVector(F, r, VectorCategories::SparseAssociativeVectorTag& tag)
linbox/vector/random.h:203:#endif // __LINBOX_vector_random_H
linbox/vector/vector-domain.h:163:VD.random<V>(v)
linbox/vector/vector-domain.h:544:		 * @param v vector to be randomized.
linbox/vector/vector-domain.h:547:		Vector& random(Vector& v)
linbox/vector/vector-domain.h:552:			for (iterator p = v.begin(); p != v.end(); ++p) r.random(*p);
linbox/vector/Makefile:400:	random.h                \
linbox/vector/blas-vector.h:502:		void random()
linbox/vector/blas-vector.h:507:				setEntry(i, r.random(x));
linbox/vector/blas-vector.h:511:		void random( RandIter r)
linbox/vector/blas-vector.h:515:				setEntry(i, r.random(x));
linbox/vector/Makefile.am:36:	random.h                \
linbox/vector/stream-gf2.h:20: *    allows, e.g. construction of a random dense vector in sparse
linbox/vector/stream-gf2.h:66: * @brief Generation of sequences of random vectors.
linbox/vector/stream-gf2.h:98:				*i = MTrandomInt<__LINBOX_BITSOF_LONG>()(MT);
linbox/vector/stream-gf2.h:184:			val = (double) MT.randomDouble ();
linbox/vector/bit-vector.inl:45:		typedef random_access_iterator_tag iterator_category;
linbox/vector/bit-vector.inl:55:		typedef random_access_iterator_tag iterator_category;
linbox/vector/bit-vector.inl:203:	// class BitVector::iterator : public std::iterator <std::random_access_iterator_tag, bool>
linbox/vector/bit-vector.inl:342:	class BitVector::const_iterator : public std::iterator <std::random_access_iterator_tag, bool> {
linbox/vector/Makefile.in:400:	random.h                \
linbox/vector/subvector.h:48:	 * random access container (such as std::vector, deque).
linbox/vector/subiterator.h:43:	 *  Subiter<Iterator> requires that Iterator be a random access iterator class
linbox/vector/subiterator.h:44:	 *  and then itself provides the full functionality of a random access iterator
linbox/vector/stream.h:20: *    allows, e.g. construction of a random dense vector in sparse
linbox/vector/stream.h:66: * @brief Generation of sequences of random vectors.
linbox/vector/stream.h:91:	 * might be run on a sequence of random vectors or on e_1, ..., e_n.
linbox/vector/stream.h:224:	 * Generates a sequence of random dense vectors over a given field
linbox/vector/stream.h:236:		 * @param F Field over which to create random vectors
linbox/vector/stream.h:244:		 * @param v Vector into which to generate random vector
linbox/vector/stream.h:245:		 * @return reference to new random vector
linbox/vector/stream.h:274:	//! Specialization of random dense stream for dense vectors
linbox/vector/stream.h:293:				_r.random (*i);
linbox/vector/stream.h:323:	 * Generates a sequence of random sparse vectors over a given field
linbox/vector/stream.h:333:		 * @param F Field over which to create random vectors
linbox/vector/stream.h:343:		 * @param v Vector into which to generate random vector
linbox/vector/stream.h:344:		 * @return reference to new random vector
linbox/vector/stream.h:399:				val = MT.randomDouble ();
linbox/vector/stream.h:402:					_r.random (*i);
linbox/vector/stream.h:466:				val = MT.randomDouble ();
linbox/vector/stream.h:476:				_r.random (x);
linbox/vector/stream.h:537:				_r.random (x);
linbox/vector/stream.h:538:				while (!_field.isZero (v[idx = MT.randomIntRange (0, (uint32_t)_n)])) ;
linbox/vector/stream.h:595:				val = MT.randomDouble ();
linbox/vector/stream.h:605:				_r.random (x);
linbox/randiter/random-fftprime.h:26:#ifndef __LINBOX_random_fftprime_H
linbox/randiter/random-fftprime.h:27:#define __LINBOX_random_fftprime_H
linbox/randiter/random-fftprime.h:54:		/** @brief randomPrime(size_t b)
linbox/randiter/random-fftprime.h:55:		 *  return a random FFT prime with a 2-valuation larger than b in its order
linbox/randiter/random-fftprime.h:56:				 *  the randomness is on the FFT primes lying in the given range
linbox/randiter/random-fftprime.h:59:		inline Prime_Type randomPrime (size_t b) const
linbox/randiter/random-fftprime.h:62:			randomPrime(tmp,b);
linbox/randiter/random-fftprime.h:66:		/** @brief randomPrime(Prime_Type& p, size_t b)
linbox/randiter/random-fftprime.h:67:		 *  return a random FFT prime with a 2-valuation larger than b in its order
linbox/randiter/random-fftprime.h:68:				 *  the randomness is on the FFT primes lying in the given range
linbox/randiter/random-fftprime.h:71:		inline Prime_Type randomPrime (Prime_Type& t, uint64_t b) const
linbox/randiter/random-fftprime.h:80:					integer::random(t,cbits);
linbox/randiter/random-fftprime.h:111:					integer::random(t,cbits);
linbox/randiter/random-fftprime.h:230:		 *  Set the random seed to be ul.
linbox/randiter/random-fftprime.h:239:#endif //__LINBOX_random_fftprime_H
linbox/randiter/generic.h:20: * Seeded random number generator in constructor.  _seed was never used
linbox/randiter/generic.h:47: * @brief Genric random iterator.
linbox/randiter/generic.h:69:	 * This is a generator of random field elements that can be used with
linbox/randiter/generic.h:82:		 * The random field element iterator works in the field F, is seeded
linbox/randiter/generic.h:90:		 * @param seed constant integer reference from which to seed random number
linbox/randiter/generic.h:110:			<< "Created random generator with size " << _size
linbox/randiter/generic.h:113:			// Seed random number generator
linbox/randiter/generic.h:134:		 * This returns a random field element from the information supplied
linbox/randiter/generic.h:137:		 * @return reference to random field element
linbox/randiter/generic.h:139:		Element &random (Element &a) const
linbox/randiter/generic.h:143:		 * This returns a random field element from the information supplied
linbox/randiter/generic.h:146:		 * @return reference to random field element
linbox/randiter/generic.h:148:		ElementAbstract &random (ElementAbstract &a) const
linbox/randiter/generic.h:152:			random (tmp);
linbox/randiter/Makefile:201:	modular-crooked.h gf2.h mersenne-twister.h random-prime.h \
linbox/randiter/Makefile:202:	gmp-random-prime.h random-fftprime.h multimod-randomprime.h \
linbox/randiter/Makefile:440:    random-prime.h      \
linbox/randiter/Makefile:441:    gmp-random-prime.h  \
linbox/randiter/Makefile:442:    random-fftprime.h   \
linbox/randiter/Makefile:443:    multimod-randomprime.h
linbox/randiter/mersenne-twister.C:35: * Implementation of the Mersenne twister pseudo-random number generator,
linbox/randiter/mersenne-twister.C:40: * This forms the basic underlying algorithm for most psuedo-random number
linbox/randiter/mersenne-twister.C:101:	uint32_t MersenneTwister::randomInt ()
linbox/randiter/mersenne-twister.C:118:	double MersenneTwister::randomDouble ()
linbox/randiter/mersenne-twister.C:124:			   32. Thats why we need two calls to randomInt */
linbox/randiter/mersenne-twister.C:125:			retval = randomInt () * doubleTransform;
linbox/randiter/mersenne-twister.C:126:			retval = (retval + randomInt ()) * doubleTransform;
linbox/randiter/mersenne-twister.C:135:	uint32_t MersenneTwister::randomIntRange (uint32_t start, uint32_t end)
linbox/randiter/mersenne-twister.C:140:		uint32_t random;
linbox/randiter/mersenne-twister.C:157:			randomInt () * (doubleTransform + doubleTransform * doubleTransform);
linbox/randiter/mersenne-twister.C:159:			random = (uint32_t) (double_rand * dist);
linbox/randiter/mersenne-twister.C:165:			random = (uint32_t) randomDoubleRange (0, dist);
linbox/randiter/mersenne-twister.C:168:		return start + random;
linbox/randiter/mersenne-twister.C:212:		// Note that the random number user does not see the values generated
Binary file linbox/randiter/mersenne-twister.o matches
linbox/randiter/gmp-rational.h:28: * @brief Generate a random rational with prescribed size.
linbox/randiter/gmp-rational.h:52:		/*! Rational number random iterator.
linbox/randiter/gmp-rational.h:58:		 * @param seed seed for random generator. By default it is 0
linbox/randiter/gmp-rational.h:96:		/*! get a random number.
linbox/randiter/gmp-rational.h:97:		 * @param[out] a a random rational.
linbox/randiter/gmp-rational.h:99:		Element &random (Element &a)  const
linbox/randiter/gmp-rational.h:149:		 * This returns a random field element from the information supplied
linbox/randiter/gmp-rational.h:152:		 * @param[out] a random field element.
linbox/randiter/gmp-rational.h:153:		 * @return reference to random field element \p a.
linbox/randiter/gmp-rational.h:155:		ElementAbstract &random (ElementAbstract &a)  const
linbox/randiter/gmp-rational.h:159:			random (tmp);
linbox/randiter/gmp-rational.h:177:#endif // __LINBOX_randiter_gmp_random_H
linbox/randiter/envelope.h:39:	 * This encapsulated class is a generator of random field base elements for
linbox/randiter/envelope.h:43:	 * draw the random elements from, and the second being a seed for the
linbox/randiter/envelope.h:44:	 * random number generator.
linbox/randiter/envelope.h:47:	 * operator(), the random element is placed into the input field base element
linbox/randiter/envelope.h:59:		 * The random field element iterator works in the field F, is seeded
linbox/randiter/envelope.h:67:		 * @param seed constant integer reference from which to seed random number
linbox/randiter/envelope.h:76:		/** Constructor from random field element generator to be wrapped
linbox/randiter/envelope.h:77:		 * @param R random field element generator object to be wrapped
linbox/randiter/envelope.h:84:		 * Constructs RandIterEnvelope object by copying the random field
linbox/randiter/envelope.h:96:		 * This destructs the random field element generator object.
linbox/randiter/envelope.h:116:		 * The random field element iterator works in the field F, is seeded
linbox/randiter/envelope.h:125:		 * @param seed constant integer reference from which to seed random number
linbox/randiter/envelope.h:145:		 * This returns a random field element from the information supplied
linbox/randiter/envelope.h:148:		 * @return reference to random field element
linbox/randiter/envelope.h:150:		ElementAbstract &random (ElementAbstract &a)
linbox/randiter/envelope.h:151:		//{ return  _randIter.random (a); }
linbox/randiter/envelope.h:155:			_randIter.random(static_cast<ElementEnvelope<Field>&> (a)._elem );
linbox/randiter/abstract.h:40:	 * This encapsulated class is a generator of random field elements for
linbox/randiter/abstract.h:44:	 * draw the random elements from, and the second being a seed for the
linbox/randiter/abstract.h:45:	 * random number generator.
linbox/randiter/abstract.h:47:	 * random() which acts on a reference to a field element.
linbox/randiter/abstract.h:48:	 * The random value is written to the argument
linbox/randiter/abstract.h:50:	 * @see \subpage randomFEGW Randiter Field Element Generator wrapper
linbox/randiter/abstract.h:60:		 * The random field element iterator works in the field F, is seeded
linbox/randiter/abstract.h:69:		 * @param seed constant integer reference from which to seed random number
linbox/randiter/abstract.h:99:		virtual Element &random (Element &a) = 0;
linbox/randiter/Makefile.am:39:    random-prime.h      \
linbox/randiter/Makefile.am:40:    gmp-random-prime.h  \
linbox/randiter/Makefile.am:41:    random-fftprime.h   \
linbox/randiter/Makefile.am:42:    multimod-randomprime.h
Binary file linbox/randiter/.libs/mersenne-twister.o matches
Binary file linbox/randiter/.libs/libranditer.a matches
linbox/randiter/ntl-zz.h:52:		Element& random (Element& x) const
linbox/randiter/gmp-random-prime.h:25:#ifndef __LINBOX_gmp_random_prime_H
linbox/randiter/gmp-random-prime.h:26:#define __LINBOX_gmp_random_prime_H
linbox/randiter/gmp-random-prime.h:32:	/** \brief generating random prime integers, using the gmp library.
linbox/randiter/gmp-random-prime.h:34:	 * Similar to random-prime.h, but return type is integer, not long, allowing
linbox/randiter/gmp-random-prime.h:45:		/** Create a new random prime generator.  Primes generated will
linbox/randiter/gmp-random-prime.h:52:		inline integer randomPrime() const
linbox/randiter/gmp-random-prime.h:55:			do test=test-1;//integer::nonzerorandom( test, max );
linbox/randiter/gmp-random-prime.h:61:		inline integer& randomPrime( integer& p )
linbox/randiter/gmp-random-prime.h:63:			do integer::nonzerorandom( p, max );
linbox/randiter/gmp-random-prime.h:71:#endif //__LINBOX_gmp_random_prime_H
linbox/randiter/archetype.doxy:23:/*! \page randomIGA Random Iterator Generator Archetype
linbox/randiter/archetype.doxy:25:  The \ref LinBox random iterator generator archetype defines the random
linbox/randiter/archetype.doxy:31:        \ref randomIGA common object interface.
linbox/randiter/lidia-gfq.h:67:			cout << "created random generator with size " << _size
linbox/randiter/lidia-gfq.h:71:			// Seed random number generator
linbox/randiter/lidia-gfq.h:100:		Element& random (Element& x)  const
linbox/randiter/lidia-gfq.h:104:				e.randomize();
linbox/randiter/lidia-gfq.h:106:				e.randomize(_size);
linbox/randiter/param-fuzzy.h:85:		Element &random (Element &a)  const
linbox/randiter/param-fuzzy.h:87:			// Create new random elements
linbox/randiter/param-fuzzy.h:94:		ElementAbstract &random (ElementAbstract &a) const
linbox/randiter/param-fuzzy.h:98:			random (tmp);
linbox/randiter/archetype.h:48:	 * This encapsulated class is a generator of random field elements for
linbox/randiter/archetype.h:52:	 * draw the random elements from, and the second being a seed for the
linbox/randiter/archetype.h:53:	 * random number generator.
linbox/randiter/archetype.h:56:	 * operator (), the random element is placed into the input field element
linbox/randiter/archetype.h:71:		 * The random field element iterator works in the
linbox/randiter/archetype.h:81:		 * which <code>F._elem_ptr</code> points, and the random
linbox/randiter/archetype.h:87:		 * @param seed constant integer reference from which to seed random number
linbox/randiter/archetype.h:96:		 * Constructs RandIterArchetype object by copying the random field
linbox/randiter/archetype.h:100:		 * In this implementation, this means copying the random field element
linbox/randiter/archetype.h:111:		 * encapsulated element and random element generator if needed.
linbox/randiter/archetype.h:126:		 * This destructs the random field element generator
linbox/randiter/archetype.h:128:		 * generator by deleting the random generator object
linbox/randiter/archetype.h:152:		 * This returns a random field element from the information supplied
linbox/randiter/archetype.h:154:		 * @return reference to random field element
linbox/randiter/archetype.h:156:		Element &random (Element &a) const
linbox/randiter/archetype.h:158:			_randIter_ptr->random (*a._elem_ptr);
linbox/randiter/archetype.h:166:		 * LinBox random field element generators
linbox/randiter/archetype.h:174:		 * Creates new copies of random iterator generator object in dynamic memory.
linbox/randiter/modular-balanced.h:19: * Seeded random number generator in constructor.  _seed was never used
linbox/randiter/modular-balanced.h:70:	 * This encapsulated class is a generator of random field base elements for
linbox/randiter/modular-balanced.h:74:	 * draw the random elements from, and the second being a seed for the
linbox/randiter/modular-balanced.h:75:	 * random number generator.
linbox/randiter/modular-balanced.h:78:	 * operator (), the random element is placed into the input field base element
linbox/randiter/modular-balanced.h:86:		 * The random field element iterator works in the field F, is seeded
linbox/randiter/modular-balanced.h:95:		 * @param seed constant integer reference from which to seed random number
linbox/randiter/modular-balanced.h:113:			<< "Created random generator with size " << _size
linbox/randiter/modular-balanced.h:116:			// Seed random number generator
linbox/randiter/modular-balanced.h:121:		 * Constructs Givaro::ModularBalancedRandIter object by copying the random field
linbox/randiter/modular-balanced.h:132:		 * This destructs the random field element generator object.
linbox/randiter/modular-balanced.h:152:		 * This returns a random field element from the information supplied
linbox/randiter/modular-balanced.h:155:		 * @return reference to random field element
linbox/randiter/modular-balanced.h:157:		Element &random (Element &a) const
linbox/randiter/modular-balanced.h:162:		 * This returns a random field element from the information supplied
linbox/randiter/modular-balanced.h:165:		 * @return reference to random field element
linbox/randiter/modular-balanced.h:167:		ElementAbstract &random (ElementAbstract &a) const
linbox/randiter/modular-balanced.h:171:			random (tmp);
linbox/randiter/Makefile.in:201:	modular-crooked.h gf2.h mersenne-twister.h random-prime.h \
linbox/randiter/Makefile.in:202:	gmp-random-prime.h random-fftprime.h multimod-randomprime.h \
linbox/randiter/Makefile.in:440:    random-prime.h      \
linbox/randiter/Makefile.in:441:    gmp-random-prime.h  \
linbox/randiter/Makefile.in:442:    random-fftprime.h   \
linbox/randiter/Makefile.in:443:    multimod-randomprime.h
linbox/randiter/randiter.doxy:27:  All LinBox random iterator generators must implement the random iterator
linbox/randiter/randiter.doxy:28:  generator common object interface as it is defined in the random iterator
linbox/randiter/randiter.doxy:30:  consists of the methods required of all LinBox random iterator generators.
linbox/randiter/gf2.h:53:		 * The random field element iterator works in the field F, is seeded
linbox/randiter/gf2.h:62:		 * @param seed constant integer reference from which to seed random number
linbox/randiter/gf2.h:79:		 * This destructs the random field element generator object.
linbox/randiter/gf2.h:91:		 * This returns a random field element from the information supplied
linbox/randiter/gf2.h:94:		 * @return reference to random field element
linbox/randiter/gf2.h:96:		bool &random (bool &a)  const
linbox/randiter/gf2.h:98:			return a = MT.randomIntRange (0, 2);
linbox/randiter/gf2.h:102:		 * This returns a random field element from the information supplied
linbox/randiter/gf2.h:105:		 * @return reference to random field element
linbox/randiter/gf2.h:107:		BitVector::reference random (BitVector::reference a)  const
linbox/randiter/gf2.h:108:		{ return a = MT.randomIntRange (0, 2); }
linbox/randiter/gf2.h:112:		 * This returns a random field element from the information supplied
linbox/randiter/gf2.h:115:		 * @return reference to random field element
linbox/randiter/gf2.h:117:		stdBitReference random (stdBitReference a)  const
linbox/randiter/gf2.h:118:		{ return a = MT.randomIntRange (0, 2); }
linbox/randiter/gf2.h:121:		 * This returns a random field element from the information supplied
linbox/randiter/gf2.h:124:		 * @return reference to random field element
linbox/randiter/gf2.h:126:		ElementAbstract &random (ElementAbstract &a)  const
linbox/randiter/gf2.h:130:			random (tmp);
linbox/randiter/gf2.h:135:		uint32_t& random (uint32_t& a)  const
linbox/randiter/gf2.h:136:		{ return a = MT.randomInt(); }
linbox/randiter/gf2.h:153:	struct MTrandomInt {
linbox/randiter/gf2.h:157:			return MT.randomInt();
linbox/randiter/gf2.h:162:	struct MTrandomInt<64> {
linbox/randiter/gf2.h:166:			uint64_t tmp = MT.randomInt();
linbox/randiter/gf2.h:168:			return tmp += MT.randomInt();
linbox/randiter/modular-crooked.h:49:	 * This encapsulated class is a generator of random field base elements for
linbox/randiter/modular-crooked.h:53:	 * draw the random elements from, and the second being a seed for the
linbox/randiter/modular-crooked.h:54:	 * random number generator.
linbox/randiter/modular-crooked.h:57:	 * operator (), the random element is placed into the input field base element
linbox/randiter/modular-crooked.h:65:		 * The random field element iterator works in the field F, is seeded
linbox/randiter/modular-crooked.h:74:		 * @param seed constant integer reference from which to seed random number
linbox/randiter/modular-crooked.h:92:			<< "Created random generator with size " << _size
linbox/randiter/modular-crooked.h:95:			// Seed random number generator
linbox/randiter/modular-crooked.h:100:		 * Constructs ModularCrookedRandIter object by copying the random field
linbox/randiter/modular-crooked.h:111:		 * This destructs the random field element generator object.
linbox/randiter/modular-crooked.h:131:		 * This returns a random field element from the information supplied
linbox/randiter/modular-crooked.h:134:		 * @return reference to random field element
linbox/randiter/modular-crooked.h:136:		Element &random (Element &a) const
linbox/randiter/modular-crooked.h:140:		 * This returns a random field element from the information supplied
linbox/randiter/modular-crooked.h:143:		 * @return reference to random field element
linbox/randiter/modular-crooked.h:145:		ElementAbstract &random (ElementAbstract &a) const
linbox/randiter/modular-crooked.h:149:			random (tmp);
linbox/randiter/randiter-wrappers.doxy:23:/** \page randomFEGW Random field element generator wrappers
linbox/randiter/randiter-wrappers.doxy:28:  @brief Wrappers to make \ref LinBox random field element generators.
linbox/randiter/random-prime.h:27:/*! @file randiter/random-prime.h
linbox/randiter/random-prime.h:29: * @brief Generates random positive prime \ref integers.
linbox/randiter/random-prime.h:32:#ifndef __LINBOX_random_prime_iterator_H
linbox/randiter/random-prime.h:33:#define __LINBOX_random_prime_iterator_H
linbox/randiter/random-prime.h:50:            //! Iterator sampling randomly (no distribution guaranteed whatsoever) from all primes of given bitsize
linbox/randiter/random-prime.h:70:         * Generates prime of specified length using a heuristically random distribution 
linbox/randiter/random-prime.h:106:             *  creates a new random prime.
linbox/randiter/random-prime.h:114:            /** @brief get the random prime.
linbox/randiter/random-prime.h:121:             *  Set the random seed to be \p ul.
linbox/randiter/random-prime.h:140:        integer::random_exact_2exp(_prime,_bits);
linbox/randiter/random-prime.h:154:            integer::random_exact_2exp(_prime,_bits);
linbox/randiter/random-prime.h:276:        integer::random_exact_2exp(_prime,_bits);
linbox/randiter/random-prime.h:298:            integer::random_exact_2exp(_prime,_bits);
linbox/randiter/random-prime.h:314:#endif //__LINBOX_random_prime_iterator_H
linbox/randiter/mersenne-twister.h:28: * Header file for implementation of the Mersenne twister pseudo-random number
linbox/randiter/mersenne-twister.h:33: * This forms the basic underlying algorithm for most psuedo-random number
linbox/randiter/mersenne-twister.h:36: * N.B. This module is tested in test-modular under the random number
linbox/randiter/mersenne-twister.h:65:		// random in [0..2^32) ?
linbox/randiter/mersenne-twister.h:66:		uint32_t randomInt ();
linbox/randiter/mersenne-twister.h:67:		uint32_t randomInt () const
linbox/randiter/mersenne-twister.h:68:		{ return const_cast<MersenneTwister&>(*this).randomInt();}
linbox/randiter/mersenne-twister.h:70:		// random in [start..end).
linbox/randiter/mersenne-twister.h:71:		uint32_t randomIntRange (uint32_t start, uint32_t end);
linbox/randiter/mersenne-twister.h:72:		uint32_t randomIntRange (uint32_t start, uint32_t end) const
linbox/randiter/mersenne-twister.h:73:		{ return const_cast<MersenneTwister&>(*this).randomIntRange(start,end); }
linbox/randiter/mersenne-twister.h:75:		// random in [0..1] in some sense ?
linbox/randiter/mersenne-twister.h:76:		double randomDouble ();
linbox/randiter/mersenne-twister.h:77:		double randomDouble ()  const
linbox/randiter/mersenne-twister.h:78:		{ return const_cast<MersenneTwister&>(*this).randomDouble(); }
linbox/randiter/mersenne-twister.h:80:		// random in [start..end] in some sense ?
linbox/randiter/mersenne-twister.h:81:		double randomDoubleRange (double start, double end)
linbox/randiter/mersenne-twister.h:82:		{ return randomDouble () * (end - start) + start; }
linbox/randiter/mersenne-twister.h:83:		double randomDoubleRange (double start, double end) const
linbox/randiter/mersenne-twister.h:84:		{ return const_cast<MersenneTwister&>(*this).randomDoubleRange(start,end); }
linbox/randiter/multimod-randomprime.h:1:/* linbox/randiter/multimod-randomprime.h
linbox/randiter/multimod-randomprime.h:30:#ifndef __LINBOX_multimod_random_prime_H
linbox/randiter/multimod-randomprime.h:31:#define __LINBOX_multimod_random_prime_H
linbox/randiter/multimod-randomprime.h:64:		/** \c randomPrime().
linbox/randiter/multimod-randomprime.h:65:		 *  return a vector of random prime
linbox/randiter/multimod-randomprime.h:67:		inline Prime_Type randomPrime() const
linbox/randiter/multimod-randomprime.h:74:					integer::random(tmp[i],_bits-1);
linbox/randiter/multimod-randomprime.h:83:		/** @c randomPrime(Prime_Type& p).
linbox/randiter/multimod-randomprime.h:84:		 *  return a random prime
linbox/randiter/multimod-randomprime.h:86:		inline Prime_Type randomPrime (Prime_Type& p) const
linbox/randiter/multimod-randomprime.h:91:					integer::random(p[i],_bits-1);
linbox/randiter/multimod-randomprime.h:102:		 *  Set the random seed to be ul.
linbox/randiter/multimod-randomprime.h:129:#endif //__LINBOX_multimod_random_prime_H
linbox/matrix/plain-matrix.h:33:	 * (exceptions are some use of domain scalars in, eg., zero(), random(), setEntry(), getEntry().
linbox/matrix/plain-matrix.h:117:		Self_t& random() // set to random entries, no shape change
linbox/matrix/plain-matrix.h:122:					setEntry(i, j, r.random(x));
linbox/matrix/plain-matrix.h:199:		using Father_t::random;
linbox/matrix/random-matrix.inl:25:#ifndef __LINBOX_matrix_random_matrix_INL
linbox/matrix/random-matrix.inl:26:#define __LINBOX_matrix_random_matrix_INL
linbox/matrix/random-matrix.inl:27:/** @file matrix/random-matrix.inl
linbox/matrix/random-matrix.inl:29: * @brief Implementation of random matrices.
linbox/matrix/random-matrix.inl:41:		random_lu_rank(const Field			& F,
linbox/matrix/random-matrix.inl:72:			// be ready for random elements
linbox/matrix/random-matrix.inl:75:			/* Create L a random invertible lower unit triangular matrix (m x m format) */
linbox/matrix/random-matrix.inl:78:					R.random( L.refEntry( i,j ) );
linbox/matrix/random-matrix.inl:81:				Rnz.random( L.refEntry( i,i ) ); // non zero diagonal
linbox/matrix/random-matrix.inl:89:			/* Create U a random rank-r upper non-unit triangular matrix (m x n format) */
linbox/matrix/random-matrix.inl:92:					R.random( U.refEntry( i,j ) ); // r random 'triangular' lines
linbox/matrix/random-matrix.inl:94:				Rnz.random( U.refEntry( i,i ) ); // non zero diagonal on rank first lines
linbox/matrix/random-matrix.inl:136:		random_lu_rank(const Ring          & ZZ,
linbox/matrix/random-matrix.inl:160:			// be ready for random elements
linbox/matrix/random-matrix.inl:167:			/* Create L a random invertible lower unit triangular matrix (m x m format) */
linbox/matrix/random-matrix.inl:170:					S_.random( L.refEntry( i,j ) );
linbox/matrix/random-matrix.inl:173:				U_.random( L.refEntry( i,i ) ); // non zero diagonal
linbox/matrix/random-matrix.inl:181:			/* Create U a random rank-r upper non-unit triangular matrix (m x n format) */
linbox/matrix/random-matrix.inl:184:					T_.random( U.refEntry( i,j ) ); // r random 'triangular' lines
linbox/matrix/random-matrix.inl:186:				U_.random( U.refEntry( i,i ) ); // non zero diagonal on rank first lines
linbox/matrix/random-matrix.inl:218:		random_lu_rank(const Field			   & F,
linbox/matrix/random-matrix.inl:225:			random_lu_rank(F,R,Alink,rank,RingCategories::IntegerTag());
linbox/matrix/random-matrix.inl:233:		random_rankupdate( const Field        & F
linbox/matrix/random-matrix.inl:246:			RandMatGen.random(D) ;
linbox/matrix/random-matrix.inl:247:			RandMatGen.random(G) ;
linbox/matrix/random-matrix.inl:255:		random_rankupdate( Givaro::ZRing<Integer>               & F //!@bug const !
linbox/matrix/random-matrix.inl:261:			//! @todo check randomness
linbox/matrix/random-matrix.inl:270:			RandMatGen.random(D) ;
linbox/matrix/random-matrix.inl:273:			RandMatGen.random(G) ;
linbox/matrix/random-matrix.inl:282:		random_rankupdate( Field                & F //!@bug const !
linbox/matrix/random-matrix.inl:297:			RandMatGen.random(D) ;
linbox/matrix/random-matrix.inl:300:			RandMatGen.random(G) ;
linbox/matrix/random-matrix.inl:329:	RandomDenseMatrix<Randiter, Field>::random( Matrix & A)
linbox/matrix/random-matrix.inl:334:				R_.random(d);
linbox/matrix/random-matrix.inl:343:	RandomDenseMatrix<Randiter, Field>::randomFullRank(Matrix &A)
linbox/matrix/random-matrix.inl:350:			random(A);
linbox/matrix/random-matrix.inl:360:	RandomDenseMatrix<Randiter, Field>::randomRank(Matrix & A,
linbox/matrix/random-matrix.inl:372:	RandomDenseMatrix<Randiter, Field>::randomRank(
linbox/matrix/random-matrix.inl:378:		return randomRank(A,rank,RankBuilder::LU_());
linbox/matrix/random-matrix.inl:384:	RandomDenseMatrix<Randiter, Field>::randomRank(
linbox/matrix/random-matrix.inl:390:		Protected::random_lu_rank( F_,R_,A,rank,
linbox/matrix/random-matrix.inl:400:	RandomDenseMatrix<Randiter, Field>::randomRank(
linbox/matrix/random-matrix.inl:406:		return Protected::random_rankupdate(F_,R_,A,rank,
linbox/matrix/random-matrix.inl:410:	/*  dense matrix with random entries */
linbox/matrix/random-matrix.inl:427:#endif // __LINBOX_matrix_random_matrix_INL
linbox/matrix/Makefile:447:	random-matrix.h           \
linbox/matrix/Makefile:448:	random-matrix.inl         \
linbox/matrix/slicedpolynomialmatrix/SlicedPolynomialMatrix.h:50:		/*! Allocates a vector of new \f$ 0 \times 0\f$ matrices (shaped and ready). Irreducible polynomial is chosen randomly.
linbox/matrix/slicedpolynomialmatrix/SlicedPolynomialMatrix.h:54:		/*Allocates a vector of $ m1 \times m2\f$ zero matrices (shaped and ready). Irreducible polynomial is chosen randomly.
linbox/matrix/Makefile.am:41:	random-matrix.h           \
linbox/matrix/Makefile.am:42:	random-matrix.inl         \
linbox/matrix/matrixdomain/matrix-domain.inl:128:		VD.random(x);
linbox/matrix/random-matrix.h:25:#ifndef __LINBOX_matrix_random_matrix_H
linbox/matrix/random-matrix.h:26:#define __LINBOX_matrix_random_matrix_H
linbox/matrix/random-matrix.h:28:/** @file matrix/random-matrix.h
linbox/matrix/random-matrix.h:30: * @brief Implementation of random matrices.
linbox/matrix/random-matrix.h:32: * We provide function to create random matrices (dense, sparse, structured)
linbox/matrix/random-matrix.h:41:#include "linbox/randiter/random-prime.h"
linbox/matrix/random-matrix.h:66:		/// random method for constructing rank
linbox/matrix/random-matrix.h:84:		Field      F_ ; //!< The field containing the random entries. @todo is there a copy made ?
linbox/matrix/random-matrix.h:86:		 * @pre need only provide <code>elmt& random(elmt&);</code>
linbox/matrix/random-matrix.h:90:		// Matrix    & A_ ; //!< The resulting random matrix
linbox/matrix/random-matrix.h:104:		/*! creates a randomly filled matrix.
linbox/matrix/random-matrix.h:105:		 * @param A matrix to be randomized.
linbox/matrix/random-matrix.h:108:		Matrix & random(Matrix & A) ;
linbox/matrix/random-matrix.h:110:		/*! Create a random matrix with rank=min(rowdim,coldim)
linbox/matrix/random-matrix.h:114:		Matrix& randomFullRank(Matrix& A);
linbox/matrix/random-matrix.h:123:		Matrix & randomRank(Matrix & A, int rank);
linbox/matrix/random-matrix.h:134:		Matrix & randomRank(Matrix & A, int rank
linbox/matrix/random-matrix.h:138:		Matrix & randomRank(Matrix & A, int rank
linbox/matrix/random-matrix.h:144:		// void randomInvertible();
linbox/matrix/random-matrix.h:146:		// void randomNilpotent(int nil k); // P N_k P^(-1)
linbox/matrix/random-matrix.h:160:#include "linbox/matrix/random-matrix.inl"
linbox/matrix/random-matrix.h:162:#endif // __LINBOX_matrix_random_matrix_H
linbox/matrix/sliced3/dense-matrix.h:213:		void randomColPermutation() {
linbox/matrix/sliced3/dense-matrix.h:221:				// Each iteration swap col j with a random col in range [j..n-1].
linbox/matrix/sliced3/dense-matrix.h:285:		void randomLowerTriangularColTransform() {
linbox/matrix/sliced3/dense-matrix.h:287:				// Each iteration swap col j with a random col in range [j..n-1].
linbox/matrix/sliced3/dense-sliced.h:143:	SlicedBase & random(){ // needs fix: not uniform, not full.
linbox/matrix/sliced3/dense-sliced.h:474:	//  returns an (approximately) random _SIZE-bit word
linbox/matrix/sliced3/dense-sliced.h:475:	SlicedWord randomLL(){
linbox/matrix/sliced3/dense-sliced.h:482:	//  completely randomizes sliced block entries
linbox/matrix/sliced3/dense-sliced.h:483:	Sliced& random(size_t seed = 0){
linbox/matrix/sliced3/dense-sliced.h:491:			(*a).b0 = randomLL();
linbox/matrix/sliced3/dense-sliced.h:492:			(*a).b1 = randomLL() & (*a).b0;
linbox/matrix/sliced3/sliced-domain.h:124:	Matrix& random(Matrix &A, size_t seed=0) const {
linbox/matrix/sliced3/sliced-domain.h:125:		return A.random(seed);
linbox/matrix/Makefile.in:447:	random-matrix.h           \
linbox/matrix/Makefile.in:448:	random-matrix.inl         \
linbox/matrix/sparsematrix/sparse-map-map-matrix.h:130:	void randomSim(Index nnz, int seed = 0);
linbox/matrix/sparsematrix/sparse-map-map-matrix.h:133:	void randomEquiv(Index nnz, int seed = 0);
linbox/matrix/sparsematrix/sparse-map-map-matrix.h:168:	// Initializes each entry of mat with a random field element
linbox/matrix/sparsematrix/sparse-map-map-matrix.h:171:	// Initialize mat with nnz non-zero random elements at random locations
linbox/matrix/sparsematrix/sparse-map-map-matrix.h:188:	static Element& nonzerorandom(const Field& F, typename Field::RandIter& r,Element& e);
linbox/matrix/sparsematrix/sparse-tpl-matrix.h:123:	 *  and rowMajor, colMajor orders are generally better than random.
linbox/matrix/sparsematrix/sparse-tpl-matrix.h:132:	 *  and rowMajor, colMajor orders are generally better than random.
linbox/matrix/sparsematrix/sparse-map-map-matrix.inl:376:void SparseMatrix<Field_,SparseMatrixFormat::SMM>::randomSim(Index nz, int seed)
linbox/matrix/sparsematrix/sparse-map-map-matrix.inl:389:		nonzerorandom(field(),r,a);
linbox/matrix/sparsematrix/sparse-map-map-matrix.inl:390:		i = ri.randomIntRange(0, rowdim()); j = ri.randomIntRange(0, coldim());
linbox/matrix/sparsematrix/sparse-map-map-matrix.inl:402:void SparseMatrix<Field_,SparseMatrixFormat::SMM>::randomEquiv(Index nz, int seed)
linbox/matrix/sparsematrix/sparse-map-map-matrix.inl:416:		nonzerorandom(field(),r,a);
linbox/matrix/sparsematrix/sparse-map-map-matrix.inl:417:		i = ri.randomIntRange(0, rowdim()); j = ri.randomIntRange(0, coldim());
linbox/matrix/sparsematrix/sparse-map-map-matrix.inl:564:	                ri.random(d);
linbox/matrix/sparsematrix/sparse-map-map-matrix.inl:592:                nonzerorandom(mat.field(),ri,d);
linbox/matrix/sparsematrix/sparse-map-map-matrix.inl:623:	        nonzerorandom(mat.field(),r,d);
linbox/matrix/sparsematrix/sparse-map-map-matrix.inl:627:        mat.randomEquiv(approxNNZ,seed);
linbox/matrix/sparsematrix/sparse-map-map-matrix.inl:661:SparseMatrix<Field_,SparseMatrixFormat::SMM>::nonzerorandom(const Field_& F,typename Field_::RandIter&r,typename Field_::Element& e)
linbox/matrix/sparsematrix/sparse-map-map-matrix.inl:664:		r.random(e);
linbox/matrix/densematrix/blas-matrix.h:538:		// init to random field elements
linbox/matrix/densematrix/blas-matrix.h:539:		void random()
linbox/matrix/densematrix/blas-matrix.h:542:			B.random();
linbox/matrix/densematrix/blas-matrix.h:546:		void random(const Rand&)
linbox/matrix/densematrix/blas-matrix.h:548:			return random();
linbox/matrix/densematrix/blas-matrix.h:932:		/// Overwrite with random elements.
linbox/matrix/densematrix/blas-matrix.h:933:		void random();
linbox/matrix/densematrix/blas-matrix.h:936:		void random(const T&)
linbox/matrix/densematrix/blas-matrix.h:938:			return random() ;
linbox/matrix/densematrix/blas-matrix.h:1225:	//! @todo b should be the random generator
linbox/matrix/densematrix/blas-matrix.h:1228:	void BlasMatrix<Givaro::ZRing<Integer>, Vector<Givaro::ZRing<Integer>>::Dense >::random<size_t>(const size_t & b)
linbox/matrix/densematrix/blas-matrix.h:1230:		// std::cout << "randomized " <<  b << std::endl;
linbox/matrix/densematrix/blas-matrix.h:1235:				R.random(refEntry(i,j));
linbox/matrix/densematrix/blas-submatrix.inl:277:	void BlasSubmatrix<_Matrix>::random()
linbox/matrix/densematrix/blas-submatrix.inl:283:				setEntry(i,j,r.random(temp));
linbox/field/envelope.h:80:		 * a wrapped field random iterator generator.
linbox/field/param-fuzzy.h:59:		 * It must meet the common object interface of random element generators
linbox/field/archetype.h:91:		/// An object of this type is a generator of random field elements.
linbox/field/archetype.h:107:		 * random element generator to which
linbox/field/archetype.h:127:		 * _elem_ptr</tt> points, and the random element
linbox/field/archetype.h:143:		 * <tt> F._elem_ptr</tt> points, and the random element
linbox/field/archetype.h:646:		 * encapsulated element and random element generator.
linbox/field/archetype.h:648:		 * Creates new copies of field, element, and random iterator generator
linbox/field/archetype.h:654:		 *                        encapsulated random iterator generator
linbox/field/archetype.h:669:		 * encapsulated element and random element generator if needed.
linbox/field/gf2.h:83:             * It must meet the common object interface of random element generators
linbox/field/multimod-field.h:423:		std::vector<double>& random(std::vector<double> &x) const
linbox/field/multimod-field.h:426:				_randiter[i]->random(x[i]);
.git/FETCH_HEAD:12:a717eddaa1cb8ceeec35810a6bdee33e1ef9873f	not-for-merge	branch 'givrandom_fixup' of https://github.com/linbox-team/linbox
.git/COMMIT_EDITMSG:22:#	modified:   ../examples/blackbox/random-rank.C
Binary file .git/objects/pack/pack-4f3992a0a5ae2455e6c7a17bb0795598f87151c8.pack matches
Binary file .git/index matches
.git/logs/HEAD:10:bdcecf9ad56b6816f6c723868a211d471978c5f1 ddac3001dba081e1aa1e4c4bb1ed74432ead5de2 ZHG <ZHG2011823@hotmail.com> 1514998816 +0100	commit: A draft test program with random integer value generation for CRA using MPI added but need to be cleaned up later
.git/logs/HEAD:31:ecf2d57237a69917c9af13de4b5305cb83f9817a e041db62bd55ab73492b733d002077b982507285 ZHG <ZHG2011823@hotmail.com> 1520497808 +0100	commit: Benchmark for solveCRA added with linbox routine to randomly fill the coefficient matrix instead of the manual way
.git/logs/refs/heads/linbox-solveCRA-mpi:4:ecf2d57237a69917c9af13de4b5305cb83f9817a e041db62bd55ab73492b733d002077b982507285 ZHG <ZHG2011823@hotmail.com> 1520497808 +0100	commit: Benchmark for solveCRA added with linbox routine to randomly fill the coefficient matrix instead of the manual way
.git/logs/refs/heads/linbox-cra-mpi:4:bdcecf9ad56b6816f6c723868a211d471978c5f1 ddac3001dba081e1aa1e4c4bb1ed74432ead5de2 ZHG <ZHG2011823@hotmail.com> 1514998816 +0100	commit: A draft test program with random integer value generation for CRA using MPI added but need to be cleaned up later
.git/sequencer/todo:4:revert a6471f3 add an accessor to the bitsize of a randomprime generator
autom4te.cache/output.4:10840:      # consuming and fragmenting process.  To avoid this, we pick a random,
autom4te.cache/output.4:14725:	# consuming and fragmenting process.  To avoid this, we pick a random,
autom4te.cache/output.2:10839:      # consuming and fragmenting process.  To avoid this, we pick a random,
autom4te.cache/output.2:14724:	# consuming and fragmenting process.  To avoid this, we pick a random,
autom4te.cache/output.1:10840:      # consuming and fragmenting process.  To avoid this, we pick a random,
autom4te.cache/output.1:14725:	# consuming and fragmenting process.  To avoid this, we pick a random,
autom4te.cache/output.3:10801:      # consuming and fragmenting process.  To avoid this, we pick a random,
autom4te.cache/output.3:14686:	# consuming and fragmenting process.  To avoid this, we pick a random,
autom4te.cache/output.0:10832:      # consuming and fragmenting process.  To avoid this, we pick a random,
autom4te.cache/output.0:14717:	# consuming and fragmenting process.  To avoid this, we pick a random,
CHANGED-INTERFACES:55:	In the random iterator interface, the operator () has been
CHANGED-INTERFACES:56:	replaced by a function random accepting a single argument --
CHANGED-INTERFACES:57:	an element type into which the random element should be
configure:10840:      # consuming and fragmenting process.  To avoid this, we pick a random,
configure:14725:	# consuming and fragmenting process.  To avoid this, we pick a random,
macros/libtool.m4:5187:      # consuming and fragmenting process.  To avoid this, we pick a random,
macros/libtool.m4:6915:	# consuming and fragmenting process.  To avoid this, we pick a random,
benchmarks/benchmark-utils.h:145:	 * @brief random <code>:alnum:</code> \c char.
benchmarks/benchmark-utils.h:151:	 * @return a random alphabetic or numeric char.
benchmarks/benchmark-utils.h:153:	char randomAlNum() ;
benchmarks/benchmark-utils.h:156:	 * @brief random <code>:alnum:</code> \c string.
benchmarks/benchmark-utils.h:163:	 * @return a random alphabetic or numeric char.
benchmarks/benchmark-utils.h:165:	std::string randomAlNum(const size_t & m) ;
benchmarks/benchmark-solveCRA.C:46:#include "linbox/matrix/random-matrix.h"
benchmarks/benchmark-solveCRA.C:97:    RDM.randomFullRank(A);
benchmarks/benchmark-solveCRA.C:105:    RDM.randomFullRank(A);
benchmarks/benchmark-solveCRA.C:112:    RDM.randomFullRank(A);
benchmarks/benchmark-solveCRA.C:119:    B.random(RI);
benchmarks/README:29:matrix class, randomMat
benchmarks/README:72:matrix constructor - eg. randomMat.  
benchmarks/benchmark-example.C:35:#include "linbox/matrix/random-matrix.h"
benchmarks/benchmark-example.C:95:		RandMat.random(A);
benchmarks/benchmark-example.C:96:		RandMat.random(B);
benchmarks/benchmark-example.C:97:		RandMat.random(C);
benchmarks/benchmark.inl:37: * graphs in files whose name is extended by a random 8-char string to avoid
benchmarks/gen-blocks.C:30:// Generates random dense matrices U and V and sparse matrix M for use
benchmarks/gen-blocks.C:53:void randomBlock(Block& block, Field& field, int q, int m, int n)
benchmarks/gen-blocks.C:64:void randomNonSingular(Block& block, Field& field, int q, int m, int n)
benchmarks/gen-blocks.C:66:  randomBlock(block,field,q,m,n);
benchmarks/gen-blocks.C:71:    randomBlock(block,field,q,m,n);
benchmarks/gen-blocks.C:137:	randomNonSingular(U,F,q,b,n);
benchmarks/gen-blocks.C:138:	randomNonSingular(V,F,q,n,b);
benchmarks/.deps/benchmark-solveCRA.Po:146: /usr/include/c++/5/bits/stl_construct.h /usr/include/c++/5/random \
benchmarks/.deps/benchmark-solveCRA.Po:147: /usr/include/c++/5/bits/random.h /usr/include/c++/5/vector \
benchmarks/.deps/benchmark-solveCRA.Po:152: /usr/include/x86_64-linux-gnu/c++/5/bits/opt_random.h \
benchmarks/.deps/benchmark-solveCRA.Po:206: /usr/include/c++/5/bits/random.tcc /usr/include/c++/5/numeric \
benchmarks/.deps/benchmark-solveCRA.Po:227: /home/zhg/soft/builds/include/givaro/givrandom.h \
benchmarks/.deps/benchmark-solveCRA.Po:234: /home/zhg/soft/builds/include/givaro/random-integer.h \
benchmarks/.deps/benchmark-solveCRA.Po:281: /home/zhg/soft/builds/include/recint/rurandom.h \
benchmarks/.deps/benchmark-solveCRA.Po:437: /home/zhg/soft/builds/include/recint/rmrandom.h \
benchmarks/.deps/benchmark-solveCRA.Po:446: /home/zhg/soft/builds/include/recint/rrandom.h \
benchmarks/.deps/benchmark-solveCRA.Po:625: /home/zhg/soft/builds/include/fflas-ffpack/utils/fflas_randommatrix.h \
benchmarks/.deps/benchmark-solveCRA.Po:759: ../linbox/randiter/random-prime.h ../linbox/algorithms/cra-domain-omp.h \
benchmarks/.deps/benchmark-solveCRA.Po:784: ../linbox/randiter/multimod-randomprime.h \
benchmarks/.deps/benchmark-solveCRA.Po:806: ../linbox/randiter/random-fftprime.h ../linbox/algorithms/echelon-form.h \
benchmarks/.deps/benchmark-solveCRA.Po:833: ../linbox/matrix/random-matrix.h \
benchmarks/.deps/benchmark-solveCRA.Po:835: ../linbox/matrix/random-matrix.inl
benchmarks/.deps/benchmark-solveCRA.Po:1219:/usr/include/c++/5/random:
benchmarks/.deps/benchmark-solveCRA.Po:1221:/usr/include/c++/5/bits/random.h:
benchmarks/.deps/benchmark-solveCRA.Po:1235:/usr/include/x86_64-linux-gnu/c++/5/bits/opt_random.h:
benchmarks/.deps/benchmark-solveCRA.Po:1343:/usr/include/c++/5/bits/random.tcc:
benchmarks/.deps/benchmark-solveCRA.Po:1393:/home/zhg/soft/builds/include/givaro/givrandom.h:
benchmarks/.deps/benchmark-solveCRA.Po:1407:/home/zhg/soft/builds/include/givaro/random-integer.h:
benchmarks/.deps/benchmark-solveCRA.Po:1501:/home/zhg/soft/builds/include/recint/rurandom.h:
benchmarks/.deps/benchmark-solveCRA.Po:1893:/home/zhg/soft/builds/include/recint/rmrandom.h:
benchmarks/.deps/benchmark-solveCRA.Po:1913:/home/zhg/soft/builds/include/recint/rrandom.h:
benchmarks/.deps/benchmark-solveCRA.Po:2275:/home/zhg/soft/builds/include/fflas-ffpack/utils/fflas_randommatrix.h:
benchmarks/.deps/benchmark-solveCRA.Po:2599:../linbox/randiter/random-prime.h:
benchmarks/.deps/benchmark-solveCRA.Po:2671:../linbox/randiter/multimod-randomprime.h:
benchmarks/.deps/benchmark-solveCRA.Po:2721:../linbox/randiter/random-fftprime.h:
benchmarks/.deps/benchmark-solveCRA.Po:2787:../linbox/matrix/random-matrix.h:
benchmarks/.deps/benchmark-solveCRA.Po:2791:../linbox/matrix/random-matrix.inl:
benchmarks/.deps/benchmark.Plo:141: /usr/include/c++/5/bits/stl_construct.h /usr/include/c++/5/random \
benchmarks/.deps/benchmark.Plo:142: /usr/include/c++/5/bits/random.h /usr/include/c++/5/vector \
benchmarks/.deps/benchmark.Plo:147: /usr/include/x86_64-linux-gnu/c++/5/bits/opt_random.h \
benchmarks/.deps/benchmark.Plo:200: /usr/include/c++/5/bits/random.tcc /usr/include/c++/5/numeric \
benchmarks/.deps/benchmark.Plo:222: /home/zhg/soft/builds/include/givaro/givrandom.h \
benchmarks/.deps/benchmark.Plo:264: /home/zhg/soft/builds/include/givaro/random-integer.h \
benchmarks/.deps/benchmark.Plo:296: /home/zhg/soft/builds/include/recint/rurandom.h \
benchmarks/.deps/benchmark.Plo:746:/usr/include/c++/5/random:
benchmarks/.deps/benchmark.Plo:748:/usr/include/c++/5/bits/random.h:
benchmarks/.deps/benchmark.Plo:762:/usr/include/x86_64-linux-gnu/c++/5/bits/opt_random.h:
benchmarks/.deps/benchmark.Plo:868:/usr/include/c++/5/bits/random.tcc:
benchmarks/.deps/benchmark.Plo:920:/home/zhg/soft/builds/include/givaro/givrandom.h:
benchmarks/.deps/benchmark.Plo:1052:/home/zhg/soft/builds/include/givaro/random-integer.h:
benchmarks/.deps/benchmark.Plo:1116:/home/zhg/soft/builds/include/recint/rurandom.h:
benchmarks/benchmark-metadata.h:158:			name[1] = name[0] + '_' + randomAlNum(8) ;
benchmarks/benchmark-metadata.h:226:			name[1] = key + "_" + randomAlNum(8) ;
benchmarks/benchmark-metadata.h:380:			if (getMetaDataSize() == 1) { // first the field. (@todo search for fields, then search for random generator.)
benchmarks/benchmark.C:1113:		UID.push_back("point_" + randomAlNum(8));
benchmarks/benchmark.C:1128:		void PlotGraph::_randomName()
benchmarks/benchmark.C:1131:			unique_filename << _filename_ << '_' << getDateTime("_") << '_' << randomAlNum(4);
benchmarks/benchmark.C:1142:				_randomName();
benchmarks/benchmark-utils.C:254:	char randomAlNum()
benchmarks/benchmark-utils.C:275:	std::string randomAlNum(const size_t & m)
benchmarks/benchmark-utils.C:279:			r += randomAlNum();
Binary file benchmarks/.libs/libbenchmarks.a matches
Binary file benchmarks/.libs/benchmark.o matches
Binary file benchmarks/benchmark.o matches
benchmarks/benchmark.h:37: * graphs in files whose name is extended by a random 8-char string to avoid
benchmarks/benchmark.h:909:	 * @warning the filename will get a random suffix before the extension
benchmarks/benchmark.h:919:		std::string         _filename_ ;   //!< name for the output file (without extension). a random \c _XXXXXX suffix will be added to make it unique.
benchmarks/benchmark.h:920:		std::string        _printname_ ;   //!< name for the output file (without extension) to be printed. a random \c _XXXXXX suffix makes it unique.
benchmarks/benchmark.h:927:		 * @brief Appends random suffix.
benchmarks/benchmark.h:928:		 * Appends to \p _filename_ a random string constituted of an
benchmarks/benchmark.h:929:		 * underscore followed by 8 random alnum chars.
benchmarks/benchmark.h:932:		void _randomName();
benchmarks/benchmark-order-basis.C:12:#include "linbox/randiter/random-fftprime.h"
benchmarks/benchmark-order-basis.C:13:#include "linbox/randiter/random-prime.h"
benchmarks/benchmark-order-basis.C:283:	// set the Serie at random
benchmarks/benchmark-order-basis.C:287:				Gen.random(Serie->ref(i,j,k));
benchmarks/benchmark-order-basis.C:354:		{ 's', "-s s", "Set the random seed to a specific value", TYPE_INT, &seed},
benchmarks/benchmark-order-basis.C:379:		integer p = Rd.randomPrime(logd+1);
TODO:8: - Test suite for random iterators
TODO:63:10) uniformly distributed random integers ! (in checks)
doc/mainpage.doxy:155: *       - linbox/<a href="group__randiter.html">randiter</a>, random element
ChangeLog:170:	* linbox/randiter/{Makefile.am,random-fftprime.h}: add fftprime generator
ChangeLog:577:	* randiter/gmp-random-prime.h Generates random numbers up to a given size
ChangeLog:719:		* rational-solver.inl       : Added blas optimization for preconditionning matrices in random solution solver
ChangeLog:748:		* vector-fraction.h - Added comment, about how RandIter may have unrandom low-order bits
ChangeLog:758:	* examples/solver/t-rdisolve.C - added flag to make some columns zero, made better random entries 
ChangeLog:827:		* rational-solver.inl - added generation of a partial certificate to randomSolve
ChangeLog:860:			- in singular/random solve, check solution before returning, and multiply by conditioner P correctly
ChangeLog:861:			- added consistency check to random solver
ChangeLog:882:			- changed random generator to give fuller range
ChangeLog:887:	* linbox/randiter/random-prime.h - the class now takes a 'bits' argument on construction and makes primes of that size
ChangeLog:907:	* linbox/randiter/envelope.h : modify random function ( assignement is not needed)
ChangeLog:1027:           and a chi-sq randomiterator check that doesn't fail on reasonably
ChangeLog:1028:           uniform random iterators over int elements.
ChangeLog:1035:	  Added linbox/randiter/generic.h which is a generic random iterator
ChangeLog:1127:	* add linbox/blackbox/apply.h, linbox/blackbox/scompose.h, linbox/blackbox/compose-traits.h, linbox/blackbox/random-matrix-traits.h, linbox/blackbox/random-matrix.h, linbox/blackbox/submatrix-traits.h, linbox/algorithms/ith-invariant-factor.h, linbox/algorithms/last-invariant-factor.h, linbox/algorithms/matrix-inverse.h, linbox/algorithms/matrix-mod.h, linbox/algorithms/smith-form.h, implement EGV/EGV+/EGV++ algorithm for Smith Form computation.
ChangeLog:1281:	* linbox/field/ntl* linbox/randiter/mersenne-twister.* linbox/randiter/unparametric.h, make them work with the new random memebr function.
ChangeLog:1287:	* linbox/randiter/*.h, make each random member function to be a const member function in each random class, since the member will not change the instantiation of the random class at all, just generate a random element.
ChangeLog:1336:  	* linbox/field/ntl* linbox/randiter/mersenne-twister.* linbox/randiter/unparametric.h, make them work with the new random memebr function.
ChangeLog:1342:  	* linbox/randiter/*.h, make each random member function to be a const member function in each random class, since the member will not change the instantiation of the random class at all, just generate a random element.
ChangeLog:1643:	* linbox/randiter/modular.h, replace static-cast with init in the random function.
ChangeLog:1923:	(MersenneTwister::randomDoubleRange): Move this to the header file
ChangeLog:1925:	* linbox/randiter/mersenne-twister.C (randomInt): Make this not
ChangeLog:1934:	(GF2RandIter::random): Overload with two reference types rather
ChangeLog:1986:	(class RandomSparseStream): Declare the base random iterator
ChangeLog:1991:	Mersenne Twister random number generator
ChangeLog:2094:	* examples/blackbox/Makefile.am (EXTRA_PROGRAMS): Add random-rank
ChangeLog:2896:	constructor that accepts random iterator
ChangeLog:2901:	to use the random iterator, or to use b for the Krylov sequence
ChangeLog:2937:	  findRandomSolution - Find a random solution to a singular preconditioned problem
ChangeLog:3020:	(testCekstvSwitch): Construct a random vector and pass it to
ChangeLog:3055:	(solveWiedemannSingular): Fix generator for random solution
ChangeLog:3216:	* linbox/randiter/param-fuzzy.h (ParamFuzzyRandIter::random):
ChangeLog:3237:	* linbox/randiter/unparametric.h (UnparametricRandIter::random):
ChangeLog:3266:	(GMPRationalRandIter::random): Initialize value properly
ChangeLog:3267:	(GMPRationalRandIter::random): Canonicalize before returning
ChangeLog:3429:	     allows, e.g. construction of a random dense vector in sparse
ChangeLog:3530:	* linbox/randiter/modular.h (ModularRandIter::random): Fix call to
ChangeLog:3613:	* linbox/randiter/modular.h (ModularRandIter::random): Protect
ChangeLog:3622:	(ModularRandIter::random): Don't use temp_integer; don't mod out
ChangeLog:3769:	* linbox/randiter/modular.h (ModularRandIter::random): Remove
ChangeLog:4188:	RandomSparseParVectorFactory): Added this class for random sparse
ChangeLog:4356:	* gmp++/gmp++_int.inl (Integer::random): Eliminate default from
ChangeLog:4786:	Add constructor specifying a particular random iterator
ChangeLog:5177:	* linbox/randiter/modular.h: Seeded random number generator in constructor.  _seed was
ChangeLog:5182:	* linbox/field/ntl-zz_p.h, ntl-ZZ_p.h: modified random generator constructor and
ChangeLog:5484:	* linbox/field/ntl.h: Fixed random iterator random(x) for zz_p
examples/sparseelimrank.C:65:		/* We could pick a random prime and work mod that prime, But the point here
examples/iliopoulos2.C:33:#include "linbox/matrix/random-matrix.h"
examples/iliopoulos2.C:72:void randomL(Matrix &L) {
examples/iliopoulos2.C:75:	RDM.random(L);
examples/iliopoulos2.C:86:void randomU(Matrix &U) {
examples/iliopoulos2.C:89:	RDM.random(U);
examples/iliopoulos2.C:104:	//RDM.random(A);
examples/iliopoulos2.C:111:	randomL(L1);
examples/iliopoulos2.C:114:	randomU(U1);
examples/iliopoulos2.C:117:	randomL(L2);
examples/iliopoulos2.C:120:	randomU(U2);
examples/smith-form-kb.C:17:#include "linbox/matrix/random-matrix.h"
examples/solver/t-rdisolve.C:58:#include "linbox/randiter/random-prime.h"
examples/solver/t-rdisolve.C:77:#define random_01() ((double)rand() / ((double)(RAND_MAX)+1))
examples/solver/t-rdisolve.C:110:	{ 'q', 0, "Solve first over the field Z/qZ (0: pick randomly)",  TYPE_INT,     &defaultPrime },
examples/solver/t-rdisolve.C:112:	{ 'r', 0, "Set random solving on/off",                           TYPE_BOOL,    &useRandom },
examples/solver/t-rdisolve.C:126:	{ 'o', 0, "Set o columns to zero at random",                     TYPE_INT,     &destroyColumns}
examples/solver/t-rdisolve.C:224:			cout << "Solving randomly.\n";
examples/solver/t-rdisolve.C:225:			s = zsolver.randomSolve(x.numer, x.denom, A, b, numPrimes, level);
examples/solver/t-rdisolve.C:399:		auxRow[i] = (random_01() <= singularProportion);
examples/solver/t-rdisolve.C:405:	{ auxRows++; auxRow[(int)(random_01()*n)] = true; }
examples/solver/t-rdisolve.C:421:		ri.random(bentries[i]);
examples/solver/t-rdisolve.C:423:		if (notRandomEnough) bentries[i] += static_cast<int>((random_01()-0.5)*bigStuff);
examples/solver/t-rdisolve.C:427:		ri.random(Aentries[i]);
examples/solver/t-rdisolve.C:429:		if (notRandomEnough) Aentries[i] += static_cast<int>((random_01()-0.5)*bigStuff);
examples/solver/t-rdisolve.C:432:	int whichInconsistent = (int)(random_01()*auxRows);
examples/solver/t-rdisolve.C:440:					int m = (int)(random_01()*2)*2 - 1;
examples/solver/t-rdisolve.C:447:					bentries[i] += (int)(random_01()*2)*2 - 1;
examples/solver/t-rdisolve.C:461:		if (random_01()*(c-i-1) < columnsToDestroy) {
examples/bench-new-fft.C:40:#include "linbox/randiter/random-fftprime.h"
examples/bench-new-fft.C:49:void randomVect (Rand& r, Vect& v) {
examples/bench-new-fft.C:52:		r.random(v[i]);
examples/bench-new-fft.C:99:		// Generate random inputs
examples/bench-new-fft.C:101:		randomVect(Gen,y);
examples/bench-new-fft.C:207:		// Generate random inputs
examples/bench-new-fft.C:209:		randomVect(Gen,x);
examples/bench-new-fft.C:274:	// p = (double)Rd.randomPrime(l2n);
examples/bench-new-fft.C:287:	p = (uint64_t)Rd.randomPrime(l2n);
examples/bench-new-fft.C:299:	p = (uint32_t)Rd.randomPrime(l2n);
examples/bench-new-fft.C:312:	p = (uint16_t)Rd.randomPrime(l2n);
examples/grid_reduce.C:54:		<< "source is `random', `random-rough', `fib', `tref', or a filename " << std::endl
Binary file examples/smithvalence.o matches
examples/omp_block_rank.C:263:			generator.random( *vit );
examples/omp_block_rank.C:297:		do generator.random (d1[i]); while (F.isZero (d1[i]));
examples/omp_block_rank.C:301:		do generator.random (d2[i]); while (F.isZero (d2[i]));
examples/omp_block_rank.C:436:			do generator.random (*itp); while (F.isZero (*itp));
examples/omp_block_rank.C:544:        // argv[4]: [optional] random generator seed
examples/nullspacebasis_rank.C:41:    std::cerr << "Usage to get a random null space basis over GF(p,k):  <matrix-file-in-SMS-format> p [k]" << std::endl;
examples/mats.C:81:		cout << " type = `random', `random-rough', `tref', or `fib',"
examples/mats.C:113:	int N,n = (int)M.rowdim(); // number of random basic row and col ops.
examples/mats.C:321:  "random-rough"
examples/mats.C:324:  "random"
examples/mats.C:341:	if (src == "random-rough") RandomRoughMat(M, R, n);
examples/mats.C:343:	else if (src == "random") RandomFromDiagMat(M, R, n);
examples/.deps/smithvalence.Po:143: /usr/include/c++/5/bits/stl_construct.h /usr/include/c++/5/random \
examples/.deps/smithvalence.Po:144: /usr/include/c++/5/bits/random.h /usr/include/c++/5/vector \
examples/.deps/smithvalence.Po:149: /usr/include/x86_64-linux-gnu/c++/5/bits/opt_random.h \
examples/.deps/smithvalence.Po:202: /usr/include/c++/5/bits/random.tcc /usr/include/c++/5/numeric \
examples/.deps/smithvalence.Po:224: /home/zhg/soft/builds/include/givaro/givrandom.h \
examples/.deps/smithvalence.Po:233: /home/zhg/soft/builds/include/givaro/random-integer.h \
examples/.deps/smithvalence.Po:273: /home/zhg/soft/builds/include/recint/rurandom.h \
examples/.deps/smithvalence.Po:429: /home/zhg/soft/builds/include/recint/rmrandom.h \
examples/.deps/smithvalence.Po:438: /home/zhg/soft/builds/include/recint/rrandom.h \
examples/.deps/smithvalence.Po:617: /home/zhg/soft/builds/include/fflas-ffpack/utils/fflas_randommatrix.h \
examples/.deps/smithvalence.Po:683: ../linbox/randiter/multimod-randomprime.h \
examples/.deps/smithvalence.Po:698: ../linbox/randiter/random-fftprime.h ../linbox/randiter/random-prime.h \
examples/.deps/smithvalence.Po:728: ../linbox/blackbox/random-matrix-traits.h \
examples/.deps/smithvalence.Po:751: ../linbox/blackbox/random-matrix.h ../linbox/blackbox/scompose.h \
examples/.deps/smithvalence.Po:1147:/usr/include/c++/5/random:
examples/.deps/smithvalence.Po:1149:/usr/include/c++/5/bits/random.h:
examples/.deps/smithvalence.Po:1163:/usr/include/x86_64-linux-gnu/c++/5/bits/opt_random.h:
examples/.deps/smithvalence.Po:1269:/usr/include/c++/5/bits/random.tcc:
examples/.deps/smithvalence.Po:1321:/home/zhg/soft/builds/include/givaro/givrandom.h:
examples/.deps/smithvalence.Po:1339:/home/zhg/soft/builds/include/givaro/random-integer.h:
examples/.deps/smithvalence.Po:1429:/home/zhg/soft/builds/include/recint/rurandom.h:
examples/.deps/smithvalence.Po:1827:/home/zhg/soft/builds/include/recint/rmrandom.h:
examples/.deps/smithvalence.Po:1845:/home/zhg/soft/builds/include/recint/rrandom.h:
examples/.deps/smithvalence.Po:2207:/home/zhg/soft/builds/include/fflas-ffpack/utils/fflas_randommatrix.h:
examples/.deps/smithvalence.Po:2363:../linbox/randiter/multimod-randomprime.h:
examples/.deps/smithvalence.Po:2395:../linbox/randiter/random-fftprime.h:
examples/.deps/smithvalence.Po:2397:../linbox/randiter/random-prime.h:
examples/.deps/smithvalence.Po:2467:../linbox/blackbox/random-matrix-traits.h:
examples/.deps/smithvalence.Po:2531:../linbox/blackbox/random-matrix.h:
examples/.deps/solve.Po:146: /usr/include/c++/5/bits/stl_construct.h /usr/include/c++/5/random \
examples/.deps/solve.Po:147: /usr/include/c++/5/bits/random.h /usr/include/c++/5/vector \
examples/.deps/solve.Po:152: /usr/include/x86_64-linux-gnu/c++/5/bits/opt_random.h \
examples/.deps/solve.Po:206: /usr/include/c++/5/bits/random.tcc /usr/include/c++/5/numeric \
examples/.deps/solve.Po:226: /home/zhg/soft/builds/include/givaro/givrandom.h \
examples/.deps/solve.Po:235: /home/zhg/soft/builds/include/givaro/random-integer.h \
examples/.deps/solve.Po:283: /home/zhg/soft/builds/include/recint/rurandom.h \
examples/.deps/solve.Po:427: /home/zhg/soft/builds/include/recint/rmrandom.h \
examples/.deps/solve.Po:436: /home/zhg/soft/builds/include/recint/rrandom.h \
examples/.deps/solve.Po:591: /home/zhg/soft/builds/include/fflas-ffpack/utils/fflas_randommatrix.h \
examples/.deps/solve.Po:695: ../linbox/randiter/random-prime.h \
examples/.deps/solve.Po:722: ../linbox/randiter/multimod-randomprime.h \
examples/.deps/solve.Po:744: ../linbox/randiter/random-fftprime.h ../linbox/algorithms/echelon-form.h \
examples/.deps/solve.Po:1153:/usr/include/c++/5/random:
examples/.deps/solve.Po:1155:/usr/include/c++/5/bits/random.h:
examples/.deps/solve.Po:1169:/usr/include/x86_64-linux-gnu/c++/5/bits/opt_random.h:
examples/.deps/solve.Po:1277:/usr/include/c++/5/bits/random.tcc:
examples/.deps/solve.Po:1325:/home/zhg/soft/builds/include/givaro/givrandom.h:
examples/.deps/solve.Po:1343:/home/zhg/soft/builds/include/givaro/random-integer.h:
examples/.deps/solve.Po:1439:/home/zhg/soft/builds/include/recint/rurandom.h:
examples/.deps/solve.Po:1805:/home/zhg/soft/builds/include/recint/rmrandom.h:
examples/.deps/solve.Po:1825:/home/zhg/soft/builds/include/recint/rrandom.h:
examples/.deps/solve.Po:2139:/home/zhg/soft/builds/include/fflas-ffpack/utils/fflas_randommatrix.h:
examples/.deps/solve.Po:2395:../linbox/randiter/random-prime.h:
examples/.deps/solve.Po:2473:../linbox/randiter/multimod-randomprime.h:
examples/.deps/solve.Po:2523:../linbox/randiter/random-fftprime.h:
examples/.deps/solverat.Po:129: /usr/include/c++/5/bits/stl_construct.h /usr/include/c++/5/random \
examples/.deps/solverat.Po:141: /usr/include/c++/5/bits/random.h /usr/include/c++/5/vector \
examples/.deps/solverat.Po:146: /usr/include/x86_64-linux-gnu/c++/5/bits/opt_random.h \
examples/.deps/solverat.Po:200: /usr/include/c++/5/bits/random.tcc /usr/include/c++/5/numeric \
examples/.deps/solverat.Po:221: /home/zhg/soft/builds/include/givaro/givrandom.h \
examples/.deps/solverat.Po:230: /home/zhg/soft/builds/include/givaro/random-integer.h \
examples/.deps/solverat.Po:278: /home/zhg/soft/builds/include/recint/rurandom.h \
examples/.deps/solverat.Po:429: /home/zhg/soft/builds/include/recint/rmrandom.h \
examples/.deps/solverat.Po:438: /home/zhg/soft/builds/include/recint/rrandom.h \
examples/.deps/solverat.Po:593: /home/zhg/soft/builds/include/fflas-ffpack/utils/fflas_randommatrix.h \
examples/.deps/solverat.Po:697: ../linbox/randiter/random-prime.h \
examples/.deps/solverat.Po:724: ../linbox/randiter/multimod-randomprime.h \
examples/.deps/solverat.Po:746: ../linbox/randiter/random-fftprime.h ../linbox/algorithms/echelon-form.h \
examples/.deps/solverat.Po:1115:/usr/include/c++/5/random:
examples/.deps/solverat.Po:1141:/usr/include/c++/5/bits/random.h:
examples/.deps/solverat.Po:1155:/usr/include/x86_64-linux-gnu/c++/5/bits/opt_random.h:
examples/.deps/solverat.Po:1263:/usr/include/c++/5/bits/random.tcc:
examples/.deps/solverat.Po:1315:/home/zhg/soft/builds/include/givaro/givrandom.h:
examples/.deps/solverat.Po:1333:/home/zhg/soft/builds/include/givaro/random-integer.h:
examples/.deps/solverat.Po:1429:/home/zhg/soft/builds/include/recint/rurandom.h:
examples/.deps/solverat.Po:1807:/home/zhg/soft/builds/include/recint/rmrandom.h:
examples/.deps/solverat.Po:1827:/home/zhg/soft/builds/include/recint/rrandom.h:
examples/.deps/solverat.Po:2141:/home/zhg/soft/builds/include/fflas-ffpack/utils/fflas_randommatrix.h:
examples/.deps/solverat.Po:2397:../linbox/randiter/random-prime.h:
examples/.deps/solverat.Po:2475:../linbox/randiter/multimod-randomprime.h:
examples/.deps/solverat.Po:2525:../linbox/randiter/random-fftprime.h:
examples/nullspacebasis.C:42:		std::cerr << "Usage to get a random null space basis over GF(p,k):  <matrix-file-in-SMS-format> p [k]" << std::endl;
examples/rank.C:77:		/* We could pick a random prime and work mod that prime, But
examples/bench-fft.C:38:#include "linbox/randiter/random-fftprime.h"
examples/bench-fft.C:47:void randomVect (Rand& r, Vect& v) {
examples/bench-fft.C:50:		r.random(v[i]);
examples/bench-fft.C:97:		// Generate random inputs
examples/bench-fft.C:99:		randomVect(Gen,y);
examples/bench-fft.C:189:		// Generate random inputs
examples/bench-fft.C:191:		randomVect(Gen,x);
examples/bench-fft.C:242:	uint32_t p = (uint32_t)Rd.randomPrime(5);
examples/solve.C:104:			std::cerr << "Creating a random {-1,1} vector U, B is AU (to have a consistent system)" << std::endl;
examples/solve.C:208:			std::cerr << "Creating a random {-1,1} vector U, B is AU" << std::endl;
Binary file examples/.libs/smithvalence matches
examples/bench-matpoly-mult.C:52:#include <linbox/randiter/random-prime.h>
examples/bench-matpoly-mult.C:53:#include <linbox/randiter/random-fftprime.h>
examples/bench-matpoly-mult.C:92:void randomVect (Rand& r, Vect& v) {
examples/bench-matpoly-mult.C:95:		r.random(v[i]); 
examples/bench-matpoly-mult.C:99:void randomMat (Rand& r, Mat& m) {
examples/bench-matpoly-mult.C:102:			r.random(m.refEntry(i,j));
examples/bench-matpoly-mult.C:157:	// Generate random matrix of polynomial
examples/bench-matpoly-mult.C:159:		randomMat(Gen,A[i]);
examples/bench-matpoly-mult.C:160:		randomMat(Gen,B[i]);
examples/bench-matpoly-mult.C:235:	// Generate random matrix of polynomial
examples/bench-matpoly-mult.C:237:		randomMat(Gen,A[i]);
examples/bench-matpoly-mult.C:238:		randomMat(Gen,B[i]);
examples/bench-matpoly-mult.C:305:	// Generate random matrix of polynomial
examples/bench-matpoly-mult.C:307:		randomVect(Gen,A(i));
examples/bench-matpoly-mult.C:308:		randomVect(Gen,B(i));
examples/bench-matpoly-mult.C:399:	// Generate random matrix of polynomial
examples/bench-matpoly-mult.C:401:		randomMat(Gen,A[i]);
examples/bench-matpoly-mult.C:402:		randomMat(Gen,B[i]);
examples/bench-matpoly-mult.C:427:	// Generate random matrix of polynomial
examples/bench-matpoly-mult.C:429:		randomVect(Gen,A(i));
examples/bench-matpoly-mult.C:432:		randomVect(Gen,B(i));
examples/bench-matpoly-mult.C:480:		{ 's', "-s s", "Set the random seed to a specific value", TYPE_INT, &seed},
examples/bench-matpoly-mult.C:515:				integer p = Rd.randomPrime(integer(d).bitsize()+1);
examples/minpoly.C:92://		BT.random();
examples/map-sparse.h:134:	void randomSim(Index nnz, int seed = 0);
examples/map-sparse.h:137:	void randomEquiv(Index nnz, int seed = 0);
examples/blassolve.C:81:        std::cerr << "Creating a random {-1,1} vector " << std::endl;
examples/genprime.C:4:#include "linbox/randiter/random-prime.h"
examples/blackbox/random-rank.C:2: * examples/blackbox/random-rank.C
examples/blackbox/random-rank.C:23:/** @name examples/blackbox/random-rank.C
examples/blackbox/Makefile.am:24:EXTRA_PROGRAMS = smith example ex-mat0 load-det load-minpoly load-symmetrize random-rank
examples/blackbox/Makefile.am:35:random_rank_SOURCES = random-rank.C
examples/blackbox/smith.C:73:		<< "source is `random', `random-rough', `fib', `tref', or a filename \n"
examples/blackbox/smith.C:211:  "random-rough"
examples/blackbox/smith.C:214:  "random"
examples/blackbox/smith.C:233:	if (src == "random-rough") RandomRoughMat(M, R, n);
examples/blackbox/smith.C:235:	else if (src == "random") RandomFromDiagMat(M, R, n);
examples/blackbox/smith.C:395:	int N,n = M.rowdim(); // number of random basic row and col ops.
examples/map-sparse-test.C:46:	ms.randomSim(5*n);
examples/map-sparse-test.C:49:	ms.randomEquiv(n*n/2);
examples/poly-smith.C:84:		cout << "Generates a random GF(p)^(n-by-n) with polynomial coefficients with degree=d" << endl;
examples/poly-smith.C:107:			Rand.random(tmp, Givaro::Degree(d));
examples/samplebb.C:32: * randomized matrix (because of the '-r' option) matrix which is similar
examples/samplebb.C:43: *  -r lightly randomized similarity transform, matrix remains sparse.
examples/samplebb.C:44: *  -R fully randomized similarity transform, matrix becomes dense.
examples/samplebb.C:138:	int N,n = M.rowdim(); // number of random basic row and col ops.
examples/samplebb.C:221:		"for lightly randomized matrix similar to direct sum of 3 copies of companion " << std::endl
examples/map-sparse.inl:307:void MapSparse<Field_>::randomSim(Index nz, int seed)
examples/map-sparse.inl:320:	{	field().nonzerorandom(r,a);
examples/map-sparse.inl:321:		i = ri.randomIntRange(0, rowdim()); j = ri.randomIntRange(0, coldim());
examples/map-sparse.inl:331:void MapSparse<Field_>::randomEquiv(Index nz, int seed)
examples/map-sparse.inl:345:	{	r.nonzerorandom(a);
examples/map-sparse.inl:346:		i = ri.randomIntRange(0, rowdim()); j = ri.randomIntRange(0, coldim());
examples/map-sparse.inl:548:                r.nonzerorandom(d);
examples/map-sparse.inl:552:        mat.randomEquiv(approxNNZ,seed);
examples/dot-product.C:26: * \brief Timings on dot products of random vectors.
examples/dot-product.C:34: * Constructs random vectors and computes their dot product, giving the
examples/sparsesolverat.C:80:			cerr << "Creating a random {-1,1} vector " << endl;
examples/sparsesolverat.C:95:            // Generator for a random solution if over-determined
examples/solverat.C:88:			cerr << "Creating a random {-1,1} vector " << endl;
interfaces/maple-old/demonstration.mws:282: a diagonal Matrix with random entries." }}}{EXCHG {PARA 0 "" 0 "" 
interfaces/maple-old/lbmaple.C:940:    // There are probably a million better random number generators, but for the moment I use this one
interfaces/maple-old/lbmaple.C:951:    // Get the random key from Maple
interfaces/maple/linbox-demonstration.mw:1970:<Text-field style="Text" layout="Normal"> <Font size="14">Set entries at random over the domain</Font></Text-field>
interfaces/maple/linbox-demonstration.mw:2107:<Text-field style="Text" layout="Normal"> <Font size="14">Set entries at random over the domain</Font></Text-field>
interfaces/maple/linbox-demonstration-good.mw:1970:<Text-field style="Text" layout="Normal"> <Font size="14">Set entries at random over the domain</Font></Text-field>
interfaces/maple/linbox-demonstration-good.mw:2107:<Text-field style="Text" layout="Normal"> <Font size="14">Set entries at random over the domain</Font></Text-field>
interfaces/maple/lb-maple.C:491:	 * Interface to fill a blackbox with random value *
interfaces/maple/lb-maple.C:589:	 * Interface to fill a vector with random value *
interfaces/maple/lb-maple.C:1021:	 * fill randomly a linbox object  *
interfaces/driver/lb-blackbox.h:69: * API to set a blackbox with random value *
interfaces/driver/lb-vector.h:62: * API to set a vector with random value *
interfaces/driver/lb-vector.C:125: * API to set a vector with random value *
interfaces/driver/lb-vector.C:144:			G.random((*V)[i]);
interfaces/driver/lb-vector.C:171:			throw lb_runtime_error("LinBox ERROR: invalid vector (set random value impossible)");
interfaces/driver/lb-blackbox.C:109: * API to set a blackbox with random value *
interfaces/driver/lb-blackbox.C:116:		throw lb_runtime_error("LinBox ERROR: incompatible blackbox type and domain type  (set random value  impossible)\n");
interfaces/driver/lb-blackbox.C:125:		throw lb_runtime_error("LinBox ERROR: impossible to set random value (storage is a real blackbox)\n");
interfaces/driver/lb-blackbox.C:137:				G.random(B->refEntry(i,j));
interfaces/driver/lb-blackbox.C:164:			throw lb_runtime_error("LinBox ERROR: invalid blackbox (set random value impossible)");
